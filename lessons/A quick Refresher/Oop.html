<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="apple-touch-icon" sizes="180x180" href="/complete-intro-to-spring-and-springBoot/images/apple-touch-icon.png" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/complete-intro-to-spring-and-springBoot/images/favicon-32x32.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/complete-intro-to-spring-and-springBoot/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/complete-intro-to-spring-and-springBoot/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/x-icon" href="/complete-intro-to-spring-and-springBoot/images/favicon.ico" data-next-head=""/><title data-next-head="">Oop ‚Äì Complete intro to Spring and Spring boot</title><meta name="description" content="" data-next-head=""/><meta name="keywords" content="java,spring,spring boot,enterprise" data-next-head=""/><meta name="og:description" content="" data-next-head=""/><meta name="og:title" content="Oop ‚Äì Complete intro to Spring and Spring boot" data-next-head=""/><meta name="og:image" content="/complete-intro-to-spring-and-springBoot/images/social-share-cover.jpg" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/complete-intro-to-spring-and-springBoot/_next/static/css/a177a108a1e5ef8e.css" as="style"/><link rel="stylesheet" href="/complete-intro-to-spring-and-springBoot/_next/static/css/a177a108a1e5ef8e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/webpack-ef71630eba064876.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/framework-2f335d22a7318891.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/main-68b275a1c1cc8358.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/pages/_app-f402e663bac92a23.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-76fa85589bbed6c1.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/xTwxhuCtUf2QTtgk5CpXn/_buildManifest.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/xTwxhuCtUf2QTtgk5CpXn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/complete-intro-to-spring-and-springBoot">Complete intro to Spring and Spring boot</a></h1><div class="navbar-info"><a href="https://www.youtube.com/@thisis3mr" class="cta-btn">Watch on youtube</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><h1><strong>Introduction to Object-Oriented Programming (OOP) in Java</strong></h1>
<p>Welcome to the second part of our Java refresher course.
In this section, we‚Äôll start exploring <strong>Object-Oriented Programming (OOP)</strong> ‚Äî the most widely used programming paradigm in Java.</p>
<hr>
<h2>What is OOP?</h2>
<p>OOP (Object-Oriented Programming) is just a <strong>programming paradigm</strong> ‚Äî a style of writing code.
It‚Äôs not the only one:</p>
<ul>
<li><strong>Procedural</strong> (C, early Java)</li>
<li><strong>Functional</strong> (Java Streams, Haskell, Scala)</li>
<li><strong>Event-driven</strong> (GUIs, message-based systems)</li>
<li><strong>Object-oriented</strong> (Java, C++, C#)</li>
</ul>
<p>üëâ In OOP, we <strong>combine data and behavior into a single unit called an object</strong>.</p>
<p>This differs from functional programming, which separates data and behavior.</p>
<p>‚ö° Important:</p>
<ul>
<li>Don‚Äôt get stuck on paradigms. Each has its strengths.</li>
<li>Java is classically OOP-focused, but modern approaches (like Go or Rust) use different models.</li>
<li>Use the style that best <strong>solves your problem</strong>.</li>
</ul>
<hr>
<h2>The Four Pillars of OOP</h2>
<p>In this section of the course, we‚Äôll cover:</p>
<ul>
<li><strong>Encapsulation</strong> ‚Äì bundling data + methods, controlling access</li>
<li><strong>Abstraction</strong> ‚Äì hiding details, showing only essentials</li>
<li><strong>Inheritance</strong> ‚Äì reusing existing code by extending classes</li>
<li><strong>Polymorphism</strong> ‚Äì objects behaving differently under the same interface</li>
</ul>
<p>Additionally, we‚Äôll learn about:</p>
<ul>
<li><strong>Classes</strong> (the building blocks of OOP)</li>
<li><strong>Constructors</strong></li>
<li><strong>Getters &amp; Setters</strong></li>
<li><strong>Method Overloading</strong></li>
<li><strong>Interfaces</strong></li>
<li><strong>Coupling &amp; Dependency</strong> between classes</li>
</ul>
<hr>
<h2>Classes and Objects</h2>
<p>A <strong>class</strong> is like a <strong>blueprint</strong> or <strong>type</strong>.</p>
<p>Example:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> {
    String model;
    <span class="hljs-type">int</span> year;
}
</code></pre><p>When we create something from this class, we get an <strong>object (or instance)</strong>:</p>
<pre><code class="hljs language-java"><span class="hljs-type">Car</span> <span class="hljs-variable">myCar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();
</code></pre><hr>
<h2>Memory Model in Java</h2>
<p>Java memory is divided into:</p>
<ul>
<li><strong>Stack</strong> ‚Äì stores <strong>primitive values</strong> and <strong>object references</strong> (addresses).</li>
<li><strong>Heap</strong> ‚Äì stores the actual <strong>objects</strong> (created with <code>new</code>).</li>
</ul>
<p>üîë Key points:</p>
<ul>
<li>When a method ends, stack variables are removed.</li>
<li>If no references point to an object in the heap, the <strong>Garbage Collector</strong> will eventually clean it up.</li>
</ul>
<hr>
<h2>Example: Our First Class</h2>
<p>Here‚Äôs a small example:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Create an instance of TextBox</span>
        <span class="hljs-type">TextBox</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextBox</span>(<span class="hljs-string">&quot;BOX1&quot;</span>);

        <span class="hljs-comment">// Print text in lowercase</span>
        System.out.println(tb.text.toLowerCase());
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBox</span> {
        <span class="hljs-comment">// Field</span>
        <span class="hljs-keyword">public</span> String text;

        <span class="hljs-comment">// Constructor</span>
        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TextBox</span><span class="hljs-params">(String value)</span> {
            <span class="hljs-built_in">this</span>.text = value;
        }

        <span class="hljs-comment">// Setter method</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setText</span><span class="hljs-params">(String text)</span> {
            <span class="hljs-built_in">this</span>.text = text;
        }

        <span class="hljs-comment">// Clear method</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> {
            <span class="hljs-built_in">this</span>.text = <span class="hljs-string">&quot;&quot;</span>;
        }
    }
}
</code></pre><hr>
<h3>Explanation:</h3>
<ul>
<li><code>TextBox</code> is a <strong>class</strong> (blueprint).</li>
<li><code>text</code> is a <strong>field</strong> (data stored in the object).</li>
<li>The <strong>constructor</strong> initializes the object.</li>
<li><code>setText</code> and <code>clear</code> are <strong>methods</strong> that define behavior.</li>
<li>In <code>main</code>, we create an <strong>object</strong> (<code>tb</code>) using <code>new TextBox(&quot;BOX1&quot;)</code>.</li>
</ul>
<hr>
<h1>From Procedural to Object-Oriented Programming</h1>
<p>In the last lesson, we introduced <strong>classes</strong> and saw how objects bundle <strong>data + behavior</strong>.</p>
<p>Now, let‚Äôs take a simple example ‚Äî calculating an employee‚Äôs wage ‚Äî and see how it looks:</p>
<ol>
<li>First, in a <strong>procedural style</strong> (functions + variables, separate).</li>
<li>Then, in <strong>OOP style</strong> (using a class that encapsulates data + behavior).</li>
</ol>
<hr>
<h2>Procedural Approach</h2>
<p>In a procedural style, we might write something like this:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProceduralDemo</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">int</span> <span class="hljs-variable">baseSalary</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">hourlyRate</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;
        <span class="hljs-type">int</span> <span class="hljs-variable">extraHours</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;

        <span class="hljs-type">int</span> <span class="hljs-variable">wage</span> <span class="hljs-operator">=</span> calculateWage(baseSalary, hourlyRate, extraHours);
        System.out.println(wage);
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateWage</span><span class="hljs-params">(<span class="hljs-type">int</span> base, <span class="hljs-type">int</span> hourlyRate, <span class="hljs-type">int</span> extraHours)</span> {
        <span class="hljs-keyword">return</span> base + extraHours * hourlyRate;
    }
}
</code></pre><p>üëâ Here, we:</p>
<ul>
<li>Store data (<code>baseSalary</code>, <code>hourlyRate</code>, <code>extraHours</code>) in <strong>separate variables</strong>.</li>
<li>Write a <strong>standalone function</strong> (<code>calculateWage</code>) to compute the result.</li>
</ul>
<p>This works, but as the program grows, managing all these <strong>loose variables</strong> gets messy.</p>
<hr>
<h2>OOP Approach</h2>
<p>In OOP, we bundle the <strong>data</strong> (like salary and hourly rate) and the <strong>functionality</strong> (like calculating wage) inside a single <strong>class</strong>.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Procedural</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">Employee</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>();
        <span class="hljs-type">int</span> <span class="hljs-variable">wage</span> <span class="hljs-operator">=</span> e.calculateWage(<span class="hljs-number">12</span>);

        e.setBaseSalary(<span class="hljs-number">6000</span>); <span class="hljs-comment">// using setter</span>
        System.out.println(wage);
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> {
        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">baseSalary</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>;
        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-variable">hourlyRate</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;

        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBaseSalary</span><span class="hljs-params">()</span> {
            <span class="hljs-keyword">return</span> baseSalary;
        }

        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBaseSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> baseSalary)</span> {
            <span class="hljs-keyword">if</span> (baseSalary &lt;= <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Base salary cannot be negative or zero&quot;</span>);
            }
            <span class="hljs-built_in">this</span>.baseSalary = baseSalary;
        }

        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateWage</span><span class="hljs-params">(<span class="hljs-type">int</span> extraHours)</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.baseSalary + <span class="hljs-built_in">this</span>.hourlyRate * extraHours;
        }
    }
}
</code></pre><hr>
<h3>What Changed?</h3>
<ol>
<li><p><strong>Encapsulation</strong>:</p>
<ul>
<li>We made <code>baseSalary</code> <strong>private</strong> so it cannot be modified directly.</li>
<li>We control changes using <strong>getters and setters</strong>.</li>
<li>This allows us to enforce rules (e.g., salary cannot be <code>0</code> or negative).</li>
</ul>
</li>
<li><p><strong>Methods inside the class</strong>:</p>
<ul>
<li>Instead of writing a separate <code>calculateWage</code> function, it is now part of <code>Employee</code>.</li>
<li>This makes sense because &quot;wage calculation&quot; is <strong>behavior</strong> of an Employee.</li>
</ul>
</li>
</ol>
<hr>
<h2>Why Encapsulation Matters</h2>
<p>Let‚Äôs say we didn‚Äôt hide <code>baseSalary</code> and left it public:</p>
<pre><code class="hljs language-java">e.baseSalary = -<span class="hljs-number">1000</span>;  <span class="hljs-comment">// valid in procedural style, but meaningless!</span>
</code></pre><p>That would allow invalid states.
By making it <strong>private</strong> and controlling it with a setter, we ensure data integrity:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBaseSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> baseSalary)</span> {
    <span class="hljs-keyword">if</span> (baseSalary &lt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Base salary cannot be negative or zero&quot;</span>);
    }
    <span class="hljs-built_in">this</span>.baseSalary = baseSalary;
}
</code></pre><hr>
<p>‚úÖ With this, we‚Äôve transitioned from procedural code ‚Üí OOP design.
Next, we‚Äôll look at <strong>constructors, overloading, and further encapsulation improvements</strong>.</p>
<hr>
<h1><strong>Abstraction, Coupling, Constructors, and Static Members</strong></h1>
<h2>Abstraction</h2>
<ul>
<li><strong>Definition:</strong> Abstraction is simply reducing complexity by hiding unnecessary details.</li>
<li>Instead of exposing raw class members (fields) to the outside world, we expose <strong>methods</strong> that control how other code interacts with the class.</li>
<li>This hides implementation details and protects the integrity of the class.</li>
</ul>
<hr>
<h2>Coupling</h2>
<ul>
<li><strong>Coupling</strong> happens when classes depend on each other.</li>
<li>Coupling is not always bad, but if classes are <strong>tightly coupled</strong>, then changing one class may force you to change many others.</li>
<li>By reducing coupling, we make our code more <strong>maintainable</strong> and <strong>flexible</strong>.</li>
</ul>
<hr>
<h2>Example: Employee Class</h2>
<p>Instead of exposing fields directly, we use <strong>getters and setters</strong> with validation.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> {

    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">hourlyRate</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">baseSalary</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBaseSalary</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> baseSalary;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBaseSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> baseSalary)</span> {
        <span class="hljs-keyword">if</span> (baseSalary &lt;= <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Base salary cannot be negative or zero&quot;</span>);
        }
        <span class="hljs-built_in">this</span>.baseSalary = baseSalary;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculateWage</span><span class="hljs-params">(<span class="hljs-type">int</span> extraHours)</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.baseSalary + <span class="hljs-built_in">this</span>.hourlyRate * extraHours;
    }
}
</code></pre><h3>Key points:</h3>
<ul>
<li>We made <code>baseSalary</code> <strong>private</strong> to prevent direct modification.</li>
<li>We added a <strong>setter method</strong> with validation to avoid putting the class into a ‚Äúbad state.‚Äù</li>
<li>We exposed a <strong>method</strong> (<code>calculateWage</code>) to perform work instead of letting the outside code do the calculation.</li>
</ul>
<hr>
<h2>Constructors</h2>
<p>Constructors are special methods that initialize objects when they are created.
They help us avoid forgetting to initialize important values.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> baseSalary;
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> hourlyRate;

    <span class="hljs-comment">// Constructor with parameters</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(<span class="hljs-type">int</span> baseSalary, <span class="hljs-type">int</span> hourlyRate)</span> {
        <span class="hljs-built_in">this</span>.baseSalary = baseSalary;
        <span class="hljs-built_in">this</span>.hourlyRate = hourlyRate;
    }

    <span class="hljs-comment">// Overloaded constructor with default values</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">this</span>.baseSalary = <span class="hljs-number">5000</span>;
        <span class="hljs-built_in">this</span>.hourlyRate = <span class="hljs-number">10</span>;
    }
}
</code></pre><h3>Notes:</h3>
<ul>
<li>By providing multiple constructors (<strong>constructor overloading</strong>), we can simulate ‚Äúdefault parameters‚Äù in Java.</li>
<li>Unlike languages like C#, C++, Go, or JavaScript, Java does not support default parameter values directly. Overloading is the workaround.</li>
</ul>
<hr>
<h2>Static Members</h2>
<ul>
<li>A class can have <strong>instance members</strong> (belong to an object) or <strong>static members</strong> (belong to the class itself).</li>
<li><strong>Static methods</strong> are useful when we don‚Äôt need an object, for example the <code>main</code> method:</li>
</ul>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Program</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// no object needed because main is static</span>
        System.out.println(<span class="hljs-string">&quot;Hello OOP&quot;</span>);
    }
}
</code></pre><h3>When to use static:</h3>
<ul>
<li>When a value or behavior should be <strong>shared across all objects</strong>.</li>
<li>When you want to provide <strong>utility functions</strong> (e.g., <code>Math.sqrt()</code>).</li>
</ul>
<hr>
<h2>Transition</h2>
<p>We‚Äôve now seen:</p>
<ul>
<li>How abstraction helps hide details.</li>
<li>How to reduce coupling between classes.</li>
<li>How constructors and method overloading make our classes safer and more flexible.</li>
<li>The difference between instance and static members.</li>
</ul>
<p>üëâ <strong>Next time, we‚Äôll look at <em>inheritance</em></strong> ‚Äî how one class can derive from another and reuse its code.</p>
<hr>
<h1><strong>Inheritance, Casting, Abstract Classes, and Polymorphism</strong></h1>
<p>In the previous section, we talked about the <strong>basics of OOP</strong> ‚Äì classes, objects, encapsulation, abstraction, and methods.
Now we‚Äôre going to push further into <strong>how objects relate to each other</strong> through inheritance, casting, abstract classes, and polymorphism.</p>
<hr>
<h2>Upcasting and Downcasting</h2>
<p>In Java, when you have a class hierarchy:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">UiControl</span> { ... }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UiControl</span> { ... }
</code></pre><ul>
<li><strong>Upcasting</strong> ‚Üí assigning a subclass (<code>TextBox</code>) to a superclass (<code>UiControl</code>) reference.
‚úÖ Always safe.</li>
<li><strong>Downcasting</strong> ‚Üí forcing a superclass reference back into a subclass.
‚ö†Ô∏è Dangerous, only works if the object is <em>actually</em> that subclass at runtime.</li>
</ul>
<pre><code class="hljs language-java"><span class="hljs-type">UiControl</span> <span class="hljs-variable">control</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextBox</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// upcasting, safe</span>
<span class="hljs-type">TextBox</span> <span class="hljs-variable">tb</span> <span class="hljs-operator">=</span> (TextBox) control;        <span class="hljs-comment">// downcasting, works</span>

<span class="hljs-type">UiControl</span> <span class="hljs-variable">control2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UiControl</span>(<span class="hljs-literal">true</span>);
<span class="hljs-type">TextBox</span> <span class="hljs-variable">tb2</span> <span class="hljs-operator">=</span> (TextBox) control2;      <span class="hljs-comment">// ‚ùå runtime error</span>
</code></pre><p>üëâ Always check with <code>instanceof</code> or <code>getClass()</code> before downcasting.</p>
<hr>
<h2>Abstract Classes</h2>
<p>Sometimes, we want to define a <strong>general concept</strong> without being able to create it directly.</p>
<p>For example, <code>UiControl</code> is an abstract idea ‚Äì we don‚Äôt really have a generic &quot;control&quot; in a UI, but we do have specific controls like <code>TextBox</code> or <code>CheckBox</code>.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UiControl</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isEnabled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UiControl</span><span class="hljs-params">(<span class="hljs-type">boolean</span> flag)</span> {
        <span class="hljs-built_in">this</span>.isEnabled = flag;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEnabled</span><span class="hljs-params">()</span> { <span class="hljs-keyword">return</span> isEnabled; }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEnabled</span><span class="hljs-params">(<span class="hljs-type">boolean</span> enabled)</span> { <span class="hljs-built_in">this</span>.isEnabled = enabled; }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>; <span class="hljs-comment">// forces subclasses to implement</span>
}
</code></pre><ul>
<li>You <strong>cannot instantiate</strong> an abstract class.</li>
<li>Subclasses <strong>must</strong> implement the abstract methods.</li>
</ul>
<hr>
<h2>Final Classes and Methods</h2>
<ul>
<li>A <strong>final class</strong> cannot be extended.</li>
<li>A <strong>final method</strong> cannot be overridden.</li>
</ul>
<p>Rarely used, but important for ensuring immutability and security.</p>
<hr>
<h2>Polymorphism</h2>
<p>Polymorphism means <strong>‚Äúmany forms.‚Äù</strong></p>
<p>When you call a method on a superclass reference, the JVM will run the <strong>actual subclass implementation</strong> at runtime.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GeometricShape</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GeometricShape</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> { System.out.println(<span class="hljs-string">&quot;This is a circle&quot;</span>); }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GeometricShape</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">()</span> { System.out.println(<span class="hljs-string">&quot;This is a square&quot;</span>); }
}
</code></pre><p>Now if we write:</p>
<pre><code class="hljs language-java">GeometricShape[] shapes = { <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>() };

<span class="hljs-keyword">for</span> (GeometricShape s : shapes) {
    s.draw(); <span class="hljs-comment">// Polymorphism in action</span>
}
</code></pre><p>Each object runs its own implementation, even though the reference type is the interface.</p>
<hr>
<h2>Comparing Objects (<code>equals</code>)</h2>
<p>By default, the <code>equals</code> method compares object <strong>references</strong>, not actual content.</p>
<p>Example:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x, y;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Point</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> {
        <span class="hljs-built_in">this</span>.x = x;
        <span class="hljs-built_in">this</span>.y = y;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == obj) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                <span class="hljs-comment">// same reference</span>
        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span> || getClass() != obj.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-type">Point</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> (Point) obj;                   <span class="hljs-comment">// safe cast</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x == other.x &amp;&amp; <span class="hljs-built_in">this</span>.y == other.y;
    }
}
</code></pre><p>Now:</p>
<pre><code class="hljs language-java"><span class="hljs-type">Point</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-type">Point</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);

System.out.println(p1.equals(p2)); <span class="hljs-comment">// true ‚úÖ (compares content)</span>
System.out.println(p1 == p2);      <span class="hljs-comment">// false ‚ùå (different references)</span>
</code></pre><hr>
<h2>Putting It All Together</h2>
<p>Here‚Äôs a summary of what we covered with live code:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UpCastingDowncasting</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        GeometricShape[] shapes = { <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Square</span>() };
        <span class="hljs-keyword">for</span> (GeometricShape sh : shapes) sh.draw();
    }
}
</code></pre><ul>
<li><code>UiControl</code> ‚Üí base (abstract) concept.</li>
<li><code>TextBox</code> ‚Üí subclass (concrete).</li>
<li>Upcasting allows <code>TextBox</code> to be treated as <code>UiControl</code>.</li>
<li>Downcasting requires checks.</li>
<li>Interfaces allow polymorphism across unrelated classes.</li>
<li>Override <code>equals</code> to compare <strong>contents</strong>, not references.</li>
</ul>
<hr>
<p>‚úÖ Next lesson: <strong>Interfaces and Dependency Injection</strong></p>
<hr>
<!---->
<!-- # C-9 üìò Lecture: Interfaces and Dependency Injection in Java -->
<!---->
<!-- Today, we‚Äôre going to dive into **interfaces** in Java, understand **why they exist**, and learn how they help us build **loosely coupled, extensible, and testable applications**. -->
<!---->
<!-- --- -->
<!---->
<!-- ## 1. Why Interfaces? (The Restaurant Analogy) -->
<!---->
<!-- Imagine you own a restaurant. You hire a chef named John. John is great, but one day John gets sick. If your restaurant only works because *John* is there, your business is in trouble. -->
<!---->
<!-- But what if instead, you said: -->
<!---->
<!-- > ‚ÄúI don‚Äôt care who the chef is, as long as they can cook.‚Äù -->
<!---->
<!-- That‚Äôs exactly what interfaces are about. We don‚Äôt tie ourselves to a **specific person (class)** ‚Äî we depend on a **contract (interface)**. -->
<!---->
<!-- This way, our application can keep running no matter who is ‚Äúin the kitchen.‚Äù -->
<!---->
<!-- --- -->
<!---->
<!-- ## 2. The Problem of Tight Coupling -->
<!---->
<!-- Let‚Äôs look at some code that is **tightly coupled**: -->
<!---->
<!-- ```java -->
<!-- static class TaxReport { -->
<!--     private TaxCal taxCal; -->
<!---->
<!--     public TaxReport() { -->
<!--         taxCal = new TaxCal(1000); -->
<!--     } -->
<!-- } -->
<!---->
<!-- static class TaxCal { -->
<!--     private double taxableIncome; -->
<!---->
<!--     public TaxCal(double taxableIncome) { -->
<!--         this.taxableIncome = taxableIncome; -->
<!--     } -->
<!---->
<!--     public double calculateTax() { -->
<!--         return taxableIncome * 0.3; -->
<!--     } -->
<!-- } -->
<!-- ``` -->
<!---->
<!-- Here‚Äôs the issue: -->
<!---->
<!-- * `TaxReport` directly depends on `TaxCal`. -->
<!-- * If we change the `TaxCal` implementation, we might break `TaxReport`. -->
<!-- * If we want to introduce a new tax rule (e.g., 2020 tax laws), we‚Äôd have to rewrite parts of `TaxReport`. -->
<!---->
<!-- This is **tight coupling**, and it makes code brittle and hard to maintain. -->
<!---->
<!-- --- -->
<!---->
<!-- ## 3. Breaking the Coupling with Interfaces -->
<!---->
<!-- Now let‚Äôs introduce an **interface** to reduce coupling: -->
<!---->
<!-- ```java -->
<!-- interface TaxCalculator { -->
<!--     double calculateTax(); -->
<!-- } -->
<!-- ``` -->
<!---->
<!-- Instead of depending on a *concrete class*, `TaxReport` now depends on this *contract*: -->
<!---->
<!-- ```java -->
<!-- static class TaxReport { -->
<!--     private TaxCalculator taxCal; -->
<!---->
<!--     // Constructor Injection -->
<!--     public TaxReport(TaxCalculator tc) { -->
<!--         taxCal = tc; -->
<!--     } -->
<!---->
<!--     public void printReport() { -->
<!--         System.out.println(taxCal.calculateTax()); -->
<!--     } -->
<!-- } -->
<!-- ``` -->
<!---->
<!-- Notice: -->
<!---->
<!-- * `TaxReport` doesn‚Äôt care *which* `TaxCalculator` it‚Äôs given. -->
<!-- * As long as the class implements `TaxCalculator`, `TaxReport` is happy. -->
<!---->
<!-- --- -->
<!---->
<!-- ## 4. Multiple Implementations -->
<!---->
<!-- Now we can write different tax calculators without breaking `TaxReport`: -->
<!---->
<!-- ```java -->
<!-- static class TaxCal implements TaxCalculator { -->
<!--     private double taxableIncome; -->
<!---->
<!--     public TaxCal(double taxableIncome) { -->
<!--         this.taxableIncome = taxableIncome; -->
<!--     } -->
<!---->
<!--     @Override -->
<!--     public double calculateTax() { -->
<!--         return taxableIncome * 0.3; -->
<!--     } -->
<!-- } -->
<!---->
<!-- static class TaxCal2020 implements TaxCalculator { -->
<!--     private double taxableIncome; -->
<!---->
<!--     public TaxCal2020(double taxableIncome) { -->
<!--         this.taxableIncome = taxableIncome; -->
<!--     } -->
<!---->
<!--     @Override -->
<!--     public double calculateTax() { -->
<!--         return taxableIncome * 0.25;  // new rules for 2020 -->
<!--     } -->
<!-- } -->
<!-- ``` -->
<!---->
<!-- Now `TaxReport` can work with **any** tax calculator: -->
<!---->
<!-- ```java -->
<!-- public static void main(String[] args) { -->
<!--     TaxCalculator calc = new TaxCal(1000); -->
<!--     TaxReport tr = new TaxReport(calc); -->
<!--     tr.printReport(); -->
<!---->
<!--     TaxCalculator calc2020 = new TaxCal2020(1000); -->
<!--     TaxReport tr2020 = new TaxReport(calc2020); -->
<!--     tr2020.printReport(); -->
<!-- } -->
<!-- ``` -->
<!---->
<!-- --- -->
<!---->
<!-- ## 5. Dependency Injection -->
<!---->
<!-- What we just did is called **Dependency Injection (DI)**. -->
<!---->
<!-- Instead of `TaxReport` creating its own dependencies, we **inject** them from outside. -->
<!-- There are three main ways to inject dependencies: -->
<!---->
<!-- 1. **Constructor Injection** (most common, what we used) -->
<!-- 2. **Setter Injection** (pass a dependency via a setter method) -->
<!-- 3. **Method Injection** (pass a dependency as a parameter to a method call) -->
<!---->
<!-- In real projects, you won‚Äôt manually manage all dependencies. -->
<!-- Instead, you‚Äôll often use a **DI Framework** like **Spring** to do this for you automatically. -->
<!---->
<!-- --- -->
<!---->
<!-- ## 6. Interface Segregation -->
<!---->
<!-- One last point: -->
<!---->
<!-- If you create a huge ‚Äúgod interface‚Äù with too many methods, every implementing class is forced to implement things it doesn‚Äôt care about. -->
<!---->
<!-- That‚Äôs bad design. -->
<!---->
<!-- Instead, follow the **Interface Segregation Principle (ISP)**: -->
<!---->
<!-- > Split large interfaces into smaller, more focused ones. -->
<!---->
<!-- For example: -->
<!---->
<!-- ```java -->
<!-- interface Drivable { -->
<!--     void drive(); -->
<!-- } -->
<!---->
<!-- interface Flyable { -->
<!--     void fly(); -->
<!-- } -->
<!---->
<!-- class Car implements Drivable { -->
<!--     public void drive() { System.out.println("Car is driving"); } -->
<!-- } -->
<!---->
<!-- class Plane implements Drivable, Flyable { -->
<!--     public void drive() { System.out.println("Plane is taxiing"); } -->
<!--     public void fly() { System.out.println("Plane is flying"); } -->
<!-- } -->
<!-- ``` -->
<!---->
<!-- This way, classes only implement what they actually need. -->
<!---->
<!-- --- -->
<!---->
<!-- ## 7. A Note on Default, Private, and Static Methods in Interfaces -->
<!---->
<!-- Since Java 8, interfaces can have `default` and `static` methods. -->
<!-- Since Java 9, they can even have `private` methods. -->
<!---->
<!-- Personally, I recommend being cautious here. Why? -->
<!---->
<!-- * An interface‚Äôs purpose is to define a **contract**. -->
<!-- * Putting too much code inside an interface can blur the line between **contracts** and **implementations**. -->
<!-- * If you need to share common logic between multiple classes, an **abstract class** that implements the interface is often a cleaner design. -->
<!---->
<!-- --- -->
<!---->
<!-- ## ‚úÖ Summary -->
<!---->
<!-- * **Interfaces** define *what* a class can do, not *how*. -->
<!-- * They help us build **loosely coupled, extensible, and testable applications**. -->
<!-- * **Dependency Injection** means passing dependencies instead of creating them internally. -->
<!-- * Use frameworks like **Spring** for large-scale projects. -->
<!-- * Apply the **Interface Segregation Principle** to avoid ‚Äúfat‚Äù interfaces. -->
<!-- * Be careful with `default`, `static`, and `private` methods inside interfaces ‚Äî prefer abstract classes for shared logic. -->
<!---->
<!-- --- -->
<!---->
<!-- üëâ And that‚Äôs interfaces in Java. -->
<!-- Next time, we‚Äôll look at how interfaces and **abstract classes** work together to design even more flexible systems. -->
<!---->
<!-- --- -->
<!---->

<h1>Java Interfaces and Inheritance Guide</h1>
<h2>Why interfaces exists ?- THE BIG PICTURE</h2>
<h3>The Restaurant Analogy</h3>
<p>Imagine you own a restaurant and hire a chef named John. John is great, but what happens when John gets sick? If your restaurant only works because <em>John</em> is there, your business is in trouble.</p>
<p>But what if instead, you said: <em>&quot;I don&#39;t care who the chef is, as long as they can cook.&quot;</em></p>
<p>That&#39;s exactly what interfaces are about. We don&#39;t tie ourselves to a <strong>specific person (class)</strong> ‚Äî we depend on a <strong>contract (interface)</strong>. This way, our application can keep running no matter who is &quot;in the kitchen.&quot;</p>
<h3>The Problem: <strong>Tight Coupling</strong></h3>
<p>Let&#39;s look at code that is <strong>tightly coupled</strong>:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxReport</span> {
    <span class="hljs-keyword">private</span> TaxCal taxCal;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaxReport</span><span class="hljs-params">()</span> {
        taxCal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaxCal</span>(<span class="hljs-number">1000</span>); <span class="hljs-comment">// Directly creates dependency</span>
    }
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxCal</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> taxableIncome;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaxCal</span><span class="hljs-params">(<span class="hljs-type">double</span> taxableIncome)</span> {
        <span class="hljs-built_in">this</span>.taxableIncome = taxableIncome;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateTax</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> taxableIncome * <span class="hljs-number">0.3</span>;
    }
}
</code></pre><p>Problems with this approach:</p>
<ul>
<li><code>TaxReport</code> directly depends on <code>TaxCal</code></li>
<li>Changing <code>TaxCal</code> might break <code>TaxReport</code></li>
<li>Adding new tax rules requires rewriting <code>TaxReport</code></li>
<li>Hard to test in isolation</li>
</ul>
<h3>The Solution: Programming Against Interfaces</h3>
<pre><code class="hljs language-java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">TaxCalculator</span> {
    <span class="hljs-type">double</span> <span class="hljs-title function_">calculateTax</span><span class="hljs-params">()</span>;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxReport</span> {
    <span class="hljs-keyword">private</span> TaxCalculator taxCal;

    <span class="hljs-comment">// Constructor Injection - depends on contract, not implementation</span>
    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaxReport</span><span class="hljs-params">(TaxCalculator tc)</span> {
        taxCal = tc;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printReport</span><span class="hljs-params">()</span> {
        System.out.println(taxCal.calculateTax());
    }
}
</code></pre><p>Now <code>TaxReport</code> doesn&#39;t care <em>which</em> <code>TaxCalculator</code> it receives - it just needs something that fulfills the contract.</p>
<h2>Multiple Inher rules</h2>
<h3>Classes: Single Inheritance Only</h3>
<p><strong>Java classes cannot extend multiple classes</strong>. Java only allows <strong>single inheritance</strong>:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> { }
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> { }
<span class="hljs-comment">// ‚ùå Not allowed - will cause compile error</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>, B { }
</code></pre><h3>Interfaces: Multiple Inheritance Allowed</h3>
<p>Unlike classes, an <strong>interface can extend multiple interfaces</strong>:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span>; }

<span class="hljs-comment">// ‚úÖ Perfectly valid</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>, B {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">baz</span><span class="hljs-params">()</span>;
}
</code></pre><p>So <code>C</code> inherits <code>foo()</code> from <code>A</code> and <code>bar()</code> from <code>B</code>.</p>
<h2>Hndeling method coflicts</h2>
<h3>Same Method Signature = No Conflict</h3>
<p>When interfaces have methods with identical signatures, there&#39;s no problem:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>, B { } <span class="hljs-comment">// No conflict</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">C</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> {
        System.out.println(<span class="hljs-string">&quot;Single implementation satisfies both&quot;</span>);
    }
}
</code></pre><p>The compiler sees them as <strong>one method contract</strong>.</p>
<h3>Different Signatures = Method Overloading</h3>
<pre><code class="hljs language-java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(String msg)</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>, B { }

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">C</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> { System.out.println(<span class="hljs-string">&quot;No args&quot;</span>); }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(String msg)</span> { System.out.println(msg); }
}
</code></pre><h3>Default Method Conflicts (Java 8+)</h3>
<p>When interfaces have conflicting default methods, you <strong>must</strong> resolve the conflict:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> {
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> { System.out.println(<span class="hljs-string">&quot;Hello from A&quot;</span>); }
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> {
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> { System.out.println(<span class="hljs-string">&quot;Hello from B&quot;</span>); }
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>, B {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span> {
        A.<span class="hljs-built_in">super</span>.hello(); <span class="hljs-comment">// Choose A&#x27;s, B&#x27;s, or write custom implementation</span>
    }
}
</code></pre><h2>Interface evolution through java versions</h2>
<h3>Pre-Java 8: Pure Contracts</h3>
<ul>
<li>Only abstract methods (implicitly <code>public abstract</code>)</li>
<li>Only <code>public static final</code> constants</li>
<li>No implemented methods allowed</li>
</ul>
<h3>Java 8: Default and Static Methods</h3>
<p>Interfaces can now have:</p>
<ul>
<li><strong>Default methods</strong>: Provide fallback implementations</li>
<li><strong>Static methods</strong>: Utility methods belonging to the interface</li>
</ul>
<pre><code class="hljs language-java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>; <span class="hljs-comment">// abstract method</span>

    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">honk</span><span class="hljs-params">()</span> {  <span class="hljs-comment">// default method</span>
        System.out.println(<span class="hljs-string">&quot;Beep!&quot;</span>);
    }

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceInfo</span><span class="hljs-params">()</span> { <span class="hljs-comment">// static method</span>
        System.out.println(<span class="hljs-string">&quot;Service required every 6 months&quot;</span>);
    }
}
</code></pre><h3>Java 9+: Private Methods</h3>
<p>Added <strong>private methods</strong> for organizing code within interfaces:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Calculator</span> {
    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addAndLog</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        logOperation(<span class="hljs-string">&quot;Addition&quot;</span>);
        <span class="hljs-keyword">return</span> a + b;
    }

    <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">subtractAndLog</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> {
        logOperation(<span class="hljs-string">&quot;Subtraction&quot;</span>);
        <span class="hljs-keyword">return</span> a - b;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logOperation</span><span class="hljs-params">(String operation)</span> { <span class="hljs-comment">// Helper method</span>
        System.out.println(<span class="hljs-string">&quot;Performing: &quot;</span> + operation);
    }
}
</code></pre><h2>Dependency injection patterns</h2>
<h3>Three Types of Dependency Injection</h3>
<ol>
<li><strong>Constructor Injection</strong> (recommended):</li>
</ol>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxReport</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TaxCalculator calculator;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaxReport</span><span class="hljs-params">(TaxCalculator calculator)</span> {
        <span class="hljs-built_in">this</span>.calculator = calculator;
    }
}
</code></pre><ol start="2">
<li>Setter Injection:</li>
</ol>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxReport</span> {
    <span class="hljs-keyword">private</span> TaxCalculator calculator;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTaxCalculator</span><span class="hljs-params">(TaxCalculator calculator)</span> {
        <span class="hljs-built_in">this</span>.calculator = calculator;
    }
}
</code></pre><ol start="3">
<li>Method Injection:</li>
</ol>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxReport</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateReport</span><span class="hljs-params">(TaxCalculator calculator)</span> {
        <span class="hljs-comment">// Use calculator for this specific operation</span>
    }
}
</code></pre><h3>Benefits of Dependency Injection</h3>
<ul>
<li><strong>Flexibility</strong>: Easy to swap implementations</li>
<li><strong>Testability</strong>: Can inject mock objects for testing</li>
<li><strong>Extensibility</strong>: Add new implementations without changing existing code</li>
<li><strong>Loose Coupling</strong>: Classes depend on abstractions, not concrete implementations</li>
</ul>
<h2>Desig principles and best practices</h2>
<h3>Interface Segregation Principle (ISP)</h3>
<p>Avoid creating &quot;god interfaces&quot; with too many methods. Split large interfaces into smaller, focused ones:</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// ‚ùå Bad: Fat interface</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">VehicleOperations</span> {
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">swim</span><span class="hljs-params">()</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">refuel</span><span class="hljs-params">()</span>;
    <span class="hljs-keyword">void</span> <span class="hljs-title function_">recharge</span><span class="hljs-params">()</span>;
}

<span class="hljs-comment">// ‚úÖ Good: Segregated interfaces</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Drivable</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Flyable</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">fly</span><span class="hljs-params">()</span>; }
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Rechargeable</span> { <span class="hljs-keyword">void</span> <span class="hljs-title function_">recharge</span><span class="hljs-params">()</span>; }

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Drivable</span>, Rechargeable {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> { System.out.println(<span class="hljs-string">&quot;Car is driving&quot;</span>); }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recharge</span><span class="hljs-params">()</span> { System.out.println(<span class="hljs-string">&quot;Car is charging&quot;</span>); }
    <span class="hljs-comment">// No need to implement fly() or swim()</span>
}
</code></pre><h3>When to Use Abstract Classes vs Interfaces</h3>
<p>Use Abstract Classes When:</p>
<ul>
<li>You need to share code between related classes</li>
<li>You have common state (fields) to share</li>
<li>Classes have a clear &quot;is-a&quot; relationship</li>
<li>You want to provide partial implementations</li>
</ul>
<p>Use Interfaces When:</p>
<ul>
<li>You need multiple inheritance</li>
<li>Defining contracts for unrelated classes</li>
<li>You want loose coupling and flexibility</li>
<li>Building for testability</li>
</ul>
<h3>Modern Interface Design Guidelines</h3>
<p>Static Methods in Interfaces:</p>
<ul>
<li>Belong to the interface namespace, not implementing classes</li>
<li>Called via <code>InterfaceName.methodName()</code></li>
<li>Consider if utility classes might be cleaner</li>
</ul>
<p>Default Methods:</p>
<ul>
<li>Use sparingly to avoid blurring interface purpose</li>
<li>Good for interface evolution without breaking existing code</li>
<li>Don&#39;t overuse - interfaces should primarily define contracts</li>
</ul>
<p>Private Methods:</p>
<ul>
<li>Useful for organizing code within the interface</li>
<li>Help reduce duplication in default methods</li>
<li>Only visible within the same interface</li>
</ul>
<h2>Practical example : Multiple implementations</h2>
<p>Here&#39;s how you can create multiple implementations and swap them easily:</p>
<pre><code class="hljs language-java"><span class="hljs-comment">// Different tax calculation strategies</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxCal</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TaxCalculator</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> taxableIncome;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaxCal</span><span class="hljs-params">(<span class="hljs-type">double</span> taxableIncome)</span> {
        <span class="hljs-built_in">this</span>.taxableIncome = taxableIncome;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateTax</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> taxableIncome * <span class="hljs-number">0.3</span>; <span class="hljs-comment">// Standard rate</span>
    }
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaxCal2020</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TaxCalculator</span> {
    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> taxableIncome;

    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaxCal2020</span><span class="hljs-params">(<span class="hljs-type">double</span> taxableIncome)</span> {
        <span class="hljs-built_in">this</span>.taxableIncome = taxableIncome;
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculateTax</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> taxableIncome * <span class="hljs-number">0.25</span>; <span class="hljs-comment">// 2020 tax rules</span>
    }
}

<span class="hljs-comment">// Usage - easy to swap implementations</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-type">TaxCalculator</span> <span class="hljs-variable">calc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaxCal</span>(<span class="hljs-number">1000</span>);
    <span class="hljs-type">TaxReport</span> <span class="hljs-variable">tr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaxReport</span>(calc);
    tr.printReport(); <span class="hljs-comment">// Uses standard calculation</span>

    <span class="hljs-type">TaxCalculator</span> <span class="hljs-variable">calc2020</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaxCal2020</span>(<span class="hljs-number">1000</span>);
    <span class="hljs-type">TaxReport</span> <span class="hljs-variable">tr2020</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaxReport</span>(calc2020);
    tr2020.printReport(); <span class="hljs-comment">// Uses 2020 rules</span>
}
</code></pre><h2>Important interview insights</h2>
<h3>The Classic &quot;Interface vs Abstract Class&quot; Question</h3>
<p>This is often considered an <strong>outdated interview question</strong> for several reasons:</p>
<p><strong>Why it&#39;s problematic:</strong></p>
<ul>
<li>Shows lack of modern interviewing experience</li>
<li>Focuses on memorization rather than practical problem-solving</li>
<li>Doesn&#39;t reflect real-world development challenges</li>
<li>Many modern languages don&#39;t even have these concepts</li>
</ul>
<p><strong>What matters more in 2025:</strong></p>
<ul>
<li>Understanding appropriate design patterns</li>
<li>Building maintainable, testable applications</li>
<li>Knowing when to use loose coupling</li>
<li>Practical problem-solving skills</li>
</ul>
<p><strong>The Real Answer:</strong></p>
<ul>
<li><strong>Interfaces</strong> = contracts for loose coupling and flexibility</li>
<li><strong>Abstract classes</strong> = partially implemented classes for sharing code between related classes</li>
<li><strong>Focus on</strong> = choosing the right tool for the design problem, not memorizing differences</li>
</ul>
<h2>KEY TAKEAWAYS</h2>
<h3>Core Principles</h3>
<ol>
<li><strong>Program against interfaces, not implementations</strong> - enables flexibility and testability</li>
<li><strong>Use dependency injection</strong> to reduce coupling and improve testability</li>
<li><strong>Keep interfaces focused</strong> - follow Interface Segregation Principle</li>
<li><strong>Interfaces define contracts</strong> - what classes can do, not how they do it</li>
</ol>
<h3>Design Recommendations</h3>
<ol>
<li><strong>Keep interfaces clean</strong> - primarily for defining contracts</li>
<li><strong>Use abstract classes for shared code</strong> between related classes</li>
<li><strong>Prefer composition over inheritance</strong> when possible</li>
<li><strong>Avoid overusing default methods</strong> - they can blur interface purpose</li>
<li><strong>Use DI frameworks</strong> (like Spring) for complex applications</li>
</ol>
<h3>Benefits of This Approach</h3>
<ul>
<li><strong>Loose Coupling</strong>: Components depend on abstractions, not concrete classes</li>
<li><strong>Extensibility</strong>: Easy to add new implementations without changing existing code</li>
<li><strong>Testability</strong>: Can inject mock objects for unit testing</li>
<li><strong>Maintainability</strong>: Changes in one implementation don&#39;t affect others</li>
<li><strong>Flexibility</strong>: Can swap implementations at runtime</li>
</ul>
<p>Remember: Good design is about <strong>clarity of responsibility</strong>. Interfaces should define contracts, abstract classes should share code, and utility classes should contain common helpers. Don&#39;t mix these roles unnecessarily.</p>
</div><div class="lesson-links"><a href="/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Java Fundamentals" class="prev">‚Üê Previous</a><a href="/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Advanced java" class="next">Next ‚Üí</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/asolyma2"><svg fill="none" height="100%" width="32" xmlns="http://www.w3.org/2000/svg" viewBox="0.254 0.25 500 451.95400000000006"><path d="M394.033.25h76.67L303.202 191.693l197.052 260.511h-154.29L225.118 294.205 86.844 452.204H10.127l179.16-204.77L.254.25H158.46l109.234 144.417zm-26.908 406.063h42.483L135.377 43.73h-45.59z" fill="var(--footer-icons)"></path></svg></a></li><li class="social"><a href="https://bsky.app/profile/thisisamr.bsky.social"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3.268 64 68.414" width="38" height="100%"><path fill="var(--footer-icons)" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805zm36.254 0C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745z"></path></svg></a></li><li class="social"><a href="https://github.com/thisisamr"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/thisisamr"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Exercises Licensed Under Apache 2.0</p><p>inspired by Btholt Course starter kit<!-- --> <a href="https://github.com/btholt/next-course-starter">Brian Holt</a></p></div></li></ul><div class="theme-icons"><button aria-label="Activate dark mode" title="Activate dark mode" class="theme-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="36px" height="100%" viewBox="0 -960 960 960" fill="var(--text-footer)" role="img"><title>Dark Mode Icon</title><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Z"></path></svg></button></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{},"html":"\u003ch1\u003e\u003cstrong\u003eIntroduction to Object-Oriented Programming (OOP) in Java\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003eWelcome to the second part of our Java refresher course.\nIn this section, we‚Äôll start exploring \u003cstrong\u003eObject-Oriented Programming (OOP)\u003c/strong\u003e ‚Äî the most widely used programming paradigm in Java.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eWhat is OOP?\u003c/h2\u003e\n\u003cp\u003eOOP (Object-Oriented Programming) is just a \u003cstrong\u003eprogramming paradigm\u003c/strong\u003e ‚Äî a style of writing code.\nIt‚Äôs not the only one:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eProcedural\u003c/strong\u003e (C, early Java)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFunctional\u003c/strong\u003e (Java Streams, Haskell, Scala)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEvent-driven\u003c/strong\u003e (GUIs, message-based systems)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eObject-oriented\u003c/strong\u003e (Java, C++, C#)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eüëâ In OOP, we \u003cstrong\u003ecombine data and behavior into a single unit called an object\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eThis differs from functional programming, which separates data and behavior.\u003c/p\u003e\n\u003cp\u003e‚ö° Important:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDon‚Äôt get stuck on paradigms. Each has its strengths.\u003c/li\u003e\n\u003cli\u003eJava is classically OOP-focused, but modern approaches (like Go or Rust) use different models.\u003c/li\u003e\n\u003cli\u003eUse the style that best \u003cstrong\u003esolves your problem\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eThe Four Pillars of OOP\u003c/h2\u003e\n\u003cp\u003eIn this section of the course, we‚Äôll cover:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eEncapsulation\u003c/strong\u003e ‚Äì bundling data + methods, controlling access\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAbstraction\u003c/strong\u003e ‚Äì hiding details, showing only essentials\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInheritance\u003c/strong\u003e ‚Äì reusing existing code by extending classes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePolymorphism\u003c/strong\u003e ‚Äì objects behaving differently under the same interface\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAdditionally, we‚Äôll learn about:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eClasses\u003c/strong\u003e (the building blocks of OOP)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eConstructors\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eGetters \u0026amp; Setters\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMethod Overloading\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInterfaces\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCoupling \u0026amp; Dependency\u003c/strong\u003e between classes\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eClasses and Objects\u003c/h2\u003e\n\u003cp\u003eA \u003cstrong\u003eclass\u003c/strong\u003e is like a \u003cstrong\u003eblueprint\u003c/strong\u003e or \u003cstrong\u003etype\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e {\n    String model;\n    \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e year;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen we create something from this class, we get an \u003cstrong\u003eobject (or instance)\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-type\"\u003eCar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003emyCar\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch2\u003eMemory Model in Java\u003c/h2\u003e\n\u003cp\u003eJava memory is divided into:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eStack\u003c/strong\u003e ‚Äì stores \u003cstrong\u003eprimitive values\u003c/strong\u003e and \u003cstrong\u003eobject references\u003c/strong\u003e (addresses).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHeap\u003c/strong\u003e ‚Äì stores the actual \u003cstrong\u003eobjects\u003c/strong\u003e (created with \u003ccode\u003enew\u003c/code\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eüîë Key points:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhen a method ends, stack variables are removed.\u003c/li\u003e\n\u003cli\u003eIf no references point to an object in the heap, the \u003cstrong\u003eGarbage Collector\u003c/strong\u003e will eventually clean it up.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eExample: Our First Class\u003c/h2\u003e\n\u003cp\u003eHere‚Äôs a small example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMain\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// Create an instance of TextBox\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003eTextBox\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etb\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTextBox\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;BOX1\u0026quot;\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-comment\"\u003e// Print text in lowercase\u003c/span\u003e\n        System.out.println(tb.text.toLowerCase());\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTextBox\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// Field\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e String text;\n\n        \u003cspan class=\"hljs-comment\"\u003e// Constructor\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTextBox\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String value)\u003c/span\u003e {\n            \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.text = value;\n        }\n\n        \u003cspan class=\"hljs-comment\"\u003e// Setter method\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetText\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String text)\u003c/span\u003e {\n            \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.text = text;\n        }\n\n        \u003cspan class=\"hljs-comment\"\u003e// Clear method\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eclear\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n            \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.text = \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch3\u003eExplanation:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTextBox\u003c/code\u003e is a \u003cstrong\u003eclass\u003c/strong\u003e (blueprint).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etext\u003c/code\u003e is a \u003cstrong\u003efield\u003c/strong\u003e (data stored in the object).\u003c/li\u003e\n\u003cli\u003eThe \u003cstrong\u003econstructor\u003c/strong\u003e initializes the object.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esetText\u003c/code\u003e and \u003ccode\u003eclear\u003c/code\u003e are \u003cstrong\u003emethods\u003c/strong\u003e that define behavior.\u003c/li\u003e\n\u003cli\u003eIn \u003ccode\u003emain\u003c/code\u003e, we create an \u003cstrong\u003eobject\u003c/strong\u003e (\u003ccode\u003etb\u003c/code\u003e) using \u003ccode\u003enew TextBox(\u0026quot;BOX1\u0026quot;)\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch1\u003eFrom Procedural to Object-Oriented Programming\u003c/h1\u003e\n\u003cp\u003eIn the last lesson, we introduced \u003cstrong\u003eclasses\u003c/strong\u003e and saw how objects bundle \u003cstrong\u003edata + behavior\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eNow, let‚Äôs take a simple example ‚Äî calculating an employee‚Äôs wage ‚Äî and see how it looks:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eFirst, in a \u003cstrong\u003eprocedural style\u003c/strong\u003e (functions + variables, separate).\u003c/li\u003e\n\u003cli\u003eThen, in \u003cstrong\u003eOOP style\u003c/strong\u003e (using a class that encapsulates data + behavior).\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2\u003eProcedural Approach\u003c/h2\u003e\n\u003cp\u003eIn a procedural style, we might write something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProceduralDemo\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ebaseSalary\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e;\n        \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ehourlyRate\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e;\n        \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eextraHours\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\n        \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ewage\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e calculateWage(baseSalary, hourlyRate, extraHours);\n        System.out.println(wage);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateWage\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e base, \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e hourlyRate, \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e extraHours)\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e base + extraHours * hourlyRate;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eüëâ Here, we:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eStore data (\u003ccode\u003ebaseSalary\u003c/code\u003e, \u003ccode\u003ehourlyRate\u003c/code\u003e, \u003ccode\u003eextraHours\u003c/code\u003e) in \u003cstrong\u003eseparate variables\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eWrite a \u003cstrong\u003estandalone function\u003c/strong\u003e (\u003ccode\u003ecalculateWage\u003c/code\u003e) to compute the result.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis works, but as the program grows, managing all these \u003cstrong\u003eloose variables\u003c/strong\u003e gets messy.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eOOP Approach\u003c/h2\u003e\n\u003cp\u003eIn OOP, we bundle the \u003cstrong\u003edata\u003c/strong\u003e (like salary and hourly rate) and the \u003cstrong\u003efunctionality\u003c/strong\u003e (like calculating wage) inside a single \u003cstrong\u003eclass\u003c/strong\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProcedural\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eEmployee\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ee\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEmployee\u003c/span\u003e();\n        \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ewage\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e e.calculateWage(\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e);\n\n        e.setBaseSalary(\u003cspan class=\"hljs-number\"\u003e6000\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// using setter\u003c/span\u003e\n        System.out.println(wage);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEmployee\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ebaseSalary\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e;\n        \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ehourlyRate\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e;\n\n        \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetBaseSalary\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e baseSalary;\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetBaseSalary\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e baseSalary)\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (baseSalary \u0026lt;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n                \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalArgumentException\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Base salary cannot be negative or zero\u0026quot;\u003c/span\u003e);\n            }\n            \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.baseSalary = baseSalary;\n        }\n\n        \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateWage\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e extraHours)\u003c/span\u003e {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.baseSalary + \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.hourlyRate * extraHours;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch3\u003eWhat Changed?\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eEncapsulation\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe made \u003ccode\u003ebaseSalary\u003c/code\u003e \u003cstrong\u003eprivate\u003c/strong\u003e so it cannot be modified directly.\u003c/li\u003e\n\u003cli\u003eWe control changes using \u003cstrong\u003egetters and setters\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eThis allows us to enforce rules (e.g., salary cannot be \u003ccode\u003e0\u003c/code\u003e or negative).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003eMethods inside the class\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eInstead of writing a separate \u003ccode\u003ecalculateWage\u003c/code\u003e function, it is now part of \u003ccode\u003eEmployee\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eThis makes sense because \u0026quot;wage calculation\u0026quot; is \u003cstrong\u003ebehavior\u003c/strong\u003e of an Employee.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch2\u003eWhy Encapsulation Matters\u003c/h2\u003e\n\u003cp\u003eLet‚Äôs say we didn‚Äôt hide \u003ccode\u003ebaseSalary\u003c/code\u003e and left it public:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003ee.baseSalary = -\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e;  \u003cspan class=\"hljs-comment\"\u003e// valid in procedural style, but meaningless!\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThat would allow invalid states.\nBy making it \u003cstrong\u003eprivate\u003c/strong\u003e and controlling it with a setter, we ensure data integrity:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetBaseSalary\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e baseSalary)\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (baseSalary \u0026lt;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalArgumentException\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Base salary cannot be negative or zero\u0026quot;\u003c/span\u003e);\n    }\n    \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.baseSalary = baseSalary;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003cp\u003e‚úÖ With this, we‚Äôve transitioned from procedural code ‚Üí OOP design.\nNext, we‚Äôll look at \u003cstrong\u003econstructors, overloading, and further encapsulation improvements\u003c/strong\u003e.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1\u003e\u003cstrong\u003eAbstraction, Coupling, Constructors, and Static Members\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2\u003eAbstraction\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDefinition:\u003c/strong\u003e Abstraction is simply reducing complexity by hiding unnecessary details.\u003c/li\u003e\n\u003cli\u003eInstead of exposing raw class members (fields) to the outside world, we expose \u003cstrong\u003emethods\u003c/strong\u003e that control how other code interacts with the class.\u003c/li\u003e\n\u003cli\u003eThis hides implementation details and protects the integrity of the class.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eCoupling\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCoupling\u003c/strong\u003e happens when classes depend on each other.\u003c/li\u003e\n\u003cli\u003eCoupling is not always bad, but if classes are \u003cstrong\u003etightly coupled\u003c/strong\u003e, then changing one class may force you to change many others.\u003c/li\u003e\n\u003cli\u003eBy reducing coupling, we make our code more \u003cstrong\u003emaintainable\u003c/strong\u003e and \u003cstrong\u003eflexible\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eExample: Employee Class\u003c/h2\u003e\n\u003cp\u003eInstead of exposing fields directly, we use \u003cstrong\u003egetters and setters\u003c/strong\u003e with validation.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEmployee\u003c/span\u003e {\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ehourlyRate\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ebaseSalary\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetBaseSalary\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e baseSalary;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetBaseSalary\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e baseSalary)\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (baseSalary \u0026lt;= \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalArgumentException\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Base salary cannot be negative or zero\u0026quot;\u003c/span\u003e);\n        }\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.baseSalary = baseSalary;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateWage\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e extraHours)\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.baseSalary + \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.hourlyRate * extraHours;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eKey points:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eWe made \u003ccode\u003ebaseSalary\u003c/code\u003e \u003cstrong\u003eprivate\u003c/strong\u003e to prevent direct modification.\u003c/li\u003e\n\u003cli\u003eWe added a \u003cstrong\u003esetter method\u003c/strong\u003e with validation to avoid putting the class into a ‚Äúbad state.‚Äù\u003c/li\u003e\n\u003cli\u003eWe exposed a \u003cstrong\u003emethod\u003c/strong\u003e (\u003ccode\u003ecalculateWage\u003c/code\u003e) to perform work instead of letting the outside code do the calculation.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eConstructors\u003c/h2\u003e\n\u003cp\u003eConstructors are special methods that initialize objects when they are created.\nThey help us avoid forgetting to initialize important values.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eEmployee\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e baseSalary;\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e hourlyRate;\n\n    \u003cspan class=\"hljs-comment\"\u003e// Constructor with parameters\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eEmployee\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e baseSalary, \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e hourlyRate)\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.baseSalary = baseSalary;\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.hourlyRate = hourlyRate;\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// Overloaded constructor with default values\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eEmployee\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.baseSalary = \u003cspan class=\"hljs-number\"\u003e5000\u003c/span\u003e;\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.hourlyRate = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eNotes:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eBy providing multiple constructors (\u003cstrong\u003econstructor overloading\u003c/strong\u003e), we can simulate ‚Äúdefault parameters‚Äù in Java.\u003c/li\u003e\n\u003cli\u003eUnlike languages like C#, C++, Go, or JavaScript, Java does not support default parameter values directly. Overloading is the workaround.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eStatic Members\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eA class can have \u003cstrong\u003einstance members\u003c/strong\u003e (belong to an object) or \u003cstrong\u003estatic members\u003c/strong\u003e (belong to the class itself).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStatic methods\u003c/strong\u003e are useful when we don‚Äôt need an object, for example the \u003ccode\u003emain\u003c/code\u003e method:\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProgram\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// no object needed because main is static\u003c/span\u003e\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Hello OOP\u0026quot;\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eWhen to use static:\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eWhen a value or behavior should be \u003cstrong\u003eshared across all objects\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eWhen you want to provide \u003cstrong\u003eutility functions\u003c/strong\u003e (e.g., \u003ccode\u003eMath.sqrt()\u003c/code\u003e).\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eTransition\u003c/h2\u003e\n\u003cp\u003eWe‚Äôve now seen:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHow abstraction helps hide details.\u003c/li\u003e\n\u003cli\u003eHow to reduce coupling between classes.\u003c/li\u003e\n\u003cli\u003eHow constructors and method overloading make our classes safer and more flexible.\u003c/li\u003e\n\u003cli\u003eThe difference between instance and static members.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eüëâ \u003cstrong\u003eNext time, we‚Äôll look at \u003cem\u003einheritance\u003c/em\u003e\u003c/strong\u003e ‚Äî how one class can derive from another and reuse its code.\u003c/p\u003e\n\u003chr\u003e\n\u003ch1\u003e\u003cstrong\u003eInheritance, Casting, Abstract Classes, and Polymorphism\u003c/strong\u003e\u003c/h1\u003e\n\u003cp\u003eIn the previous section, we talked about the \u003cstrong\u003ebasics of OOP\u003c/strong\u003e ‚Äì classes, objects, encapsulation, abstraction, and methods.\nNow we‚Äôre going to push further into \u003cstrong\u003ehow objects relate to each other\u003c/strong\u003e through inheritance, casting, abstract classes, and polymorphism.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eUpcasting and Downcasting\u003c/h2\u003e\n\u003cp\u003eIn Java, when you have a class hierarchy:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUiControl\u003c/span\u003e { ... }\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTextBox\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUiControl\u003c/span\u003e { ... }\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eUpcasting\u003c/strong\u003e ‚Üí assigning a subclass (\u003ccode\u003eTextBox\u003c/code\u003e) to a superclass (\u003ccode\u003eUiControl\u003c/code\u003e) reference.\n‚úÖ Always safe.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDowncasting\u003c/strong\u003e ‚Üí forcing a superclass reference back into a subclass.\n‚ö†Ô∏è Dangerous, only works if the object is \u003cem\u003eactually\u003c/em\u003e that subclass at runtime.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-type\"\u003eUiControl\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003econtrol\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTextBox\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// upcasting, safe\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003eTextBox\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etb\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e (TextBox) control;        \u003cspan class=\"hljs-comment\"\u003e// downcasting, works\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eUiControl\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003econtrol2\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUiControl\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n\u003cspan class=\"hljs-type\"\u003eTextBox\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etb2\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e (TextBox) control2;      \u003cspan class=\"hljs-comment\"\u003e// ‚ùå runtime error\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eüëâ Always check with \u003ccode\u003einstanceof\u003c/code\u003e or \u003ccode\u003egetClass()\u003c/code\u003e before downcasting.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eAbstract Classes\u003c/h2\u003e\n\u003cp\u003eSometimes, we want to define a \u003cstrong\u003egeneral concept\u003c/strong\u003e without being able to create it directly.\u003c/p\u003e\n\u003cp\u003eFor example, \u003ccode\u003eUiControl\u003c/code\u003e is an abstract idea ‚Äì we don‚Äôt really have a generic \u0026quot;control\u0026quot; in a UI, but we do have specific controls like \u003ccode\u003eTextBox\u003c/code\u003e or \u003ccode\u003eCheckBox\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUiControl\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eboolean\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eisEnabled\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eUiControl\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eboolean\u003c/span\u003e flag)\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.isEnabled = flag;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eboolean\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisEnabled\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e isEnabled; }\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetEnabled\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eboolean\u003c/span\u003e enabled)\u003c/span\u003e { \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.isEnabled = enabled; }\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edraw\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// forces subclasses to implement\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003eYou \u003cstrong\u003ecannot instantiate\u003c/strong\u003e an abstract class.\u003c/li\u003e\n\u003cli\u003eSubclasses \u003cstrong\u003emust\u003c/strong\u003e implement the abstract methods.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003ch2\u003eFinal Classes and Methods\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eA \u003cstrong\u003efinal class\u003c/strong\u003e cannot be extended.\u003c/li\u003e\n\u003cli\u003eA \u003cstrong\u003efinal method\u003c/strong\u003e cannot be overridden.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRarely used, but important for ensuring immutability and security.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003ePolymorphism\u003c/h2\u003e\n\u003cp\u003ePolymorphism means \u003cstrong\u003e‚Äúmany forms.‚Äù\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhen you call a method on a superclass reference, the JVM will run the \u003cstrong\u003eactual subclass implementation\u003c/strong\u003e at runtime.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGeometricShape\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edraw\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGeometricShape\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edraw\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e { System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;This is a circle\u0026quot;\u003c/span\u003e); }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSquare\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eGeometricShape\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edraw\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e { System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;This is a square\u0026quot;\u003c/span\u003e); }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow if we write:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003eGeometricShape[] shapes = { \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e(), \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSquare\u003c/span\u003e() };\n\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (GeometricShape s : shapes) {\n    s.draw(); \u003cspan class=\"hljs-comment\"\u003e// Polymorphism in action\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eEach object runs its own implementation, even though the reference type is the interface.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eComparing Objects (\u003ccode\u003eequals\u003c/code\u003e)\u003c/h2\u003e\n\u003cp\u003eBy default, the \u003ccode\u003eequals\u003c/code\u003e method compares object \u003cstrong\u003ereferences\u003c/strong\u003e, not actual content.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e x, y;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ePoint\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e x, \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e y)\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.x = x;\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.y = y;\n    }\n\n    \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eboolean\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eequals\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(Object obj)\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e == obj) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;                \u003cspan class=\"hljs-comment\"\u003e// same reference\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (obj == \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e || getClass() != obj.getClass()) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n\n        \u003cspan class=\"hljs-type\"\u003ePoint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eother\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e (Point) obj;                   \u003cspan class=\"hljs-comment\"\u003e// safe cast\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.x == other.x \u0026amp;\u0026amp; \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.y == other.y;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-type\"\u003ePoint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ep1\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-type\"\u003ePoint\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ep2\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePoint\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\nSystem.out.println(p1.equals(p2)); \u003cspan class=\"hljs-comment\"\u003e// true ‚úÖ (compares content)\u003c/span\u003e\nSystem.out.println(p1 == p2);      \u003cspan class=\"hljs-comment\"\u003e// false ‚ùå (different references)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003chr\u003e\n\u003ch2\u003ePutting It All Together\u003c/h2\u003e\n\u003cp\u003eHere‚Äôs a summary of what we covered with live code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUpCastingDowncasting\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        GeometricShape[] shapes = { \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCircle\u003c/span\u003e(), \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSquare\u003c/span\u003e() };\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (GeometricShape sh : shapes) sh.draw();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eUiControl\u003c/code\u003e ‚Üí base (abstract) concept.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTextBox\u003c/code\u003e ‚Üí subclass (concrete).\u003c/li\u003e\n\u003cli\u003eUpcasting allows \u003ccode\u003eTextBox\u003c/code\u003e to be treated as \u003ccode\u003eUiControl\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eDowncasting requires checks.\u003c/li\u003e\n\u003cli\u003eInterfaces allow polymorphism across unrelated classes.\u003c/li\u003e\n\u003cli\u003eOverride \u003ccode\u003eequals\u003c/code\u003e to compare \u003cstrong\u003econtents\u003c/strong\u003e, not references.\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e‚úÖ Next lesson: \u003cstrong\u003eInterfaces and Dependency Injection\u003c/strong\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003c!----\u003e\n\u003c!-- # C-9 üìò Lecture: Interfaces and Dependency Injection in Java --\u003e\n\u003c!----\u003e\n\u003c!-- Today, we‚Äôre going to dive into **interfaces** in Java, understand **why they exist**, and learn how they help us build **loosely coupled, extensible, and testable applications**. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 1. Why Interfaces? (The Restaurant Analogy) --\u003e\n\u003c!----\u003e\n\u003c!-- Imagine you own a restaurant. You hire a chef named John. John is great, but one day John gets sick. If your restaurant only works because *John* is there, your business is in trouble. --\u003e\n\u003c!----\u003e\n\u003c!-- But what if instead, you said: --\u003e\n\u003c!----\u003e\n\u003c!-- \u003e ‚ÄúI don‚Äôt care who the chef is, as long as they can cook.‚Äù --\u003e\n\u003c!----\u003e\n\u003c!-- That‚Äôs exactly what interfaces are about. We don‚Äôt tie ourselves to a **specific person (class)** ‚Äî we depend on a **contract (interface)**. --\u003e\n\u003c!----\u003e\n\u003c!-- This way, our application can keep running no matter who is ‚Äúin the kitchen.‚Äù --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 2. The Problem of Tight Coupling --\u003e\n\u003c!----\u003e\n\u003c!-- Let‚Äôs look at some code that is **tightly coupled**: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- static class TaxReport { --\u003e\n\u003c!--     private TaxCal taxCal; --\u003e\n\u003c!----\u003e\n\u003c!--     public TaxReport() { --\u003e\n\u003c!--         taxCal = new TaxCal(1000); --\u003e\n\u003c!--     } --\u003e\n\u003c!-- } --\u003e\n\u003c!----\u003e\n\u003c!-- static class TaxCal { --\u003e\n\u003c!--     private double taxableIncome; --\u003e\n\u003c!----\u003e\n\u003c!--     public TaxCal(double taxableIncome) { --\u003e\n\u003c!--         this.taxableIncome = taxableIncome; --\u003e\n\u003c!--     } --\u003e\n\u003c!----\u003e\n\u003c!--     public double calculateTax() { --\u003e\n\u003c!--         return taxableIncome * 0.3; --\u003e\n\u003c!--     } --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- Here‚Äôs the issue: --\u003e\n\u003c!----\u003e\n\u003c!-- * `TaxReport` directly depends on `TaxCal`. --\u003e\n\u003c!-- * If we change the `TaxCal` implementation, we might break `TaxReport`. --\u003e\n\u003c!-- * If we want to introduce a new tax rule (e.g., 2020 tax laws), we‚Äôd have to rewrite parts of `TaxReport`. --\u003e\n\u003c!----\u003e\n\u003c!-- This is **tight coupling**, and it makes code brittle and hard to maintain. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 3. Breaking the Coupling with Interfaces --\u003e\n\u003c!----\u003e\n\u003c!-- Now let‚Äôs introduce an **interface** to reduce coupling: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- interface TaxCalculator { --\u003e\n\u003c!--     double calculateTax(); --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- Instead of depending on a *concrete class*, `TaxReport` now depends on this *contract*: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- static class TaxReport { --\u003e\n\u003c!--     private TaxCalculator taxCal; --\u003e\n\u003c!----\u003e\n\u003c!--     // Constructor Injection --\u003e\n\u003c!--     public TaxReport(TaxCalculator tc) { --\u003e\n\u003c!--         taxCal = tc; --\u003e\n\u003c!--     } --\u003e\n\u003c!----\u003e\n\u003c!--     public void printReport() { --\u003e\n\u003c!--         System.out.println(taxCal.calculateTax()); --\u003e\n\u003c!--     } --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- Notice: --\u003e\n\u003c!----\u003e\n\u003c!-- * `TaxReport` doesn‚Äôt care *which* `TaxCalculator` it‚Äôs given. --\u003e\n\u003c!-- * As long as the class implements `TaxCalculator`, `TaxReport` is happy. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 4. Multiple Implementations --\u003e\n\u003c!----\u003e\n\u003c!-- Now we can write different tax calculators without breaking `TaxReport`: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- static class TaxCal implements TaxCalculator { --\u003e\n\u003c!--     private double taxableIncome; --\u003e\n\u003c!----\u003e\n\u003c!--     public TaxCal(double taxableIncome) { --\u003e\n\u003c!--         this.taxableIncome = taxableIncome; --\u003e\n\u003c!--     } --\u003e\n\u003c!----\u003e\n\u003c!--     @Override --\u003e\n\u003c!--     public double calculateTax() { --\u003e\n\u003c!--         return taxableIncome * 0.3; --\u003e\n\u003c!--     } --\u003e\n\u003c!-- } --\u003e\n\u003c!----\u003e\n\u003c!-- static class TaxCal2020 implements TaxCalculator { --\u003e\n\u003c!--     private double taxableIncome; --\u003e\n\u003c!----\u003e\n\u003c!--     public TaxCal2020(double taxableIncome) { --\u003e\n\u003c!--         this.taxableIncome = taxableIncome; --\u003e\n\u003c!--     } --\u003e\n\u003c!----\u003e\n\u003c!--     @Override --\u003e\n\u003c!--     public double calculateTax() { --\u003e\n\u003c!--         return taxableIncome * 0.25;  // new rules for 2020 --\u003e\n\u003c!--     } --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- Now `TaxReport` can work with **any** tax calculator: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- public static void main(String[] args) { --\u003e\n\u003c!--     TaxCalculator calc = new TaxCal(1000); --\u003e\n\u003c!--     TaxReport tr = new TaxReport(calc); --\u003e\n\u003c!--     tr.printReport(); --\u003e\n\u003c!----\u003e\n\u003c!--     TaxCalculator calc2020 = new TaxCal2020(1000); --\u003e\n\u003c!--     TaxReport tr2020 = new TaxReport(calc2020); --\u003e\n\u003c!--     tr2020.printReport(); --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 5. Dependency Injection --\u003e\n\u003c!----\u003e\n\u003c!-- What we just did is called **Dependency Injection (DI)**. --\u003e\n\u003c!----\u003e\n\u003c!-- Instead of `TaxReport` creating its own dependencies, we **inject** them from outside. --\u003e\n\u003c!-- There are three main ways to inject dependencies: --\u003e\n\u003c!----\u003e\n\u003c!-- 1. **Constructor Injection** (most common, what we used) --\u003e\n\u003c!-- 2. **Setter Injection** (pass a dependency via a setter method) --\u003e\n\u003c!-- 3. **Method Injection** (pass a dependency as a parameter to a method call) --\u003e\n\u003c!----\u003e\n\u003c!-- In real projects, you won‚Äôt manually manage all dependencies. --\u003e\n\u003c!-- Instead, you‚Äôll often use a **DI Framework** like **Spring** to do this for you automatically. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 6. Interface Segregation --\u003e\n\u003c!----\u003e\n\u003c!-- One last point: --\u003e\n\u003c!----\u003e\n\u003c!-- If you create a huge ‚Äúgod interface‚Äù with too many methods, every implementing class is forced to implement things it doesn‚Äôt care about. --\u003e\n\u003c!----\u003e\n\u003c!-- That‚Äôs bad design. --\u003e\n\u003c!----\u003e\n\u003c!-- Instead, follow the **Interface Segregation Principle (ISP)**: --\u003e\n\u003c!----\u003e\n\u003c!-- \u003e Split large interfaces into smaller, more focused ones. --\u003e\n\u003c!----\u003e\n\u003c!-- For example: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- interface Drivable { --\u003e\n\u003c!--     void drive(); --\u003e\n\u003c!-- } --\u003e\n\u003c!----\u003e\n\u003c!-- interface Flyable { --\u003e\n\u003c!--     void fly(); --\u003e\n\u003c!-- } --\u003e\n\u003c!----\u003e\n\u003c!-- class Car implements Drivable { --\u003e\n\u003c!--     public void drive() { System.out.println(\"Car is driving\"); } --\u003e\n\u003c!-- } --\u003e\n\u003c!----\u003e\n\u003c!-- class Plane implements Drivable, Flyable { --\u003e\n\u003c!--     public void drive() { System.out.println(\"Plane is taxiing\"); } --\u003e\n\u003c!--     public void fly() { System.out.println(\"Plane is flying\"); } --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- This way, classes only implement what they actually need. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 7. A Note on Default, Private, and Static Methods in Interfaces --\u003e\n\u003c!----\u003e\n\u003c!-- Since Java 8, interfaces can have `default` and `static` methods. --\u003e\n\u003c!-- Since Java 9, they can even have `private` methods. --\u003e\n\u003c!----\u003e\n\u003c!-- Personally, I recommend being cautious here. Why? --\u003e\n\u003c!----\u003e\n\u003c!-- * An interface‚Äôs purpose is to define a **contract**. --\u003e\n\u003c!-- * Putting too much code inside an interface can blur the line between **contracts** and **implementations**. --\u003e\n\u003c!-- * If you need to share common logic between multiple classes, an **abstract class** that implements the interface is often a cleaner design. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## ‚úÖ Summary --\u003e\n\u003c!----\u003e\n\u003c!-- * **Interfaces** define *what* a class can do, not *how*. --\u003e\n\u003c!-- * They help us build **loosely coupled, extensible, and testable applications**. --\u003e\n\u003c!-- * **Dependency Injection** means passing dependencies instead of creating them internally. --\u003e\n\u003c!-- * Use frameworks like **Spring** for large-scale projects. --\u003e\n\u003c!-- * Apply the **Interface Segregation Principle** to avoid ‚Äúfat‚Äù interfaces. --\u003e\n\u003c!-- * Be careful with `default`, `static`, and `private` methods inside interfaces ‚Äî prefer abstract classes for shared logic. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- üëâ And that‚Äôs interfaces in Java. --\u003e\n\u003c!-- Next time, we‚Äôll look at how interfaces and **abstract classes** work together to design even more flexible systems. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\n\u003ch1\u003eJava Interfaces and Inheritance Guide\u003c/h1\u003e\n\u003ch2\u003eWhy interfaces exists ?- THE BIG PICTURE\u003c/h2\u003e\n\u003ch3\u003eThe Restaurant Analogy\u003c/h3\u003e\n\u003cp\u003eImagine you own a restaurant and hire a chef named John. John is great, but what happens when John gets sick? If your restaurant only works because \u003cem\u003eJohn\u003c/em\u003e is there, your business is in trouble.\u003c/p\u003e\n\u003cp\u003eBut what if instead, you said: \u003cem\u003e\u0026quot;I don\u0026#39;t care who the chef is, as long as they can cook.\u0026quot;\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThat\u0026#39;s exactly what interfaces are about. We don\u0026#39;t tie ourselves to a \u003cstrong\u003especific person (class)\u003c/strong\u003e ‚Äî we depend on a \u003cstrong\u003econtract (interface)\u003c/strong\u003e. This way, our application can keep running no matter who is \u0026quot;in the kitchen.\u0026quot;\u003c/p\u003e\n\u003ch3\u003eThe Problem: \u003cstrong\u003eTight Coupling\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003eLet\u0026#39;s look at code that is \u003cstrong\u003etightly coupled\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxReport\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e TaxCal taxCal;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTaxReport\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        taxCal = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxCal\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Directly creates dependency\u003c/span\u003e\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxCal\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e taxableIncome;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTaxCal\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e taxableIncome)\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.taxableIncome = taxableIncome;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateTax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e taxableIncome * \u003cspan class=\"hljs-number\"\u003e0.3\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eProblems with this approach:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTaxReport\u003c/code\u003e directly depends on \u003ccode\u003eTaxCal\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eChanging \u003ccode\u003eTaxCal\u003c/code\u003e might break \u003ccode\u003eTaxReport\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eAdding new tax rules requires rewriting \u003ccode\u003eTaxReport\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eHard to test in isolation\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eThe Solution: Programming Against Interfaces\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxCalculator\u003c/span\u003e {\n    \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateTax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxReport\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e TaxCalculator taxCal;\n\n    \u003cspan class=\"hljs-comment\"\u003e// Constructor Injection - depends on contract, not implementation\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTaxReport\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TaxCalculator tc)\u003c/span\u003e {\n        taxCal = tc;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eprintReport\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        System.out.println(taxCal.calculateTax());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow \u003ccode\u003eTaxReport\u003c/code\u003e doesn\u0026#39;t care \u003cem\u003ewhich\u003c/em\u003e \u003ccode\u003eTaxCalculator\u003c/code\u003e it receives - it just needs something that fulfills the contract.\u003c/p\u003e\n\u003ch2\u003eMultiple Inher rules\u003c/h2\u003e\n\u003ch3\u003eClasses: Single Inheritance Only\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eJava classes cannot extend multiple classes\u003c/strong\u003e. Java only allows \u003cstrong\u003esingle inheritance\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eA\u003c/span\u003e { }\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eB\u003c/span\u003e { }\n\u003cspan class=\"hljs-comment\"\u003e// ‚ùå Not allowed - will cause compile error\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eC\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eA\u003c/span\u003e, B { }\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eInterfaces: Multiple Inheritance Allowed\u003c/h3\u003e\n\u003cp\u003eUnlike classes, an \u003cstrong\u003einterface can extend multiple interfaces\u003c/strong\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eA\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; }\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eB\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; }\n\n\u003cspan class=\"hljs-comment\"\u003e// ‚úÖ Perfectly valid\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eC\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eA\u003c/span\u003e, B {\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebaz\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSo \u003ccode\u003eC\u003c/code\u003e inherits \u003ccode\u003efoo()\u003c/code\u003e from \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003ebar()\u003c/code\u003e from \u003ccode\u003eB\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003eHndeling method coflicts\u003c/h2\u003e\n\u003ch3\u003eSame Method Signature = No Conflict\u003c/h3\u003e\n\u003cp\u003eWhen interfaces have methods with identical signatures, there\u0026#39;s no problem:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eA\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; }\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eB\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; }\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eC\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eA\u003c/span\u003e, B { } \u003cspan class=\"hljs-comment\"\u003e// No conflict\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyClass\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eC\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Single implementation satisfies both\u0026quot;\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe compiler sees them as \u003cstrong\u003eone method contract\u003c/strong\u003e.\u003c/p\u003e\n\u003ch3\u003eDifferent Signatures = Method Overloading\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eA\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; }\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eB\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String msg)\u003c/span\u003e; }\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eC\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eA\u003c/span\u003e, B { }\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyClass\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eC\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e { System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;No args\u0026quot;\u003c/span\u003e); }\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String msg)\u003c/span\u003e { System.out.println(msg); }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eDefault Method Conflicts (Java 8+)\u003c/h3\u003e\n\u003cp\u003eWhen interfaces have conflicting default methods, you \u003cstrong\u003emust\u003c/strong\u003e resolve the conflict:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eA\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehello\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e { System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Hello from A\u0026quot;\u003c/span\u003e); }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eB\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehello\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e { System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Hello from B\u0026quot;\u003c/span\u003e); }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eC\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eA\u003c/span\u003e, B {\n    \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehello\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        A.\u003cspan class=\"hljs-built_in\"\u003esuper\u003c/span\u003e.hello(); \u003cspan class=\"hljs-comment\"\u003e// Choose A\u0026#x27;s, B\u0026#x27;s, or write custom implementation\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eInterface evolution through java versions\u003c/h2\u003e\n\u003ch3\u003ePre-Java 8: Pure Contracts\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eOnly abstract methods (implicitly \u003ccode\u003epublic abstract\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eOnly \u003ccode\u003epublic static final\u003c/code\u003e constants\u003c/li\u003e\n\u003cli\u003eNo implemented methods allowed\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eJava 8: Default and Static Methods\u003c/h3\u003e\n\u003cp\u003eInterfaces can now have:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eDefault methods\u003c/strong\u003e: Provide fallback implementations\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStatic methods\u003c/strong\u003e: Utility methods belonging to the interface\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVehicle\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emove\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// abstract method\u003c/span\u003e\n\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ehonk\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {  \u003cspan class=\"hljs-comment\"\u003e// default method\u003c/span\u003e\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Beep!\u0026quot;\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eserviceInfo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e { \u003cspan class=\"hljs-comment\"\u003e// static method\u003c/span\u003e\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Service required every 6 months\u0026quot;\u003c/span\u003e);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eJava 9+: Private Methods\u003c/h3\u003e\n\u003cp\u003eAdded \u003cstrong\u003eprivate methods\u003c/strong\u003e for organizing code within interfaces:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCalculator\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddAndLog\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e a, \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e b)\u003c/span\u003e {\n        logOperation(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Addition\u0026quot;\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a + b;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esubtractAndLog\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e a, \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e b)\u003c/span\u003e {\n        logOperation(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Subtraction\u0026quot;\u003c/span\u003e);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a - b;\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003elogOperation\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String operation)\u003c/span\u003e { \u003cspan class=\"hljs-comment\"\u003e// Helper method\u003c/span\u003e\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Performing: \u0026quot;\u003c/span\u003e + operation);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eDependency injection patterns\u003c/h2\u003e\n\u003ch3\u003eThree Types of Dependency Injection\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eConstructor Injection\u003c/strong\u003e (recommended):\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxReport\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efinal\u003c/span\u003e TaxCalculator calculator;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTaxReport\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TaxCalculator calculator)\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.calculator = calculator;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003col start=\"2\"\u003e\n\u003cli\u003eSetter Injection:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxReport\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e TaxCalculator calculator;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esetTaxCalculator\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TaxCalculator calculator)\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.calculator = calculator;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003col start=\"3\"\u003e\n\u003cli\u003eMethod Injection:\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxReport\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egenerateReport\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(TaxCalculator calculator)\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// Use calculator for this specific operation\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eBenefits of Dependency Injection\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eFlexibility\u003c/strong\u003e: Easy to swap implementations\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTestability\u003c/strong\u003e: Can inject mock objects for testing\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExtensibility\u003c/strong\u003e: Add new implementations without changing existing code\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eLoose Coupling\u003c/strong\u003e: Classes depend on abstractions, not concrete implementations\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eDesig principles and best practices\u003c/h2\u003e\n\u003ch3\u003eInterface Segregation Principle (ISP)\u003c/h3\u003e\n\u003cp\u003eAvoid creating \u0026quot;god interfaces\u0026quot; with too many methods. Split large interfaces into smaller, focused ones:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// ‚ùå Bad: Fat interface\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eVehicleOperations\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efly\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eswim\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erefuel\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erecharge\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// ‚úÖ Good: Segregated interfaces\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDrivable\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; }\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eFlyable\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efly\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; }\n\u003cspan class=\"hljs-keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRechargeable\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erecharge\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; }\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCar\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDrivable\u003c/span\u003e, Rechargeable {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edrive\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e { System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Car is driving\u0026quot;\u003c/span\u003e); }\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erecharge\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e { System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Car is charging\u0026quot;\u003c/span\u003e); }\n    \u003cspan class=\"hljs-comment\"\u003e// No need to implement fly() or swim()\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eWhen to Use Abstract Classes vs Interfaces\u003c/h3\u003e\n\u003cp\u003eUse Abstract Classes When:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou need to share code between related classes\u003c/li\u003e\n\u003cli\u003eYou have common state (fields) to share\u003c/li\u003e\n\u003cli\u003eClasses have a clear \u0026quot;is-a\u0026quot; relationship\u003c/li\u003e\n\u003cli\u003eYou want to provide partial implementations\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUse Interfaces When:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou need multiple inheritance\u003c/li\u003e\n\u003cli\u003eDefining contracts for unrelated classes\u003c/li\u003e\n\u003cli\u003eYou want loose coupling and flexibility\u003c/li\u003e\n\u003cli\u003eBuilding for testability\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eModern Interface Design Guidelines\u003c/h3\u003e\n\u003cp\u003eStatic Methods in Interfaces:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBelong to the interface namespace, not implementing classes\u003c/li\u003e\n\u003cli\u003eCalled via \u003ccode\u003eInterfaceName.methodName()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eConsider if utility classes might be cleaner\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDefault Methods:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUse sparingly to avoid blurring interface purpose\u003c/li\u003e\n\u003cli\u003eGood for interface evolution without breaking existing code\u003c/li\u003e\n\u003cli\u003eDon\u0026#39;t overuse - interfaces should primarily define contracts\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ePrivate Methods:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUseful for organizing code within the interface\u003c/li\u003e\n\u003cli\u003eHelp reduce duplication in default methods\u003c/li\u003e\n\u003cli\u003eOnly visible within the same interface\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003ePractical example : Multiple implementations\u003c/h2\u003e\n\u003cp\u003eHere\u0026#39;s how you can create multiple implementations and swap them easily:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Different tax calculation strategies\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxCal\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxCalculator\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e taxableIncome;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTaxCal\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e taxableIncome)\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.taxableIncome = taxableIncome;\n    }\n\n    \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateTax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e taxableIncome * \u003cspan class=\"hljs-number\"\u003e0.3\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// Standard rate\u003c/span\u003e\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxCal2020\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxCalculator\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e taxableIncome;\n\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eTaxCal2020\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(\u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e taxableIncome)\u003c/span\u003e {\n        \u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e.taxableIncome = taxableIncome;\n    }\n\n    \u003cspan class=\"hljs-meta\"\u003e@Override\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003edouble\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecalculateTax\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e taxableIncome * \u003cspan class=\"hljs-number\"\u003e0.25\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 2020 tax rules\u003c/span\u003e\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Usage - easy to swap implementations\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n    \u003cspan class=\"hljs-type\"\u003eTaxCalculator\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecalc\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxCal\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n    \u003cspan class=\"hljs-type\"\u003eTaxReport\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etr\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxReport\u003c/span\u003e(calc);\n    tr.printReport(); \u003cspan class=\"hljs-comment\"\u003e// Uses standard calculation\u003c/span\u003e\n\n    \u003cspan class=\"hljs-type\"\u003eTaxCalculator\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecalc2020\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxCal2020\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n    \u003cspan class=\"hljs-type\"\u003eTaxReport\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003etr2020\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTaxReport\u003c/span\u003e(calc2020);\n    tr2020.printReport(); \u003cspan class=\"hljs-comment\"\u003e// Uses 2020 rules\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eImportant interview insights\u003c/h2\u003e\n\u003ch3\u003eThe Classic \u0026quot;Interface vs Abstract Class\u0026quot; Question\u003c/h3\u003e\n\u003cp\u003eThis is often considered an \u003cstrong\u003eoutdated interview question\u003c/strong\u003e for several reasons:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWhy it\u0026#39;s problematic:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eShows lack of modern interviewing experience\u003c/li\u003e\n\u003cli\u003eFocuses on memorization rather than practical problem-solving\u003c/li\u003e\n\u003cli\u003eDoesn\u0026#39;t reflect real-world development challenges\u003c/li\u003e\n\u003cli\u003eMany modern languages don\u0026#39;t even have these concepts\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eWhat matters more in 2025:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUnderstanding appropriate design patterns\u003c/li\u003e\n\u003cli\u003eBuilding maintainable, testable applications\u003c/li\u003e\n\u003cli\u003eKnowing when to use loose coupling\u003c/li\u003e\n\u003cli\u003ePractical problem-solving skills\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eThe Real Answer:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eInterfaces\u003c/strong\u003e = contracts for loose coupling and flexibility\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAbstract classes\u003c/strong\u003e = partially implemented classes for sharing code between related classes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFocus on\u003c/strong\u003e = choosing the right tool for the design problem, not memorizing differences\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eKEY TAKEAWAYS\u003c/h2\u003e\n\u003ch3\u003eCore Principles\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eProgram against interfaces, not implementations\u003c/strong\u003e - enables flexibility and testability\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse dependency injection\u003c/strong\u003e to reduce coupling and improve testability\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eKeep interfaces focused\u003c/strong\u003e - follow Interface Segregation Principle\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eInterfaces define contracts\u003c/strong\u003e - what classes can do, not how they do it\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eDesign Recommendations\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eKeep interfaces clean\u003c/strong\u003e - primarily for defining contracts\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse abstract classes for shared code\u003c/strong\u003e between related classes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePrefer composition over inheritance\u003c/strong\u003e when possible\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAvoid overusing default methods\u003c/strong\u003e - they can blur interface purpose\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUse DI frameworks\u003c/strong\u003e (like Spring) for complex applications\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eBenefits of This Approach\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eLoose Coupling\u003c/strong\u003e: Components depend on abstractions, not concrete classes\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eExtensibility\u003c/strong\u003e: Easy to add new implementations without changing existing code\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTestability\u003c/strong\u003e: Can inject mock objects for unit testing\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMaintainability\u003c/strong\u003e: Changes in one implementation don\u0026#39;t affect others\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eFlexibility\u003c/strong\u003e: Can swap implementations at runtime\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRemember: Good design is about \u003cstrong\u003eclarity of responsibility\u003c/strong\u003e. Interfaces should define contracts, abstract classes should share code, and utility classes should contain common helpers. Don\u0026#39;t mix these roles unnecessarily.\u003c/p\u003e\n","markdown":"# **Introduction to Object-Oriented Programming (OOP) in Java**\n\nWelcome to the second part of our Java refresher course.\nIn this section, we‚Äôll start exploring **Object-Oriented Programming (OOP)** ‚Äî the most widely used programming paradigm in Java.\n\n---\n\n## What is OOP?\n\nOOP (Object-Oriented Programming) is just a **programming paradigm** ‚Äî a style of writing code.\nIt‚Äôs not the only one:\n\n- **Procedural** (C, early Java)\n- **Functional** (Java Streams, Haskell, Scala)\n- **Event-driven** (GUIs, message-based systems)\n- **Object-oriented** (Java, C++, C#)\n\nüëâ In OOP, we **combine data and behavior into a single unit called an object**.\n\nThis differs from functional programming, which separates data and behavior.\n\n‚ö° Important:\n\n- Don‚Äôt get stuck on paradigms. Each has its strengths.\n- Java is classically OOP-focused, but modern approaches (like Go or Rust) use different models.\n- Use the style that best **solves your problem**.\n\n---\n\n## The Four Pillars of OOP\n\nIn this section of the course, we‚Äôll cover:\n\n- **Encapsulation** ‚Äì bundling data + methods, controlling access\n- **Abstraction** ‚Äì hiding details, showing only essentials\n- **Inheritance** ‚Äì reusing existing code by extending classes\n- **Polymorphism** ‚Äì objects behaving differently under the same interface\n\nAdditionally, we‚Äôll learn about:\n\n- **Classes** (the building blocks of OOP)\n- **Constructors**\n- **Getters \u0026 Setters**\n- **Method Overloading**\n- **Interfaces**\n- **Coupling \u0026 Dependency** between classes\n\n---\n\n## Classes and Objects\n\nA **class** is like a **blueprint** or **type**.\n\nExample:\n\n```java\nclass Car {\n    String model;\n    int year;\n}\n```\n\nWhen we create something from this class, we get an **object (or instance)**:\n\n```java\nCar myCar = new Car();\n```\n\n---\n\n## Memory Model in Java\n\nJava memory is divided into:\n\n- **Stack** ‚Äì stores **primitive values** and **object references** (addresses).\n- **Heap** ‚Äì stores the actual **objects** (created with `new`).\n\nüîë Key points:\n\n- When a method ends, stack variables are removed.\n- If no references point to an object in the heap, the **Garbage Collector** will eventually clean it up.\n\n---\n\n## Example: Our First Class\n\nHere‚Äôs a small example:\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Create an instance of TextBox\n        TextBox tb = new TextBox(\"BOX1\");\n\n        // Print text in lowercase\n        System.out.println(tb.text.toLowerCase());\n    }\n\n    static class TextBox {\n        // Field\n        public String text;\n\n        // Constructor\n        public TextBox(String value) {\n            this.text = value;\n        }\n\n        // Setter method\n        public void setText(String text) {\n            this.text = text;\n        }\n\n        // Clear method\n        public void clear() {\n            this.text = \"\";\n        }\n    }\n}\n```\n\n---\n\n### Explanation:\n\n- `TextBox` is a **class** (blueprint).\n- `text` is a **field** (data stored in the object).\n- The **constructor** initializes the object.\n- `setText` and `clear` are **methods** that define behavior.\n- In `main`, we create an **object** (`tb`) using `new TextBox(\"BOX1\")`.\n\n---\n\n# From Procedural to Object-Oriented Programming\n\nIn the last lesson, we introduced **classes** and saw how objects bundle **data + behavior**.\n\nNow, let‚Äôs take a simple example ‚Äî calculating an employee‚Äôs wage ‚Äî and see how it looks:\n\n1. First, in a **procedural style** (functions + variables, separate).\n2. Then, in **OOP style** (using a class that encapsulates data + behavior).\n\n---\n\n## Procedural Approach\n\nIn a procedural style, we might write something like this:\n\n```java\npublic class ProceduralDemo {\n    public static void main(String[] args) {\n        int baseSalary = 5000;\n        int hourlyRate = 50;\n        int extraHours = 10;\n\n        int wage = calculateWage(baseSalary, hourlyRate, extraHours);\n        System.out.println(wage);\n    }\n\n    public static int calculateWage(int base, int hourlyRate, int extraHours) {\n        return base + extraHours * hourlyRate;\n    }\n}\n```\n\nüëâ Here, we:\n\n- Store data (`baseSalary`, `hourlyRate`, `extraHours`) in **separate variables**.\n- Write a **standalone function** (`calculateWage`) to compute the result.\n\nThis works, but as the program grows, managing all these **loose variables** gets messy.\n\n---\n\n## OOP Approach\n\nIn OOP, we bundle the **data** (like salary and hourly rate) and the **functionality** (like calculating wage) inside a single **class**.\n\n```java\npublic class Procedural {\n    public static void main(String[] args) {\n        Employee e = new Employee();\n        int wage = e.calculateWage(12);\n\n        e.setBaseSalary(6000); // using setter\n        System.out.println(wage);\n    }\n\n    static class Employee {\n        private int baseSalary = 5000;\n        public int hourlyRate = 50;\n\n        public int getBaseSalary() {\n            return baseSalary;\n        }\n\n        public void setBaseSalary(int baseSalary) {\n            if (baseSalary \u003c= 0) {\n                throw new IllegalArgumentException(\"Base salary cannot be negative or zero\");\n            }\n            this.baseSalary = baseSalary;\n        }\n\n        public int calculateWage(int extraHours) {\n            return this.baseSalary + this.hourlyRate * extraHours;\n        }\n    }\n}\n```\n\n---\n\n### What Changed?\n\n1. **Encapsulation**:\n   - We made `baseSalary` **private** so it cannot be modified directly.\n   - We control changes using **getters and setters**.\n   - This allows us to enforce rules (e.g., salary cannot be `0` or negative).\n\n2. **Methods inside the class**:\n   - Instead of writing a separate `calculateWage` function, it is now part of `Employee`.\n   - This makes sense because \"wage calculation\" is **behavior** of an Employee.\n\n---\n\n## Why Encapsulation Matters\n\nLet‚Äôs say we didn‚Äôt hide `baseSalary` and left it public:\n\n```java\ne.baseSalary = -1000;  // valid in procedural style, but meaningless!\n```\n\nThat would allow invalid states.\nBy making it **private** and controlling it with a setter, we ensure data integrity:\n\n```java\npublic void setBaseSalary(int baseSalary) {\n    if (baseSalary \u003c= 0) {\n        throw new IllegalArgumentException(\"Base salary cannot be negative or zero\");\n    }\n    this.baseSalary = baseSalary;\n}\n```\n\n---\n\n‚úÖ With this, we‚Äôve transitioned from procedural code ‚Üí OOP design.\nNext, we‚Äôll look at **constructors, overloading, and further encapsulation improvements**.\n\n---\n\n# **Abstraction, Coupling, Constructors, and Static Members**\n\n## Abstraction\n\n- **Definition:** Abstraction is simply reducing complexity by hiding unnecessary details.\n- Instead of exposing raw class members (fields) to the outside world, we expose **methods** that control how other code interacts with the class.\n- This hides implementation details and protects the integrity of the class.\n\n---\n\n## Coupling\n\n- **Coupling** happens when classes depend on each other.\n- Coupling is not always bad, but if classes are **tightly coupled**, then changing one class may force you to change many others.\n- By reducing coupling, we make our code more **maintainable** and **flexible**.\n\n---\n\n## Example: Employee Class\n\nInstead of exposing fields directly, we use **getters and setters** with validation.\n\n```java\npublic class Employee {\n\n    private int hourlyRate = 50;\n    private int baseSalary = 5000;\n\n    public int getBaseSalary() {\n        return baseSalary;\n    }\n\n    public void setBaseSalary(int baseSalary) {\n        if (baseSalary \u003c= 0) {\n            throw new IllegalArgumentException(\"Base salary cannot be negative or zero\");\n        }\n        this.baseSalary = baseSalary;\n    }\n\n    public int calculateWage(int extraHours) {\n        return this.baseSalary + this.hourlyRate * extraHours;\n    }\n}\n```\n\n### Key points:\n\n- We made `baseSalary` **private** to prevent direct modification.\n- We added a **setter method** with validation to avoid putting the class into a ‚Äúbad state.‚Äù\n- We exposed a **method** (`calculateWage`) to perform work instead of letting the outside code do the calculation.\n\n---\n\n## Constructors\n\nConstructors are special methods that initialize objects when they are created.\nThey help us avoid forgetting to initialize important values.\n\n```java\nclass Employee {\n    private int baseSalary;\n    private int hourlyRate;\n\n    // Constructor with parameters\n    public Employee(int baseSalary, int hourlyRate) {\n        this.baseSalary = baseSalary;\n        this.hourlyRate = hourlyRate;\n    }\n\n    // Overloaded constructor with default values\n    public Employee() {\n        this.baseSalary = 5000;\n        this.hourlyRate = 10;\n    }\n}\n```\n\n### Notes:\n\n- By providing multiple constructors (**constructor overloading**), we can simulate ‚Äúdefault parameters‚Äù in Java.\n- Unlike languages like C#, C++, Go, or JavaScript, Java does not support default parameter values directly. Overloading is the workaround.\n\n---\n\n## Static Members\n\n- A class can have **instance members** (belong to an object) or **static members** (belong to the class itself).\n- **Static methods** are useful when we don‚Äôt need an object, for example the `main` method:\n\n```java\npublic class Program {\n    public static void main(String[] args) {\n        // no object needed because main is static\n        System.out.println(\"Hello OOP\");\n    }\n}\n```\n\n### When to use static:\n\n- When a value or behavior should be **shared across all objects**.\n- When you want to provide **utility functions** (e.g., `Math.sqrt()`).\n\n---\n\n## Transition\n\nWe‚Äôve now seen:\n\n- How abstraction helps hide details.\n- How to reduce coupling between classes.\n- How constructors and method overloading make our classes safer and more flexible.\n- The difference between instance and static members.\n\nüëâ **Next time, we‚Äôll look at _inheritance_** ‚Äî how one class can derive from another and reuse its code.\n\n---\n\n# **Inheritance, Casting, Abstract Classes, and Polymorphism**\n\nIn the previous section, we talked about the **basics of OOP** ‚Äì classes, objects, encapsulation, abstraction, and methods.\nNow we‚Äôre going to push further into **how objects relate to each other** through inheritance, casting, abstract classes, and polymorphism.\n\n---\n\n## Upcasting and Downcasting\n\nIn Java, when you have a class hierarchy:\n\n```java\nclass UiControl { ... }\nclass TextBox extends UiControl { ... }\n```\n\n- **Upcasting** ‚Üí assigning a subclass (`TextBox`) to a superclass (`UiControl`) reference.\n  ‚úÖ Always safe.\n- **Downcasting** ‚Üí forcing a superclass reference back into a subclass.\n  ‚ö†Ô∏è Dangerous, only works if the object is _actually_ that subclass at runtime.\n\n```java\nUiControl control = new TextBox(true); // upcasting, safe\nTextBox tb = (TextBox) control;        // downcasting, works\n\nUiControl control2 = new UiControl(true);\nTextBox tb2 = (TextBox) control2;      // ‚ùå runtime error\n```\n\nüëâ Always check with `instanceof` or `getClass()` before downcasting.\n\n---\n\n## Abstract Classes\n\nSometimes, we want to define a **general concept** without being able to create it directly.\n\nFor example, `UiControl` is an abstract idea ‚Äì we don‚Äôt really have a generic \"control\" in a UI, but we do have specific controls like `TextBox` or `CheckBox`.\n\n```java\nabstract class UiControl {\n    private boolean isEnabled = true;\n\n    public UiControl(boolean flag) {\n        this.isEnabled = flag;\n    }\n\n    public boolean isEnabled() { return isEnabled; }\n    public void setEnabled(boolean enabled) { this.isEnabled = enabled; }\n\n    public abstract void draw(); // forces subclasses to implement\n}\n```\n\n- You **cannot instantiate** an abstract class.\n- Subclasses **must** implement the abstract methods.\n\n---\n\n## Final Classes and Methods\n\n- A **final class** cannot be extended.\n- A **final method** cannot be overridden.\n\nRarely used, but important for ensuring immutability and security.\n\n---\n\n## Polymorphism\n\nPolymorphism means **‚Äúmany forms.‚Äù**\n\nWhen you call a method on a superclass reference, the JVM will run the **actual subclass implementation** at runtime.\n\n```java\ninterface GeometricShape {\n    void draw();\n}\n\nclass Circle implements GeometricShape {\n    public void draw() { System.out.println(\"This is a circle\"); }\n}\n\nclass Square implements GeometricShape {\n    public void draw() { System.out.println(\"This is a square\"); }\n}\n```\n\nNow if we write:\n\n```java\nGeometricShape[] shapes = { new Circle(), new Square() };\n\nfor (GeometricShape s : shapes) {\n    s.draw(); // Polymorphism in action\n}\n```\n\nEach object runs its own implementation, even though the reference type is the interface.\n\n---\n\n## Comparing Objects (`equals`)\n\nBy default, the `equals` method compares object **references**, not actual content.\n\nExample:\n\n```java\nclass Point {\n    private int x, y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;                // same reference\n        if (obj == null || getClass() != obj.getClass()) return false;\n\n        Point other = (Point) obj;                   // safe cast\n        return this.x == other.x \u0026\u0026 this.y == other.y;\n    }\n}\n```\n\nNow:\n\n```java\nPoint p1 = new Point(1, 2);\nPoint p2 = new Point(1, 2);\n\nSystem.out.println(p1.equals(p2)); // true ‚úÖ (compares content)\nSystem.out.println(p1 == p2);      // false ‚ùå (different references)\n```\n\n---\n\n## Putting It All Together\n\nHere‚Äôs a summary of what we covered with live code:\n\n```java\npublic class UpCastingDowncasting {\n    public static void main(String[] args) {\n        GeometricShape[] shapes = { new Circle(), new Square() };\n        for (GeometricShape sh : shapes) sh.draw();\n    }\n}\n```\n\n- `UiControl` ‚Üí base (abstract) concept.\n- `TextBox` ‚Üí subclass (concrete).\n- Upcasting allows `TextBox` to be treated as `UiControl`.\n- Downcasting requires checks.\n- Interfaces allow polymorphism across unrelated classes.\n- Override `equals` to compare **contents**, not references.\n\n---\n\n‚úÖ Next lesson: **Interfaces and Dependency Injection**\n\n---\n\n\u003c!----\u003e\n\u003c!-- # C-9 üìò Lecture: Interfaces and Dependency Injection in Java --\u003e\n\u003c!----\u003e\n\u003c!-- Today, we‚Äôre going to dive into **interfaces** in Java, understand **why they exist**, and learn how they help us build **loosely coupled, extensible, and testable applications**. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 1. Why Interfaces? (The Restaurant Analogy) --\u003e\n\u003c!----\u003e\n\u003c!-- Imagine you own a restaurant. You hire a chef named John. John is great, but one day John gets sick. If your restaurant only works because *John* is there, your business is in trouble. --\u003e\n\u003c!----\u003e\n\u003c!-- But what if instead, you said: --\u003e\n\u003c!----\u003e\n\u003c!-- \u003e ‚ÄúI don‚Äôt care who the chef is, as long as they can cook.‚Äù --\u003e\n\u003c!----\u003e\n\u003c!-- That‚Äôs exactly what interfaces are about. We don‚Äôt tie ourselves to a **specific person (class)** ‚Äî we depend on a **contract (interface)**. --\u003e\n\u003c!----\u003e\n\u003c!-- This way, our application can keep running no matter who is ‚Äúin the kitchen.‚Äù --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 2. The Problem of Tight Coupling --\u003e\n\u003c!----\u003e\n\u003c!-- Let‚Äôs look at some code that is **tightly coupled**: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- static class TaxReport { --\u003e\n\u003c!--     private TaxCal taxCal; --\u003e\n\u003c!----\u003e\n\u003c!--     public TaxReport() { --\u003e\n\u003c!--         taxCal = new TaxCal(1000); --\u003e\n\u003c!--     } --\u003e\n\u003c!-- } --\u003e\n\u003c!----\u003e\n\u003c!-- static class TaxCal { --\u003e\n\u003c!--     private double taxableIncome; --\u003e\n\u003c!----\u003e\n\u003c!--     public TaxCal(double taxableIncome) { --\u003e\n\u003c!--         this.taxableIncome = taxableIncome; --\u003e\n\u003c!--     } --\u003e\n\u003c!----\u003e\n\u003c!--     public double calculateTax() { --\u003e\n\u003c!--         return taxableIncome * 0.3; --\u003e\n\u003c!--     } --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- Here‚Äôs the issue: --\u003e\n\u003c!----\u003e\n\u003c!-- * `TaxReport` directly depends on `TaxCal`. --\u003e\n\u003c!-- * If we change the `TaxCal` implementation, we might break `TaxReport`. --\u003e\n\u003c!-- * If we want to introduce a new tax rule (e.g., 2020 tax laws), we‚Äôd have to rewrite parts of `TaxReport`. --\u003e\n\u003c!----\u003e\n\u003c!-- This is **tight coupling**, and it makes code brittle and hard to maintain. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 3. Breaking the Coupling with Interfaces --\u003e\n\u003c!----\u003e\n\u003c!-- Now let‚Äôs introduce an **interface** to reduce coupling: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- interface TaxCalculator { --\u003e\n\u003c!--     double calculateTax(); --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- Instead of depending on a *concrete class*, `TaxReport` now depends on this *contract*: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- static class TaxReport { --\u003e\n\u003c!--     private TaxCalculator taxCal; --\u003e\n\u003c!----\u003e\n\u003c!--     // Constructor Injection --\u003e\n\u003c!--     public TaxReport(TaxCalculator tc) { --\u003e\n\u003c!--         taxCal = tc; --\u003e\n\u003c!--     } --\u003e\n\u003c!----\u003e\n\u003c!--     public void printReport() { --\u003e\n\u003c!--         System.out.println(taxCal.calculateTax()); --\u003e\n\u003c!--     } --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- Notice: --\u003e\n\u003c!----\u003e\n\u003c!-- * `TaxReport` doesn‚Äôt care *which* `TaxCalculator` it‚Äôs given. --\u003e\n\u003c!-- * As long as the class implements `TaxCalculator`, `TaxReport` is happy. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 4. Multiple Implementations --\u003e\n\u003c!----\u003e\n\u003c!-- Now we can write different tax calculators without breaking `TaxReport`: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- static class TaxCal implements TaxCalculator { --\u003e\n\u003c!--     private double taxableIncome; --\u003e\n\u003c!----\u003e\n\u003c!--     public TaxCal(double taxableIncome) { --\u003e\n\u003c!--         this.taxableIncome = taxableIncome; --\u003e\n\u003c!--     } --\u003e\n\u003c!----\u003e\n\u003c!--     @Override --\u003e\n\u003c!--     public double calculateTax() { --\u003e\n\u003c!--         return taxableIncome * 0.3; --\u003e\n\u003c!--     } --\u003e\n\u003c!-- } --\u003e\n\u003c!----\u003e\n\u003c!-- static class TaxCal2020 implements TaxCalculator { --\u003e\n\u003c!--     private double taxableIncome; --\u003e\n\u003c!----\u003e\n\u003c!--     public TaxCal2020(double taxableIncome) { --\u003e\n\u003c!--         this.taxableIncome = taxableIncome; --\u003e\n\u003c!--     } --\u003e\n\u003c!----\u003e\n\u003c!--     @Override --\u003e\n\u003c!--     public double calculateTax() { --\u003e\n\u003c!--         return taxableIncome * 0.25;  // new rules for 2020 --\u003e\n\u003c!--     } --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- Now `TaxReport` can work with **any** tax calculator: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- public static void main(String[] args) { --\u003e\n\u003c!--     TaxCalculator calc = new TaxCal(1000); --\u003e\n\u003c!--     TaxReport tr = new TaxReport(calc); --\u003e\n\u003c!--     tr.printReport(); --\u003e\n\u003c!----\u003e\n\u003c!--     TaxCalculator calc2020 = new TaxCal2020(1000); --\u003e\n\u003c!--     TaxReport tr2020 = new TaxReport(calc2020); --\u003e\n\u003c!--     tr2020.printReport(); --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 5. Dependency Injection --\u003e\n\u003c!----\u003e\n\u003c!-- What we just did is called **Dependency Injection (DI)**. --\u003e\n\u003c!----\u003e\n\u003c!-- Instead of `TaxReport` creating its own dependencies, we **inject** them from outside. --\u003e\n\u003c!-- There are three main ways to inject dependencies: --\u003e\n\u003c!----\u003e\n\u003c!-- 1. **Constructor Injection** (most common, what we used) --\u003e\n\u003c!-- 2. **Setter Injection** (pass a dependency via a setter method) --\u003e\n\u003c!-- 3. **Method Injection** (pass a dependency as a parameter to a method call) --\u003e\n\u003c!----\u003e\n\u003c!-- In real projects, you won‚Äôt manually manage all dependencies. --\u003e\n\u003c!-- Instead, you‚Äôll often use a **DI Framework** like **Spring** to do this for you automatically. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 6. Interface Segregation --\u003e\n\u003c!----\u003e\n\u003c!-- One last point: --\u003e\n\u003c!----\u003e\n\u003c!-- If you create a huge ‚Äúgod interface‚Äù with too many methods, every implementing class is forced to implement things it doesn‚Äôt care about. --\u003e\n\u003c!----\u003e\n\u003c!-- That‚Äôs bad design. --\u003e\n\u003c!----\u003e\n\u003c!-- Instead, follow the **Interface Segregation Principle (ISP)**: --\u003e\n\u003c!----\u003e\n\u003c!-- \u003e Split large interfaces into smaller, more focused ones. --\u003e\n\u003c!----\u003e\n\u003c!-- For example: --\u003e\n\u003c!----\u003e\n\u003c!-- ```java --\u003e\n\u003c!-- interface Drivable { --\u003e\n\u003c!--     void drive(); --\u003e\n\u003c!-- } --\u003e\n\u003c!----\u003e\n\u003c!-- interface Flyable { --\u003e\n\u003c!--     void fly(); --\u003e\n\u003c!-- } --\u003e\n\u003c!----\u003e\n\u003c!-- class Car implements Drivable { --\u003e\n\u003c!--     public void drive() { System.out.println(\"Car is driving\"); } --\u003e\n\u003c!-- } --\u003e\n\u003c!----\u003e\n\u003c!-- class Plane implements Drivable, Flyable { --\u003e\n\u003c!--     public void drive() { System.out.println(\"Plane is taxiing\"); } --\u003e\n\u003c!--     public void fly() { System.out.println(\"Plane is flying\"); } --\u003e\n\u003c!-- } --\u003e\n\u003c!-- ``` --\u003e\n\u003c!----\u003e\n\u003c!-- This way, classes only implement what they actually need. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## 7. A Note on Default, Private, and Static Methods in Interfaces --\u003e\n\u003c!----\u003e\n\u003c!-- Since Java 8, interfaces can have `default` and `static` methods. --\u003e\n\u003c!-- Since Java 9, they can even have `private` methods. --\u003e\n\u003c!----\u003e\n\u003c!-- Personally, I recommend being cautious here. Why? --\u003e\n\u003c!----\u003e\n\u003c!-- * An interface‚Äôs purpose is to define a **contract**. --\u003e\n\u003c!-- * Putting too much code inside an interface can blur the line between **contracts** and **implementations**. --\u003e\n\u003c!-- * If you need to share common logic between multiple classes, an **abstract class** that implements the interface is often a cleaner design. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- ## ‚úÖ Summary --\u003e\n\u003c!----\u003e\n\u003c!-- * **Interfaces** define *what* a class can do, not *how*. --\u003e\n\u003c!-- * They help us build **loosely coupled, extensible, and testable applications**. --\u003e\n\u003c!-- * **Dependency Injection** means passing dependencies instead of creating them internally. --\u003e\n\u003c!-- * Use frameworks like **Spring** for large-scale projects. --\u003e\n\u003c!-- * Apply the **Interface Segregation Principle** to avoid ‚Äúfat‚Äù interfaces. --\u003e\n\u003c!-- * Be careful with `default`, `static`, and `private` methods inside interfaces ‚Äî prefer abstract classes for shared logic. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\u003c!-- üëâ And that‚Äôs interfaces in Java. --\u003e\n\u003c!-- Next time, we‚Äôll look at how interfaces and **abstract classes** work together to design even more flexible systems. --\u003e\n\u003c!----\u003e\n\u003c!-- --- --\u003e\n\u003c!----\u003e\n\n# Java Interfaces and Inheritance Guide\n\n## Why interfaces exists ?- THE BIG PICTURE\n\n### The Restaurant Analogy\n\nImagine you own a restaurant and hire a chef named John. John is great, but what happens when John gets sick? If your restaurant only works because _John_ is there, your business is in trouble.\n\nBut what if instead, you said: _\"I don't care who the chef is, as long as they can cook.\"_\n\nThat's exactly what interfaces are about. We don't tie ourselves to a **specific person (class)** ‚Äî we depend on a **contract (interface)**. This way, our application can keep running no matter who is \"in the kitchen.\"\n\n### The Problem: **Tight Coupling**\n\nLet's look at code that is **tightly coupled**:\n\n```java\nstatic class TaxReport {\n    private TaxCal taxCal;\n\n    public TaxReport() {\n        taxCal = new TaxCal(1000); // Directly creates dependency\n    }\n}\n\nstatic class TaxCal {\n    private double taxableIncome;\n\n    public TaxCal(double taxableIncome) {\n        this.taxableIncome = taxableIncome;\n    }\n\n    public double calculateTax() {\n        return taxableIncome * 0.3;\n    }\n}\n```\n\nProblems with this approach:\n\n- `TaxReport` directly depends on `TaxCal`\n- Changing `TaxCal` might break `TaxReport`\n- Adding new tax rules requires rewriting `TaxReport`\n- Hard to test in isolation\n\n### The Solution: Programming Against Interfaces\n\n```java\ninterface TaxCalculator {\n    double calculateTax();\n}\n\nstatic class TaxReport {\n    private TaxCalculator taxCal;\n\n    // Constructor Injection - depends on contract, not implementation\n    public TaxReport(TaxCalculator tc) {\n        taxCal = tc;\n    }\n\n    public void printReport() {\n        System.out.println(taxCal.calculateTax());\n    }\n}\n```\n\nNow `TaxReport` doesn't care _which_ `TaxCalculator` it receives - it just needs something that fulfills the contract.\n\n## Multiple Inher rules\n\n### Classes: Single Inheritance Only\n\n**Java classes cannot extend multiple classes**. Java only allows **single inheritance**:\n\n```java\nclass A { }\nclass B { }\n// ‚ùå Not allowed - will cause compile error\nclass C extends A, B { }\n```\n\n### Interfaces: Multiple Inheritance Allowed\n\nUnlike classes, an **interface can extend multiple interfaces**:\n\n```java\ninterface A { void foo(); }\ninterface B { void bar(); }\n\n// ‚úÖ Perfectly valid\ninterface C extends A, B {\n    void baz();\n}\n```\n\nSo `C` inherits `foo()` from `A` and `bar()` from `B`.\n\n## Hndeling method coflicts\n\n### Same Method Signature = No Conflict\n\nWhen interfaces have methods with identical signatures, there's no problem:\n\n```java\ninterface A { void doSomething(); }\ninterface B { void doSomething(); }\ninterface C extends A, B { } // No conflict\n\nclass MyClass implements C {\n    public void doSomething() {\n        System.out.println(\"Single implementation satisfies both\");\n    }\n}\n```\n\nThe compiler sees them as **one method contract**.\n\n### Different Signatures = Method Overloading\n\n```java\ninterface A { void doSomething(); }\ninterface B { void doSomething(String msg); }\ninterface C extends A, B { }\n\nclass MyClass implements C {\n    public void doSomething() { System.out.println(\"No args\"); }\n    public void doSomething(String msg) { System.out.println(msg); }\n}\n```\n\n### Default Method Conflicts (Java 8+)\n\nWhen interfaces have conflicting default methods, you **must** resolve the conflict:\n\n```java\ninterface A {\n    default void hello() { System.out.println(\"Hello from A\"); }\n}\n\ninterface B {\n    default void hello() { System.out.println(\"Hello from B\"); }\n}\n\ninterface C extends A, B {\n    @Override\n    default void hello() {\n        A.super.hello(); // Choose A's, B's, or write custom implementation\n    }\n}\n```\n\n## Interface evolution through java versions\n\n### Pre-Java 8: Pure Contracts\n\n- Only abstract methods (implicitly `public abstract`)\n- Only `public static final` constants\n- No implemented methods allowed\n\n### Java 8: Default and Static Methods\n\nInterfaces can now have:\n\n- **Default methods**: Provide fallback implementations\n- **Static methods**: Utility methods belonging to the interface\n\n```java\ninterface Vehicle {\n    void move(); // abstract method\n\n    default void honk() {  // default method\n        System.out.println(\"Beep!\");\n    }\n\n    static void serviceInfo() { // static method\n        System.out.println(\"Service required every 6 months\");\n    }\n}\n```\n\n### Java 9+: Private Methods\n\nAdded **private methods** for organizing code within interfaces:\n\n```java\ninterface Calculator {\n    default int addAndLog(int a, int b) {\n        logOperation(\"Addition\");\n        return a + b;\n    }\n\n    default int subtractAndLog(int a, int b) {\n        logOperation(\"Subtraction\");\n        return a - b;\n    }\n\n    private void logOperation(String operation) { // Helper method\n        System.out.println(\"Performing: \" + operation);\n    }\n}\n```\n\n## Dependency injection patterns\n\n### Three Types of Dependency Injection\n\n1. **Constructor Injection** (recommended):\n\n```java\nclass TaxReport {\n    private final TaxCalculator calculator;\n\n    public TaxReport(TaxCalculator calculator) {\n        this.calculator = calculator;\n    }\n}\n```\n\n2. Setter Injection:\n\n```java\nclass TaxReport {\n    private TaxCalculator calculator;\n\n    public void setTaxCalculator(TaxCalculator calculator) {\n        this.calculator = calculator;\n    }\n}\n```\n\n3. Method Injection:\n\n```java\nclass TaxReport {\n    public void generateReport(TaxCalculator calculator) {\n        // Use calculator for this specific operation\n    }\n}\n```\n\n### Benefits of Dependency Injection\n\n- **Flexibility**: Easy to swap implementations\n- **Testability**: Can inject mock objects for testing\n- **Extensibility**: Add new implementations without changing existing code\n- **Loose Coupling**: Classes depend on abstractions, not concrete implementations\n\n## Desig principles and best practices\n\n### Interface Segregation Principle (ISP)\n\nAvoid creating \"god interfaces\" with too many methods. Split large interfaces into smaller, focused ones:\n\n```java\n// ‚ùå Bad: Fat interface\ninterface VehicleOperations {\n    void drive();\n    void fly();\n    void swim();\n    void refuel();\n    void recharge();\n}\n\n// ‚úÖ Good: Segregated interfaces\ninterface Drivable { void drive(); }\ninterface Flyable { void fly(); }\ninterface Rechargeable { void recharge(); }\n\nclass Car implements Drivable, Rechargeable {\n    public void drive() { System.out.println(\"Car is driving\"); }\n    public void recharge() { System.out.println(\"Car is charging\"); }\n    // No need to implement fly() or swim()\n}\n```\n\n### When to Use Abstract Classes vs Interfaces\n\nUse Abstract Classes When:\n\n- You need to share code between related classes\n- You have common state (fields) to share\n- Classes have a clear \"is-a\" relationship\n- You want to provide partial implementations\n\nUse Interfaces When:\n\n- You need multiple inheritance\n- Defining contracts for unrelated classes\n- You want loose coupling and flexibility\n- Building for testability\n\n### Modern Interface Design Guidelines\n\nStatic Methods in Interfaces:\n\n- Belong to the interface namespace, not implementing classes\n- Called via `InterfaceName.methodName()`\n- Consider if utility classes might be cleaner\n\nDefault Methods:\n\n- Use sparingly to avoid blurring interface purpose\n- Good for interface evolution without breaking existing code\n- Don't overuse - interfaces should primarily define contracts\n\nPrivate Methods:\n\n- Useful for organizing code within the interface\n- Help reduce duplication in default methods\n- Only visible within the same interface\n\n## Practical example : Multiple implementations\n\nHere's how you can create multiple implementations and swap them easily:\n\n```java\n// Different tax calculation strategies\nstatic class TaxCal implements TaxCalculator {\n    private double taxableIncome;\n\n    public TaxCal(double taxableIncome) {\n        this.taxableIncome = taxableIncome;\n    }\n\n    @Override\n    public double calculateTax() {\n        return taxableIncome * 0.3; // Standard rate\n    }\n}\n\nstatic class TaxCal2020 implements TaxCalculator {\n    private double taxableIncome;\n\n    public TaxCal2020(double taxableIncome) {\n        this.taxableIncome = taxableIncome;\n    }\n\n    @Override\n    public double calculateTax() {\n        return taxableIncome * 0.25; // 2020 tax rules\n    }\n}\n\n// Usage - easy to swap implementations\npublic static void main(String[] args) {\n    TaxCalculator calc = new TaxCal(1000);\n    TaxReport tr = new TaxReport(calc);\n    tr.printReport(); // Uses standard calculation\n\n    TaxCalculator calc2020 = new TaxCal2020(1000);\n    TaxReport tr2020 = new TaxReport(calc2020);\n    tr2020.printReport(); // Uses 2020 rules\n}\n```\n\n## Important interview insights\n\n### The Classic \"Interface vs Abstract Class\" Question\n\nThis is often considered an **outdated interview question** for several reasons:\n\n**Why it's problematic:**\n\n- Shows lack of modern interviewing experience\n- Focuses on memorization rather than practical problem-solving\n- Doesn't reflect real-world development challenges\n- Many modern languages don't even have these concepts\n\n**What matters more in 2025:**\n\n- Understanding appropriate design patterns\n- Building maintainable, testable applications\n- Knowing when to use loose coupling\n- Practical problem-solving skills\n\n**The Real Answer:**\n\n- **Interfaces** = contracts for loose coupling and flexibility\n- **Abstract classes** = partially implemented classes for sharing code between related classes\n- **Focus on** = choosing the right tool for the design problem, not memorizing differences\n\n## KEY TAKEAWAYS\n\n### Core Principles\n\n1. **Program against interfaces, not implementations** - enables flexibility and testability\n2. **Use dependency injection** to reduce coupling and improve testability\n3. **Keep interfaces focused** - follow Interface Segregation Principle\n4. **Interfaces define contracts** - what classes can do, not how they do it\n\n### Design Recommendations\n\n1. **Keep interfaces clean** - primarily for defining contracts\n2. **Use abstract classes for shared code** between related classes\n3. **Prefer composition over inheritance** when possible\n4. **Avoid overusing default methods** - they can blur interface purpose\n5. **Use DI frameworks** (like Spring) for complex applications\n\n### Benefits of This Approach\n\n- **Loose Coupling**: Components depend on abstractions, not concrete classes\n- **Extensibility**: Easy to add new implementations without changing existing code\n- **Testability**: Can inject mock objects for unit testing\n- **Maintainability**: Changes in one implementation don't affect others\n- **Flexibility**: Can swap implementations at runtime\n\nRemember: Good design is about **clarity of responsibility**. Interfaces should define contracts, abstract classes should share code, and utility classes should contain common helpers. Don't mix these roles unnecessarily.\n","slug":"Oop","title":"Oop","section":"A Quick Refresher","icon":"rotate","filePath":"/home/runner/work/complete-intro-to-spring-and-springBoot/complete-intro-to-spring-and-springBoot/lessons/00-A quick Refresher/C-Oop.md","nextSlug":"/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Advanced java","prevSlug":"/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Java Fundamentals"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"A quick Refresher","slug":"Oop"},"buildId":"xTwxhuCtUf2QTtgk5CpXn","assetPrefix":"/complete-intro-to-spring-and-springBoot","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>