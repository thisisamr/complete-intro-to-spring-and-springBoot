<!DOCTYPE html><html><head><meta charSet="utf-8" data-next-head=""/><meta name="viewport" content="width=device-width" data-next-head=""/><link rel="apple-touch-icon" sizes="180x180" href="/complete-intro-to-spring-and-springBoot/images/apple-touch-icon.png" data-next-head=""/><link rel="icon" type="image/png" sizes="32x32" href="/complete-intro-to-spring-and-springBoot/images/favicon-32x32.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/complete-intro-to-spring-and-springBoot/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/png" sizes="16x16" href="/complete-intro-to-spring-and-springBoot/images/favicon-16x16.png" data-next-head=""/><link rel="icon" type="image/x-icon" href="/complete-intro-to-spring-and-springBoot/images/favicon.ico" data-next-head=""/><title data-next-head="">Async Java – Complete intro to Spring and Spring boot</title><meta name="description" content="" data-next-head=""/><meta name="keywords" content="java,spring,spring boot,enterprise" data-next-head=""/><meta name="og:description" content="" data-next-head=""/><meta name="og:title" content="Async Java – Complete intro to Spring and Spring boot" data-next-head=""/><meta name="og:image" content="/complete-intro-to-spring-and-springBoot/images/social-share-cover.jpg" data-next-head=""/><meta name="twitter:card" content="summary_large_image" data-next-head=""/><link data-next-font="size-adjust" rel="preconnect" href="/" crossorigin="anonymous"/><link rel="preload" href="/complete-intro-to-spring-and-springBoot/_next/static/css/a177a108a1e5ef8e.css" as="style"/><link rel="stylesheet" href="/complete-intro-to-spring-and-springBoot/_next/static/css/a177a108a1e5ef8e.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" noModule="" src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/polyfills-42372ed130431b0a.js"></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/webpack-ef71630eba064876.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/framework-2f335d22a7318891.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/main-68b275a1c1cc8358.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/pages/_app-f402e663bac92a23.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/chunks/pages/lessons/%5Bsection%5D/%5Bslug%5D-76fa85589bbed6c1.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/xTwxhuCtUf2QTtgk5CpXn/_buildManifest.js" defer=""></script><script src="/complete-intro-to-spring-and-springBoot/_next/static/xTwxhuCtUf2QTtgk5CpXn/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div class="remix-app"><header class="navbar"><h1 class="navbar-brand"><a href="/complete-intro-to-spring-and-springBoot">Complete intro to Spring and Spring boot</a></h1><div class="navbar-info"><a href="https://www.youtube.com/@thisis3mr" class="cta-btn">Watch on youtube</a></div></header><div class="content-container"><div class="main"><div class="lesson-container"><div class="lesson"><div class="lesson-content"><h1>Async Java</h1>
<p>Asynchronous programming is a style of writing code where a long-running operation
is started, and the main program continues its work <strong>without waiting</strong>
for that operation to finish. In Java, this is often managed using the <code>Future</code> interface.</p>
<h2>The <code>Future</code> Interface: A Placeholder for Results</h2>
<p>The <strong><code>Future&lt;T&gt;</code></strong> interface is a core component of Java&#39;s concurrency utilities.
It represents the <strong>result of an asynchronous computation</strong> that may not have completed yet.
When you start a task on a background thread (e.g., using an <code>ExecutorService</code>), the method returns a <code>Future</code> object immediately. This object is essentially a <strong>placeholder</strong> for the eventual result (of type <code>T</code>).</p>
<h4><strong>How to Get a Future</strong></h4>
<p>You typically obtain a <code>Future</code> by submitting a task (a <code>Callable</code>) to an <code>ExecutorService</code>:</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">import</span> java.util.concurrent.*;

<span class="hljs-comment">// 1. Create a service to run background threads</span>
<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();

<span class="hljs-comment">// 2. Submit a long-running task that returns a value (Callable)</span>
Future&lt;Integer&gt; futureResult = executor.submit(() -&gt; {
    System.out.println(<span class="hljs-string">&quot;...Starting background task (simulating 3 seconds)...&quot;</span>);
    Thread.sleep(<span class="hljs-number">3000</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// The final result</span>
});

<span class="hljs-comment">// The main thread continues running immediately.</span>
System.out.println(<span class="hljs-string">&quot;Main thread is not blocked yet, doing other work...&quot;</span>);
</code></pre><h3>Future Interface Methods</h3>
<table>
<thead>
<tr>
<th align="left">Method</th>
<th align="left">Purpose</th>
<th align="left">Key Behavior and Limitation</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong><code>get()</code></strong></td>
<td align="left">Retrieves the result.</td>
<td align="left"><strong>BLOCKS</strong> the calling thread indefinitely until the result is available or an exception is thrown. <strong>This is usually what asynchronous code tries to avoid.</strong></td>
</tr>
<tr>
<td align="left"><strong><code>get(timeout, unit)</code></strong></td>
<td align="left">Retrieves the result with a time limit.</td>
<td align="left"><strong>BLOCKS</strong> the calling thread. Throws a <code>TimeoutException</code> if the result isn&#39;t ready in time.</td>
</tr>
<tr>
<td align="left"><strong><code>isDone()</code></strong></td>
<td align="left">Check if task completed.</td>
<td align="left">Returns <code>true</code> if the task has finished, whether normally, by cancellation, or with an error.</td>
</tr>
<tr>
<td align="left"><strong><code>cancel(mayInterrupt)</code></strong></td>
<td align="left">Attempt to cancel the task.</td>
<td align="left">Attempts to stop the running task. Returns <code>true</code> if the cancellation was successful.</td>
</tr>
</tbody></table>
<p><strong><em>The main limitation of the original <code>Future</code> is that retrieving the result via <code>get()</code> requires the calling thread to stop and wait. For modern, non-blocking asynchronous programming, Java developers prefer the</em></strong> <strong><code>CompletableFuture</code></strong> <strong><em>class (introduced in Java 8), which allows you to chain tasks and react to completion without blocking.</em></strong></p>
<hr>
<h2>Understanding Concurrency vs. Parallelism vs. Asynchronous</h2>
<p>These three terms are often confused. Here’s how they differ:</p>
<table>
<thead>
<tr>
<th align="left">Term</th>
<th align="left">Meaning</th>
<th align="left">Requires Multiple Cores?</th>
<th align="left">Practical Analogy</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Concurrent</strong></td>
<td align="left">Many tasks making <strong>progress</strong> over overlapping time periods by rapidly switching between them.</td>
<td align="left">❌ Not necessarily (can run on one core)</td>
<td align="left"><strong>One Chef</strong> juggling three orders: they chop for a minute, stir for a minute, then check the oven. All tasks are <em>progressing</em> over time.</td>
</tr>
<tr>
<td align="left"><strong>Parallel</strong></td>
<td align="left">Tasks running <strong>literally at the same instant</strong> (simultaneously) on different CPU cores.</td>
<td align="left">✅ Yes</td>
<td align="left"><strong>Three Chefs</strong> working on three different orders <strong>at the exact same time</strong> on three different stations.</td>
</tr>
<tr>
<td align="left"><strong>Asynchronous</strong></td>
<td align="left">A <strong>programming style</strong> where the caller initiates a task and continues its own work, using a <code>Future</code> or callback to handle the result later.</td>
<td align="left">❌ No (It&#39;s a coding approach)</td>
<td align="left"><strong>Placing a take-out order</strong> by phone: You hang up and drive to the restaurant. You don&#39;t stay on hold the whole time waiting for the food.</td>
</tr>
</tbody></table>
<h3>Future Interface Methods</h3>
<ul>
<li><code>get()</code>: Blocks until result is available (throws checked exceptions)</li>
<li><code>get(timeout, unit)</code>: Blocks with timeout</li>
<li><code>isDone()</code>: Check if task completed</li>
<li><code>cancel(mayInterrupt)</code>: Attempt to cancel the task</li>
</ul>
<h2>Understanding Concurrency vs Parallelism vs Asynchronous</h2>
<h3>Definitions</h3>
<table>
<thead>
<tr>
<th>Term</th>
<th>Meaning</th>
<th>Needs Multiple Cores?</th>
<th>Typical Use</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Parallel</strong></td>
<td>Tasks run literally at the same time</td>
<td>✅ Yes</td>
<td>CPU-bound work (math, image processing)</td>
</tr>
<tr>
<td><strong>Concurrent</strong></td>
<td>Many tasks progressing in overlapping time</td>
<td>❌ Not necessarily</td>
<td>Task scheduling, multitasking</td>
</tr>
<tr>
<td><strong>Asynchronous</strong></td>
<td>Task runs in background, caller doesn&#39;t wait</td>
<td>❌ No</td>
<td>I/O-bound work (network, DB, files)</td>
</tr>
</tbody></table>
<h3>Examples</h3>
<p><strong>Parallel Processing:</strong></p>
<pre><code class="hljs language-java">IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)
    .parallel()
    .forEach(i -&gt; System.out.println(i + <span class="hljs-string">&quot; &quot;</span> + Thread.currentThread()));
</code></pre><p><strong>Concurrent Processing:</strong></p>
<pre><code class="hljs language-java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);
pool.submit(() -&gt; doWork(<span class="hljs-string">&quot;A&quot;</span>));
pool.submit(() -&gt; doWork(<span class="hljs-string">&quot;B&quot;</span>));
<span class="hljs-comment">// Tasks overlap in time, may or may not run simultaneously</span>
</code></pre><p><strong>Asynchronous Processing:</strong></p>
<pre><code class="hljs language-java">CompletableFuture.runAsync(() -&gt; {
    delay();
    System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);
});
System.out.println(<span class="hljs-string">&quot;I don&#x27;t block!&quot;</span>); <span class="hljs-comment">// Runs immediately</span>
</code></pre><h3>What Does &quot;Asynchronous&quot; Really Mean?</h3>
<p>Asynchronous programming is about <strong>non-blocking execution</strong>:</p>
<ul>
<li>You start a task</li>
<li>Your thread continues with other work</li>
<li>The task completes later and notifies you (via callback, promise, etc.)</li>
</ul>
<p>Think of it like ordering coffee:</p>
<ul>
<li><strong>Synchronous</strong>: Order coffee → wait → receive coffee → continue</li>
<li><strong>Asynchronous</strong>: Order coffee → do other things → get notified when ready</li>
</ul>
<h2>CompletableFuture: Modern Asynchronous Programming</h2>
<h3>Introduction</h3>
<p><code>CompletableFuture</code> is Java&#39;s equivalent to JavaScript Promises. It has three states:</p>
<ul>
<li><strong>Pending</strong>: Task is running</li>
<li><strong>Resolved</strong>: Task completed successfully</li>
<li><strong>Rejected</strong>: Task failed with an exception</li>
</ul>
<h3>Basic Usage</h3>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncExample</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Fire and forget</span>
        show().join(); <span class="hljs-comment">// join() blocks until completion</span>

        <span class="hljs-comment">// With return value</span>
        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> show2().get();
            System.out.println(<span class="hljs-string">&quot;Returned: &quot;</span> + value);
        } <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);
        }
    }

    <span class="hljs-comment">// CompletableFuture.runAsync for void tasks</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">show</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> CompletableFuture.runAsync(() -&gt; {
            delay();
            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);
        });
    }

    <span class="hljs-comment">// CompletableFuture.supplyAsync for tasks with return values</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">show2</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; {
            delay();
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;
        });
    }
}
</code></pre><h3>Building Async APIs</h3>
<pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailSender</span> {
    <span class="hljs-comment">// Synchronous method</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendMail</span><span class="hljs-params">()</span> {
        delay();
        System.out.println(<span class="hljs-string">&quot;mail sent !!!!&quot;</span>);
    }

    <span class="hljs-comment">// Asynchronous wrapper</span>
    <span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">sendMailAsync</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> CompletableFuture.runAsync(() -&gt; sendMail());
    }
}

<span class="hljs-comment">// Usage</span>
<span class="hljs-type">var</span> <span class="hljs-variable">mailService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MailSender</span>();
<span class="hljs-type">var</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> mailService.sendMailAsync();
System.out.println(<span class="hljs-string">&quot;This runs immediately&quot;</span>);
future.join(); <span class="hljs-comment">// Wait for completion</span>
</code></pre><h2>Chaining Operations</h2>
<h3>CompletableFuture Chaining Methods</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Input Lambda</th>
<th>Returns</th>
<th>Use Case</th>
</tr>
</thead>
<tbody><tr>
<td><code>thenApply(fn)</code></td>
<td><code>T -&gt; U</code></td>
<td><code>CompletableFuture&lt;U&gt;</code></td>
<td>Transform result (sync)</td>
</tr>
<tr>
<td><code>thenApplyAsync(fn)</code></td>
<td><code>T -&gt; U</code></td>
<td><code>CompletableFuture&lt;U&gt;</code></td>
<td>Transform result (async)</td>
</tr>
<tr>
<td><code>thenAccept(consumer)</code></td>
<td><code>T -&gt; void</code></td>
<td><code>CompletableFuture&lt;Void&gt;</code></td>
<td>Consume result, no return</td>
</tr>
<tr>
<td><code>thenAcceptAsync(consumer)</code></td>
<td><code>T -&gt; void</code></td>
<td><code>CompletableFuture&lt;Void&gt;</code></td>
<td>Consume result (async)</td>
</tr>
<tr>
<td><code>thenRun(runnable)</code></td>
<td><code>() -&gt; void</code></td>
<td><code>CompletableFuture&lt;Void&gt;</code></td>
<td>Run after completion</td>
</tr>
<tr>
<td><code>thenCompose(fn)</code></td>
<td><code>T -&gt; CompletableFuture&lt;U&gt;</code></td>
<td><code>CompletableFuture&lt;U&gt;</code></td>
<td>Chain async operations</td>
</tr>
</tbody></table>
<h3>Practical Examples</h3>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompletableFutureChaining</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Transform and consume</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">12</span>)
            .thenApplyAsync(v -&gt; v * <span class="hljs-number">2</span>) <span class="hljs-comment">// Transform: 12 -&gt; 24</span>
            .thenAcceptAsync(v -&gt; {
                delay();
                System.out.println(<span class="hljs-string">&quot;Thread: &quot;</span> + Thread.currentThread().getName());
                System.out.println(<span class="hljs-string">&quot;Value: &quot;</span> + v);
            });

        future.join();
    }
}
</code></pre><h3>thenApply vs thenCompose</h3>
<p><strong>Key Difference:</strong></p>
<ul>
<li><code>thenApply</code>: Use when your function returns a <strong>plain value</strong> (<code>T -&gt; U</code>)</li>
<li><code>thenCompose</code>: Use when your function returns a <strong>CompletableFuture</strong> (<code>T -&gt; CompletableFuture&lt;U&gt;</code>)</li>
</ul>
<pre><code class="hljs language-java"><span class="hljs-comment">// thenApply - transforms value</span>
CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;User123&quot;</span>)
    .thenApply(id -&gt; fetchProfileSync(id)) <span class="hljs-comment">// Returns Profile</span>
    .thenAccept(System.out::println);

<span class="hljs-comment">// thenCompose - chains futures (avoids nesting)</span>
CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;User123&quot;</span>)
    .thenCompose(id -&gt; fetchProfileAsync(id)) <span class="hljs-comment">// Returns CompletableFuture&lt;Profile&gt;</span>
    .thenAccept(System.out::println);
</code></pre><p>Without <code>thenCompose</code>, you&#39;d get <code>CompletableFuture&lt;CompletableFuture&lt;Profile&gt;&gt;</code> (nested futures).</p>
<h2>Combining Futures</h2>
<h3>Combining Two Futures</h3>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CombiningFutures</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Get price in USD</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">priceInUSD</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">39</span>);

        <span class="hljs-comment">// Get exchange rate USD -&gt; EGP</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">exchangeRate</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">50</span>);

        <span class="hljs-comment">// Combine results</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">finalPrice</span> <span class="hljs-operator">=</span> priceInUSD.thenCombine(exchangeRate,
            (price, rate) -&gt; price * rate);

        System.out.println(<span class="hljs-string">&quot;Final price: &quot;</span> + finalPrice.join());

        <span class="hljs-comment">// More complex example with string parsing</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">priceString</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;39usd&quot;</span>);
        <span class="hljs-type">var</span> <span class="hljs-variable">rate</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-number">50</span>);

        <span class="hljs-type">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> priceString
            .thenApply(price -&gt; {
                <span class="hljs-type">var</span> <span class="hljs-variable">cleanPrice</span> <span class="hljs-operator">=</span> price.replace(<span class="hljs-string">&quot;usd&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
                <span class="hljs-keyword">return</span> Integer.parseInt(cleanPrice);
            })
            .thenCombine(rate, (price, exchangeRate) -&gt; price * exchangeRate);

        System.out.println(<span class="hljs-string">&quot;Parsed result: &quot;</span> + result.join());
    }
}
</code></pre><h3>Working with Multiple Futures</h3>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultipleFutures</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">var</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; { delay(); <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; });
        <span class="hljs-type">var</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; { delay(); <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>; });
        <span class="hljs-type">var</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; { delay(); <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>; });
        <span class="hljs-type">var</span> <span class="hljs-variable">f4</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; { delay(); <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>; });

        <span class="hljs-comment">// Wait for ALL to complete</span>
        CompletableFuture.allOf(f1, f2, f3, f4).join();
        System.out.println(<span class="hljs-string">&quot;All completed: &quot;</span> + f1.join());

        <span class="hljs-comment">// Wait for ANY to complete (first wins)</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; {
            delay(<span class="hljs-number">6</span>); <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;slow&quot;</span>;
        });
        <span class="hljs-type">var</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; {
            delay(<span class="hljs-number">1</span>); <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fast&quot;</span>;
        });

        CompletableFuture.anyOf(slow, fast)
            .thenAccept(System.out::println) <span class="hljs-comment">// Prints &quot;fast&quot;</span>
            .join();
    }
}
</code></pre><h2>Error Handling</h2>
<h3>Exception Handling Patterns</h3>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorHandling</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-comment">// Using exceptionally for error recovery</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Something went wrong!&quot;</span>);
        });

        <span class="hljs-keyword">try</span> {
            <span class="hljs-type">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.exceptionally(throwable -&gt; {
                System.out.println(<span class="hljs-string">&quot;Error: &quot;</span> + throwable.getMessage());
                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;default_value&quot;</span>; <span class="hljs-comment">// Fallback value</span>
            }).get();

            System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result); <span class="hljs-comment">// Prints &quot;default_value&quot;</span>
        } <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) {
            System.out.println(<span class="hljs-string">&quot;Unexpected error: &quot;</span> + e.getMessage());
        }

        <span class="hljs-comment">// Using handle for both success and failure</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; {
            <span class="hljs-comment">// This might succeed or fail</span>
            <span class="hljs-keyword">if</span> (Math.random() &gt; <span class="hljs-number">0.5</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Success!&quot;</span>;
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Failed!&quot;</span>);
            }
        }).handle((value, throwable) -&gt; {
            <span class="hljs-keyword">if</span> (throwable != <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Error: &quot;</span> + throwable.getMessage();
            }
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Success: &quot;</span> + value;
        });

        System.out.println(result2.join());
    }
}
</code></pre><h3>Timeouts</h3>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeoutHandling</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
        <span class="hljs-type">var</span> <span class="hljs-variable">slowTask</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; {
            delay(<span class="hljs-number">6</span>); <span class="hljs-comment">// 6 seconds</span>
            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;slow result&quot;</span>;
        });

        <span class="hljs-comment">// This will throw TimeoutException</span>
        <span class="hljs-comment">// slowTask.orTimeout(2, TimeUnit.SECONDS).join();</span>

        <span class="hljs-comment">// Better: provide default value on timeout</span>
        <span class="hljs-type">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> slowTask.completeOnTimeout(<span class="hljs-string">&quot;timeout_value&quot;</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);
        System.out.println(result.join()); <span class="hljs-comment">// Prints &quot;timeout_value&quot;</span>
    }
}
</code></pre><h2>Advanced Patterns</h2>
<h3>Custom Thread Pools</h3>
<pre><code class="hljs language-java"><span class="hljs-comment">// CompletableFuture uses ForkJoinPool.commonPool() by default</span>
<span class="hljs-comment">// You can provide custom executor:</span>
<span class="hljs-type">var</span> <span class="hljs-variable">customPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);
<span class="hljs-type">var</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;result&quot;</span>, customPool);
</code></pre><h3>Async Method Composition</h3>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">processUser</span><span class="hljs-params">(String userId)</span> {
    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; userId)
        .thenCompose(<span class="hljs-built_in">this</span>::fetchUser)           <span class="hljs-comment">// CompletableFuture&lt;User&gt;</span>
        .thenCompose(<span class="hljs-built_in">this</span>::enrichUserProfile)   <span class="hljs-comment">// CompletableFuture&lt;User&gt;</span>
        .thenApply(User::getName);              <span class="hljs-comment">// CompletableFuture&lt;String&gt;</span>
}

<span class="hljs-keyword">private</span> CompletableFuture&lt;User&gt; <span class="hljs-title function_">fetchUser</span><span class="hljs-params">(String id)</span> {
    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; {
        <span class="hljs-comment">// Simulate database call</span>
        delay();
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(id);
    });
}

<span class="hljs-keyword">private</span> CompletableFuture&lt;User&gt; <span class="hljs-title function_">enrichUserProfile</span><span class="hljs-params">(User user)</span> {
    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; {
        <span class="hljs-comment">// Simulate external API call</span>
        delay();
        user.setProfile(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Profile</span>());
        <span class="hljs-keyword">return</span> user;
    });
}
</code></pre><h2>Best Practices</h2>
<h3>1. Resource Management</h3>
<pre><code class="hljs language-java"><span class="hljs-comment">// Always shutdown executors</span>
<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);
<span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// Use executor</span>
} <span class="hljs-keyword">finally</span> {
    executor.shutdown();
}

<span class="hljs-comment">// Or use try-with-resources (but remember it blocks!)</span>
<span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>)) {
    <span class="hljs-comment">// Use executor</span>
} <span class="hljs-comment">// Automatically shuts down and waits</span>
</code></pre><h3>2. Exception Handling</h3>
<pre><code class="hljs language-java"><span class="hljs-comment">// Always handle exceptions in async chains</span>
CompletableFuture.supplyAsync(() -&gt; riskyOperation())
    .exceptionally(throwable -&gt; {
        log.error(<span class="hljs-string">&quot;Operation failed&quot;</span>, throwable);
        <span class="hljs-keyword">return</span> defaultValue;
    })
    .thenAccept(<span class="hljs-built_in">this</span>::processResult);
</code></pre><h3>3. Avoid Blocking in Async Code</h3>
<pre><code class="hljs language-java"><span class="hljs-comment">// BAD: Blocking in async context</span>
CompletableFuture.runAsync(() -&gt; {
    <span class="hljs-type">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> anotherFuture.join(); <span class="hljs-comment">// Blocking!</span>
    process(result);
});

<span class="hljs-comment">// GOOD: Chain properly</span>
CompletableFuture.runAsync(() -&gt; setupWork())
    .thenCompose(x -&gt; anotherFuture)  <span class="hljs-comment">// Non-blocking composition</span>
    .thenAccept(<span class="hljs-built_in">this</span>::process);
</code></pre><h3>4. Memory and Context Management</h3>
<pre><code class="hljs language-java"><span class="hljs-comment">// Be careful with shared state in lambdas</span>
<span class="hljs-comment">// Prefer passing data through the pipeline rather than capturing</span>
</code></pre><h3>5. Testing Async Code</h3>
<pre><code class="hljs language-java"><span class="hljs-meta">@Test</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAsync</span><span class="hljs-params">()</span> {
    <span class="hljs-type">var</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> myAsyncMethod();

    <span class="hljs-comment">// Don&#x27;t forget to wait in tests!</span>
    <span class="hljs-type">var</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join();
    assertEquals(<span class="hljs-string">&quot;expected&quot;</span>, result);
}
</code></pre><h2>Summary</h2>
<p>CompletableFuture provide powerful tools for asynchronous programming:</p>
<ol>
<li><strong>Future/Callable</strong> interfaces allow returning values from background tasks</li>
<li><strong>CompletableFuture</strong> enables modern, composable asynchronous programming</li>
<li><strong>Proper error handling</strong> and <strong>resource management</strong> are crucial</li>
<li><strong>Understanding the difference</strong> between blocking and non-blocking operations is key</li>
</ol>
<h3>Key Takeaways</h3>
<ul>
<li>Use CompletableFuture for new async code</li>
<li>Chain operations with <code>thenApply</code>, <code>thenCompose</code>, <code>thenCombine</code></li>
<li>Handle errors with <code>exceptionally</code> or <code>handle</code></li>
<li>Always consider resource cleanup</li>
<li>Test your async code properly</li>
</ul>
<h3>get() vs join()</h3>
<ul>
<li><code>get()</code>: Throws checked exceptions (<code>InterruptedException</code>, <code>ExecutionException</code>)</li>
<li><code>join()</code>: Throws unchecked <code>CompletionException</code>, more convenient for most use cases</li>
</ul>
</div><div class="lesson-links"><a href="/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Threads and concurrent Programming" class="prev">← Previous</a><a href="/complete-intro-to-spring-and-springBoot/lessons/Introduction/intro" class="next">Next →</a></div></div><div class="details-bg"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="154" height="154" viewBox="0 0 154 154"><defs><clipPath id="clip-path"><rect id="Rectangle_2238" data-name="Rectangle 2238" width="154" height="154" transform="translate(9467 350)" fill="#fff" stroke="#707070" stroke-width="1"></rect></clipPath><clipPath id="clip-corner-image-active"><rect width="154" height="154"></rect></clipPath></defs><g id="corner-image-active" clip-path="url(#clip-corner-image-active)"><g id="Corner-image-active-2" data-name="Corner-image-active" transform="translate(-9467 -350)" clip-path="url(#clip-path)"><path id="Subtraction_34" data-name="Subtraction 34" d="M-3857.365,1740.766h0l-7.07-7.07,12.89-12.89v14.142l-5.818,5.818Zm-14.142-14.142h0l-7.071-7.07,27.033-27.033v14.143l-19.96,19.96Zm-14.143-14.143h0l-7.07-7.069,41.175-41.175v14.142Zm-14.142-14.142h0l-7.07-7.069,55.317-55.317v14.142Zm-14.142-14.142h0l-7.07-7.069,69.459-69.459v14.142Zm-14.142-14.142h0l-7.07-7.069,76.739-76.739h6.862v7.28Zm-14.143-14.143h0l-7.07-7.069,62.6-62.6h14.142Zm-14.142-14.142h0l-7.07-7.069,48.454-48.454h14.142Zm-14.142-14.142h0l-7.07-7.069,34.312-34.312h14.142Zm-14.142-14.142h0l-7.07-7.069,20.17-20.17h14.142Zm-14.142-14.142h0l-7.071-7.071,6.027-6.027h14.144l-13.1,13.1Zm367.24-56.114v-.909l.455.455-.453.453Z" transform="translate(13472.546 -1236.766)" fill="var(--corner-fill)"></path></g></g></svg></div></div></div></div><footer class="footer"><ul class="socials"><li class="social"><a href="https://twitter.com/asolyma2"><svg fill="none" height="100%" width="32" xmlns="http://www.w3.org/2000/svg" viewBox="0.254 0.25 500 451.95400000000006"><path d="M394.033.25h76.67L303.202 191.693l197.052 260.511h-154.29L225.118 294.205 86.844 452.204H10.127l179.16-204.77L.254.25H158.46l109.234 144.417zm-26.908 406.063h42.483L135.377 43.73h-45.59z" fill="var(--footer-icons)"></path></svg></a></li><li class="social"><a href="https://bsky.app/profile/thisisamr.bsky.social"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -3.268 64 68.414" width="38" height="100%"><path fill="var(--footer-icons)" d="M13.873 3.805C21.21 9.332 29.103 20.537 32 26.55v15.882c0-.338-.13.044-.41.867-1.512 4.456-7.418 21.847-20.923 7.944-7.111-7.32-3.819-14.64 9.125-16.85-7.405 1.264-15.73-.825-18.014-9.015C1.12 23.022 0 8.51 0 6.55 0-3.268 8.579-.182 13.873 3.805zm36.254 0C42.79 9.332 34.897 20.537 32 26.55v15.882c0-.338.13.044.41.867 1.512 4.456 7.418 21.847 20.923 7.944 7.111-7.32 3.819-14.64-9.125-16.85 7.405 1.264 15.73-.825 18.014-9.015C62.88 23.022 64 8.51 64 6.55c0-9.818-8.578-6.732-13.873-2.745z"></path></svg></a></li><li class="social"><a href="https://github.com/thisisamr"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-github-social"><rect width="32" height="32"></rect></clipPath></defs><g id="github-social" clip-path="url(#clip-github-social)"><g id="Group_272" data-name="Group 272" transform="translate(13522.5 -6994)"><path id="Subtraction_33" data-name="Subtraction 33" d="M-24967.5,8041a15.9,15.9,0,0,1-11.312-4.688A15.893,15.893,0,0,1-24983.5,8025a15.893,15.893,0,0,1,4.689-11.315A15.894,15.894,0,0,1-24967.5,8009a15.894,15.894,0,0,1,11.313,4.686A15.893,15.893,0,0,1-24951.5,8025a15.893,15.893,0,0,1-4.689,11.313A15.9,15.9,0,0,1-24967.5,8041Zm-3.781-4.571h0v3.918h7.895v-6.665a1.836,1.836,0,0,0-1.2-1.718c5.1-.617,7.467-2.975,7.467-7.424a7.176,7.176,0,0,0-1.637-4.728,6.74,6.74,0,0,0,.275-1.812,4.34,4.34,0,0,0-.52-2.452.574.574,0,0,0-.359-.1c-1.061,0-3.465,1.411-3.936,1.694a16.644,16.644,0,0,0-4.2-.489,16.379,16.379,0,0,0-3.969.445c-.846-.5-2.91-1.649-3.859-1.649a.566.566,0,0,0-.354.095,4.3,4.3,0,0,0-.521,2.452,6.7,6.7,0,0,0,.244,1.718,7.346,7.346,0,0,0-1.6,4.822,7.263,7.263,0,0,0,1.533,4.985c1.193,1.359,3.115,2.165,5.871,2.464a1.826,1.826,0,0,0-1.129,1.693v.5h0l-.006,0a7.121,7.121,0,0,1-2.033.363,2.608,2.608,0,0,1-.965-.158,4.438,4.438,0,0,1-1.836-1.881,2.361,2.361,0,0,0-1.248-1.091,3.472,3.472,0,0,0-1.217-.3.584.584,0,0,0-.545.224.282.282,0,0,0,.027.367,1.875,1.875,0,0,0,.447.307,4.732,4.732,0,0,1,.561.355,10.726,10.726,0,0,1,1.682,2.755c.043.092.078.163.105.217a3.876,3.876,0,0,0,2.42,1.185,6.036,6.036,0,0,0,.607.025c.875,0,1.988-.124,2-.125Z" transform="translate(11461 -1015)" fill="var(--footer-icons)"></path><g id="Ellipse_670" data-name="Ellipse 670" transform="translate(-13522.5 6994)" fill="none" stroke="var(--footer-icons)" stroke-width="1"><circle cx="16" cy="16" r="16" stroke="none"></circle><circle cx="16" cy="16" r="15.5" fill="none"></circle></g></g></g></svg></a></li><li class="social"><a href="https://linkedin.com/in/thisisamr"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="32" height="32" viewBox="0 0 32 32"><defs><clipPath id="clip-linkedin-social"><rect width="32" height="32"></rect></clipPath></defs><g id="linkedin-social" clip-path="url(#clip-linkedin-social)"><g id="Group_270" data-name="Group 270" transform="translate(-86.349 -633.073)"><path id="Path_375" data-name="Path 375" d="M115.789,633.073a2.324,2.324,0,0,1,1.682.676,2.194,2.194,0,0,1,.695,1.627V662.8a2.131,2.131,0,0,1-.695,1.609,2.314,2.314,0,0,1-1.646.659H88.69a2.307,2.307,0,0,1-1.646-.659,2.128,2.128,0,0,1-.695-1.609V635.376a2.19,2.19,0,0,1,.695-1.627,2.322,2.322,0,0,1,1.682-.676h27.063Zm-20.224,9.672a2.561,2.561,0,0,0,0-3.584,2.658,2.658,0,0,0-1.938-.712,2.724,2.724,0,0,0-1.957.712,2.371,2.371,0,0,0-.75,1.792,2.4,2.4,0,0,0,.731,1.792,2.605,2.605,0,0,0,1.9.713h.037A2.7,2.7,0,0,0,95.565,642.745ZM96,645.434H91.213V659.88H96Zm17.3,6.144a7.007,7.007,0,0,0-1.573-4.9,5.68,5.68,0,0,0-6.839-.769,5.663,5.663,0,0,0-1.426,1.573v-2.048H98.674q.036.841,0,7.717v6.728h4.791V651.8a3.592,3.592,0,0,1,.146-1.17,2.913,2.913,0,0,1,.878-1.206,2.429,2.429,0,0,1,1.609-.549,2.108,2.108,0,0,1,1.865.914,4.265,4.265,0,0,1,.549,2.341v7.752H113.3Z" fill="var(--footer-icons)"></path></g></g></svg></a></li><li class="social"><div class="terms"><p>Content Licensed Under CC-BY-NC-4.0</p><p>Code Samples and Exercises Licensed Under Apache 2.0</p><p>inspired by Btholt Course starter kit<!-- --> <a href="https://github.com/btholt/next-course-starter">Brian Holt</a></p></div></li></ul><div class="theme-icons"><button aria-label="Activate dark mode" title="Activate dark mode" class="theme-toggle"><svg xmlns="http://www.w3.org/2000/svg" width="36px" height="100%" viewBox="0 -960 960 960" fill="var(--text-footer)" role="img"><title>Dark Mode Icon</title><path d="M480-120q-150 0-255-105T120-480q0-150 105-255t255-105q14 0 27.5 1t26.5 3q-41 29-65.5 75.5T444-660q0 90 63 153t153 63q55 0 101-24.5t75-65.5q2 13 3 26.5t1 27.5q0 150-105 255T480-120Zm0-80q88 0 158-48.5T740-375q-20 5-40 8t-40 3q-123 0-209.5-86.5T364-660q0-20 3-40t8-40q-78 32-126.5 102T200-480q0 116 82 198t198 82Z"></path></svg></button></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"attributes":{},"html":"\u003ch1\u003eAsync Java\u003c/h1\u003e\n\u003cp\u003eAsynchronous programming is a style of writing code where a long-running operation\nis started, and the main program continues its work \u003cstrong\u003ewithout waiting\u003c/strong\u003e\nfor that operation to finish. In Java, this is often managed using the \u003ccode\u003eFuture\u003c/code\u003e interface.\u003c/p\u003e\n\u003ch2\u003eThe \u003ccode\u003eFuture\u003c/code\u003e Interface: A Placeholder for Results\u003c/h2\u003e\n\u003cp\u003eThe \u003cstrong\u003e\u003ccode\u003eFuture\u0026lt;T\u0026gt;\u003c/code\u003e\u003c/strong\u003e interface is a core component of Java\u0026#39;s concurrency utilities.\nIt represents the \u003cstrong\u003eresult of an asynchronous computation\u003c/strong\u003e that may not have completed yet.\nWhen you start a task on a background thread (e.g., using an \u003ccode\u003eExecutorService\u003c/code\u003e), the method returns a \u003ccode\u003eFuture\u003c/code\u003e object immediately. This object is essentially a \u003cstrong\u003eplaceholder\u003c/strong\u003e for the eventual result (of type \u003ccode\u003eT\u003c/code\u003e).\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003eHow to Get a Future\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003eYou typically obtain a \u003ccode\u003eFuture\u003c/code\u003e by submitting a task (a \u003ccode\u003eCallable\u003c/code\u003e) to an \u003ccode\u003eExecutorService\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e java.util.concurrent.*;\n\n\u003cspan class=\"hljs-comment\"\u003e// 1. Create a service to run background threads\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003eExecutorService\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eexecutor\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Executors.newSingleThreadExecutor();\n\n\u003cspan class=\"hljs-comment\"\u003e// 2. Submit a long-running task that returns a value (Callable)\u003c/span\u003e\nFuture\u0026lt;Integer\u0026gt; futureResult = executor.submit(() -\u0026gt; {\n    System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;...Starting background task (simulating 3 seconds)...\u0026quot;\u003c/span\u003e);\n    Thread.sleep(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// The final result\u003c/span\u003e\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// The main thread continues running immediately.\u003c/span\u003e\nSystem.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Main thread is not blocked yet, doing other work...\u0026quot;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eFuture Interface Methods\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"left\"\u003eMethod\u003c/th\u003e\n\u003cth align=\"left\"\u003ePurpose\u003c/th\u003e\n\u003cth align=\"left\"\u003eKey Behavior and Limitation\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003e\u003ccode\u003eget()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eRetrieves the result.\u003c/td\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eBLOCKS\u003c/strong\u003e the calling thread indefinitely until the result is available or an exception is thrown. \u003cstrong\u003eThis is usually what asynchronous code tries to avoid.\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003e\u003ccode\u003eget(timeout, unit)\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eRetrieves the result with a time limit.\u003c/td\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eBLOCKS\u003c/strong\u003e the calling thread. Throws a \u003ccode\u003eTimeoutException\u003c/code\u003e if the result isn\u0026#39;t ready in time.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003e\u003ccode\u003eisDone()\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eCheck if task completed.\u003c/td\u003e\n\u003ctd align=\"left\"\u003eReturns \u003ccode\u003etrue\u003c/code\u003e if the task has finished, whether normally, by cancellation, or with an error.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003e\u003ccode\u003ecancel(mayInterrupt)\u003c/code\u003e\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eAttempt to cancel the task.\u003c/td\u003e\n\u003ctd align=\"left\"\u003eAttempts to stop the running task. Returns \u003ccode\u003etrue\u003c/code\u003e if the cancellation was successful.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eThe main limitation of the original \u003ccode\u003eFuture\u003c/code\u003e is that retrieving the result via \u003ccode\u003eget()\u003c/code\u003e requires the calling thread to stop and wait. For modern, non-blocking asynchronous programming, Java developers prefer the\u003c/em\u003e\u003c/strong\u003e \u003cstrong\u003e\u003ccode\u003eCompletableFuture\u003c/code\u003e\u003c/strong\u003e \u003cstrong\u003e\u003cem\u003eclass (introduced in Java 8), which allows you to chain tasks and react to completion without blocking.\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003chr\u003e\n\u003ch2\u003eUnderstanding Concurrency vs. Parallelism vs. Asynchronous\u003c/h2\u003e\n\u003cp\u003eThese three terms are often confused. Here’s how they differ:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"left\"\u003eTerm\u003c/th\u003e\n\u003cth align=\"left\"\u003eMeaning\u003c/th\u003e\n\u003cth align=\"left\"\u003eRequires Multiple Cores?\u003c/th\u003e\n\u003cth align=\"left\"\u003ePractical Analogy\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eConcurrent\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eMany tasks making \u003cstrong\u003eprogress\u003c/strong\u003e over overlapping time periods by rapidly switching between them.\u003c/td\u003e\n\u003ctd align=\"left\"\u003e❌ Not necessarily (can run on one core)\u003c/td\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eOne Chef\u003c/strong\u003e juggling three orders: they chop for a minute, stir for a minute, then check the oven. All tasks are \u003cem\u003eprogressing\u003c/em\u003e over time.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eParallel\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eTasks running \u003cstrong\u003eliterally at the same instant\u003c/strong\u003e (simultaneously) on different CPU cores.\u003c/td\u003e\n\u003ctd align=\"left\"\u003e✅ Yes\u003c/td\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eThree Chefs\u003c/strong\u003e working on three different orders \u003cstrong\u003eat the exact same time\u003c/strong\u003e on three different stations.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003eAsynchronous\u003c/strong\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eA \u003cstrong\u003eprogramming style\u003c/strong\u003e where the caller initiates a task and continues its own work, using a \u003ccode\u003eFuture\u003c/code\u003e or callback to handle the result later.\u003c/td\u003e\n\u003ctd align=\"left\"\u003e❌ No (It\u0026#39;s a coding approach)\u003c/td\u003e\n\u003ctd align=\"left\"\u003e\u003cstrong\u003ePlacing a take-out order\u003c/strong\u003e by phone: You hang up and drive to the restaurant. You don\u0026#39;t stay on hold the whole time waiting for the food.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003eFuture Interface Methods\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eget()\u003c/code\u003e: Blocks until result is available (throws checked exceptions)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eget(timeout, unit)\u003c/code\u003e: Blocks with timeout\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eisDone()\u003c/code\u003e: Check if task completed\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecancel(mayInterrupt)\u003c/code\u003e: Attempt to cancel the task\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eUnderstanding Concurrency vs Parallelism vs Asynchronous\u003c/h2\u003e\n\u003ch3\u003eDefinitions\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eTerm\u003c/th\u003e\n\u003cth\u003eMeaning\u003c/th\u003e\n\u003cth\u003eNeeds Multiple Cores?\u003c/th\u003e\n\u003cth\u003eTypical Use\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eParallel\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eTasks run literally at the same time\u003c/td\u003e\n\u003ctd\u003e✅ Yes\u003c/td\u003e\n\u003ctd\u003eCPU-bound work (math, image processing)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eConcurrent\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eMany tasks progressing in overlapping time\u003c/td\u003e\n\u003ctd\u003e❌ Not necessarily\u003c/td\u003e\n\u003ctd\u003eTask scheduling, multitasking\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eAsynchronous\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003eTask runs in background, caller doesn\u0026#39;t wait\u003c/td\u003e\n\u003ctd\u003e❌ No\u003c/td\u003e\n\u003ctd\u003eI/O-bound work (network, DB, files)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003eExamples\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eParallel Processing:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003eIntStream.range(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e)\n    .parallel()\n    .forEach(i -\u0026gt; System.out.println(i + \u003cspan class=\"hljs-string\"\u003e\u0026quot; \u0026quot;\u003c/span\u003e + Thread.currentThread()));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eConcurrent Processing:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-type\"\u003eExecutorService\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epool\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Executors.newFixedThreadPool(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\npool.submit(() -\u0026gt; doWork(\u003cspan class=\"hljs-string\"\u003e\u0026quot;A\u0026quot;\u003c/span\u003e));\npool.submit(() -\u0026gt; doWork(\u003cspan class=\"hljs-string\"\u003e\u0026quot;B\u0026quot;\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// Tasks overlap in time, may or may not run simultaneously\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eAsynchronous Processing:\u003c/strong\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003eCompletableFuture.runAsync(() -\u0026gt; {\n    delay();\n    System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;hello\u0026quot;\u003c/span\u003e);\n});\nSystem.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;I don\u0026#x27;t block!\u0026quot;\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Runs immediately\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eWhat Does \u0026quot;Asynchronous\u0026quot; Really Mean?\u003c/h3\u003e\n\u003cp\u003eAsynchronous programming is about \u003cstrong\u003enon-blocking execution\u003c/strong\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eYou start a task\u003c/li\u003e\n\u003cli\u003eYour thread continues with other work\u003c/li\u003e\n\u003cli\u003eThe task completes later and notifies you (via callback, promise, etc.)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThink of it like ordering coffee:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSynchronous\u003c/strong\u003e: Order coffee → wait → receive coffee → continue\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAsynchronous\u003c/strong\u003e: Order coffee → do other things → get notified when ready\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eCompletableFuture: Modern Asynchronous Programming\u003c/h2\u003e\n\u003ch3\u003eIntroduction\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eCompletableFuture\u003c/code\u003e is Java\u0026#39;s equivalent to JavaScript Promises. It has three states:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePending\u003c/strong\u003e: Task is running\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eResolved\u003c/strong\u003e: Task completed successfully\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRejected\u003c/strong\u003e: Task failed with an exception\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eBasic Usage\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eAsyncExample\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// Fire and forget\u003c/span\u003e\n        show().join(); \u003cspan class=\"hljs-comment\"\u003e// join() blocks until completion\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e// With return value\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003evalue\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e show2().get();\n            System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Returned: \u0026quot;\u003c/span\u003e + value);\n        } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (InterruptedException | ExecutionException e) {\n            \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRuntimeException\u003c/span\u003e(e);\n        }\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// CompletableFuture.runAsync for void tasks\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e CompletableFuture\u0026lt;Void\u0026gt; \u003cspan class=\"hljs-title function_\"\u003eshow\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e CompletableFuture.runAsync(() -\u0026gt; {\n            delay();\n            System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;hello\u0026quot;\u003c/span\u003e);\n        });\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// CompletableFuture.supplyAsync for tasks with return values\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e CompletableFuture\u0026lt;String\u0026gt; \u003cspan class=\"hljs-title function_\"\u003eshow2\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; {\n            delay();\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;hello\u0026quot;\u003c/span\u003e;\n        });\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eBuilding Async APIs\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMailSender\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Synchronous method\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esendMail\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        delay();\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;mail sent !!!!\u0026quot;\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-comment\"\u003e// Asynchronous wrapper\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e CompletableFuture\u0026lt;Void\u0026gt; \u003cspan class=\"hljs-title function_\"\u003esendMailAsync\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e CompletableFuture.runAsync(() -\u0026gt; sendMail());\n    }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Usage\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003emailService\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMailSender\u003c/span\u003e();\n\u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003efuture\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e mailService.sendMailAsync();\nSystem.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;This runs immediately\u0026quot;\u003c/span\u003e);\nfuture.join(); \u003cspan class=\"hljs-comment\"\u003e// Wait for completion\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eChaining Operations\u003c/h2\u003e\n\u003ch3\u003eCompletableFuture Chaining Methods\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eMethod\u003c/th\u003e\n\u003cth\u003eInput Lambda\u003c/th\u003e\n\u003cth\u003eReturns\u003c/th\u003e\n\u003cth\u003eUse Case\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethenApply(fn)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eT -\u0026gt; U\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCompletableFuture\u0026lt;U\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eTransform result (sync)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethenApplyAsync(fn)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eT -\u0026gt; U\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCompletableFuture\u0026lt;U\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eTransform result (async)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethenAccept(consumer)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eT -\u0026gt; void\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCompletableFuture\u0026lt;Void\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eConsume result, no return\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethenAcceptAsync(consumer)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eT -\u0026gt; void\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCompletableFuture\u0026lt;Void\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eConsume result (async)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethenRun(runnable)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e() -\u0026gt; void\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCompletableFuture\u0026lt;Void\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eRun after completion\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003ethenCompose(fn)\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eT -\u0026gt; CompletableFuture\u0026lt;U\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eCompletableFuture\u0026lt;U\u0026gt;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003eChain async operations\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3\u003ePractical Examples\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCompletableFutureChaining\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// Transform and consume\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003efuture\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; \u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e)\n            .thenApplyAsync(v -\u0026gt; v * \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// Transform: 12 -\u0026gt; 24\u003c/span\u003e\n            .thenAcceptAsync(v -\u0026gt; {\n                delay();\n                System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Thread: \u0026quot;\u003c/span\u003e + Thread.currentThread().getName());\n                System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Value: \u0026quot;\u003c/span\u003e + v);\n            });\n\n        future.join();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003ethenApply vs thenCompose\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eKey Difference:\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ethenApply\u003c/code\u003e: Use when your function returns a \u003cstrong\u003eplain value\u003c/strong\u003e (\u003ccode\u003eT -\u0026gt; U\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ethenCompose\u003c/code\u003e: Use when your function returns a \u003cstrong\u003eCompletableFuture\u003c/strong\u003e (\u003ccode\u003eT -\u0026gt; CompletableFuture\u0026lt;U\u0026gt;\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// thenApply - transforms value\u003c/span\u003e\nCompletableFuture.supplyAsync(() -\u0026gt; \u003cspan class=\"hljs-string\"\u003e\u0026quot;User123\u0026quot;\u003c/span\u003e)\n    .thenApply(id -\u0026gt; fetchProfileSync(id)) \u003cspan class=\"hljs-comment\"\u003e// Returns Profile\u003c/span\u003e\n    .thenAccept(System.out::println);\n\n\u003cspan class=\"hljs-comment\"\u003e// thenCompose - chains futures (avoids nesting)\u003c/span\u003e\nCompletableFuture.supplyAsync(() -\u0026gt; \u003cspan class=\"hljs-string\"\u003e\u0026quot;User123\u0026quot;\u003c/span\u003e)\n    .thenCompose(id -\u0026gt; fetchProfileAsync(id)) \u003cspan class=\"hljs-comment\"\u003e// Returns CompletableFuture\u0026lt;Profile\u0026gt;\u003c/span\u003e\n    .thenAccept(System.out::println);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWithout \u003ccode\u003ethenCompose\u003c/code\u003e, you\u0026#39;d get \u003ccode\u003eCompletableFuture\u0026lt;CompletableFuture\u0026lt;Profile\u0026gt;\u0026gt;\u003c/code\u003e (nested futures).\u003c/p\u003e\n\u003ch2\u003eCombining Futures\u003c/h2\u003e\n\u003ch3\u003eCombining Two Futures\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eCombiningFutures\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// Get price in USD\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epriceInUSD\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; \u003cspan class=\"hljs-number\"\u003e39\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-comment\"\u003e// Get exchange rate USD -\u0026gt; EGP\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eexchangeRate\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-comment\"\u003e// Combine results\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003efinalPrice\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e priceInUSD.thenCombine(exchangeRate,\n            (price, rate) -\u0026gt; price * rate);\n\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Final price: \u0026quot;\u003c/span\u003e + finalPrice.join());\n\n        \u003cspan class=\"hljs-comment\"\u003e// More complex example with string parsing\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003epriceString\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; \u003cspan class=\"hljs-string\"\u003e\u0026quot;39usd\u0026quot;\u003c/span\u003e);\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003erate\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e);\n\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eresult\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e priceString\n            .thenApply(price -\u0026gt; {\n                \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecleanPrice\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e price.replace(\u003cspan class=\"hljs-string\"\u003e\u0026quot;usd\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026quot;\u003c/span\u003e);\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e Integer.parseInt(cleanPrice);\n            })\n            .thenCombine(rate, (price, exchangeRate) -\u0026gt; price * exchangeRate);\n\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Parsed result: \u0026quot;\u003c/span\u003e + result.join());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eWorking with Multiple Futures\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMultipleFutures\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ef1\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; { delay(); \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; });\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ef2\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; { delay(); \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e; });\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ef3\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; { delay(); \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e; });\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ef4\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; { delay(); \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e; });\n\n        \u003cspan class=\"hljs-comment\"\u003e// Wait for ALL to complete\u003c/span\u003e\n        CompletableFuture.allOf(f1, f2, f3, f4).join();\n        System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;All completed: \u0026quot;\u003c/span\u003e + f1.join());\n\n        \u003cspan class=\"hljs-comment\"\u003e// Wait for ANY to complete (first wins)\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eslow\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; {\n            delay(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e); \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;slow\u0026quot;\u003c/span\u003e;\n        });\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003efast\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; {\n            delay(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e); \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;fast\u0026quot;\u003c/span\u003e;\n        });\n\n        CompletableFuture.anyOf(slow, fast)\n            .thenAccept(System.out::println) \u003cspan class=\"hljs-comment\"\u003e// Prints \u0026quot;fast\u0026quot;\u003c/span\u003e\n            .join();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eError Handling\u003c/h2\u003e\n\u003ch3\u003eException Handling Patterns\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eErrorHandling\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// Using exceptionally for error recovery\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003efuture\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; {\n            \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eIllegalStateException\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Something went wrong!\u0026quot;\u003c/span\u003e);\n        });\n\n        \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eresult\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e future.exceptionally(throwable -\u0026gt; {\n                System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Error: \u0026quot;\u003c/span\u003e + throwable.getMessage());\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;default_value\u0026quot;\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// Fallback value\u003c/span\u003e\n            }).get();\n\n            System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Result: \u0026quot;\u003c/span\u003e + result); \u003cspan class=\"hljs-comment\"\u003e// Prints \u0026quot;default_value\u0026quot;\u003c/span\u003e\n        } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (InterruptedException | ExecutionException e) {\n            System.out.println(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Unexpected error: \u0026quot;\u003c/span\u003e + e.getMessage());\n        }\n\n        \u003cspan class=\"hljs-comment\"\u003e// Using handle for both success and failure\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eresult2\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; {\n            \u003cspan class=\"hljs-comment\"\u003e// This might succeed or fail\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (Math.random() \u0026gt; \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e) {\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;Success!\u0026quot;\u003c/span\u003e;\n            } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n                \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRuntimeException\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Failed!\u0026quot;\u003c/span\u003e);\n            }\n        }).handle((value, throwable) -\u0026gt; {\n            \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (throwable != \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e) {\n                \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;Error: \u0026quot;\u003c/span\u003e + throwable.getMessage();\n            }\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;Success: \u0026quot;\u003c/span\u003e + value;\n        });\n\n        System.out.println(result2.join());\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eTimeouts\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTimeoutHandling\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eslowTask\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; {\n            delay(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 6 seconds\u003c/span\u003e\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;slow result\u0026quot;\u003c/span\u003e;\n        });\n\n        \u003cspan class=\"hljs-comment\"\u003e// This will throw TimeoutException\u003c/span\u003e\n        \u003cspan class=\"hljs-comment\"\u003e// slowTask.orTimeout(2, TimeUnit.SECONDS).join();\u003c/span\u003e\n\n        \u003cspan class=\"hljs-comment\"\u003e// Better: provide default value on timeout\u003c/span\u003e\n        \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eresult\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e slowTask.completeOnTimeout(\u003cspan class=\"hljs-string\"\u003e\u0026quot;timeout_value\u0026quot;\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, TimeUnit.SECONDS);\n        System.out.println(result.join()); \u003cspan class=\"hljs-comment\"\u003e// Prints \u0026quot;timeout_value\u0026quot;\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eAdvanced Patterns\u003c/h2\u003e\n\u003ch3\u003eCustom Thread Pools\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// CompletableFuture uses ForkJoinPool.commonPool() by default\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// You can provide custom executor:\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003ecustomPool\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Executors.newFixedThreadPool(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n\u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003efuture\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; \u003cspan class=\"hljs-string\"\u003e\u0026quot;result\u0026quot;\u003c/span\u003e, customPool);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003eAsync Method Composition\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e CompletableFuture\u0026lt;String\u0026gt; \u003cspan class=\"hljs-title function_\"\u003eprocessUser\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String userId)\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; userId)\n        .thenCompose(\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e::fetchUser)           \u003cspan class=\"hljs-comment\"\u003e// CompletableFuture\u0026lt;User\u0026gt;\u003c/span\u003e\n        .thenCompose(\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e::enrichUserProfile)   \u003cspan class=\"hljs-comment\"\u003e// CompletableFuture\u0026lt;User\u0026gt;\u003c/span\u003e\n        .thenApply(User::getName);              \u003cspan class=\"hljs-comment\"\u003e// CompletableFuture\u0026lt;String\u0026gt;\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e CompletableFuture\u0026lt;User\u0026gt; \u003cspan class=\"hljs-title function_\"\u003efetchUser\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String id)\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; {\n        \u003cspan class=\"hljs-comment\"\u003e// Simulate database call\u003c/span\u003e\n        delay();\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eUser\u003c/span\u003e(id);\n    });\n}\n\n\u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e CompletableFuture\u0026lt;User\u0026gt; \u003cspan class=\"hljs-title function_\"\u003eenrichUserProfile\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(User user)\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e CompletableFuture.supplyAsync(() -\u0026gt; {\n        \u003cspan class=\"hljs-comment\"\u003e// Simulate external API call\u003c/span\u003e\n        delay();\n        user.setProfile(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eProfile\u003c/span\u003e());\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e user;\n    });\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eBest Practices\u003c/h2\u003e\n\u003ch3\u003e1. Resource Management\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Always shutdown executors\u003c/span\u003e\n\u003cspan class=\"hljs-type\"\u003eExecutorService\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eexecutor\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Executors.newFixedThreadPool(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Use executor\u003c/span\u003e\n} \u003cspan class=\"hljs-keyword\"\u003efinally\u003c/span\u003e {\n    executor.shutdown();\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// Or use try-with-resources (but remember it blocks!)\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e (\u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eexecutor\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e Executors.newFixedThreadPool(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e)) {\n    \u003cspan class=\"hljs-comment\"\u003e// Use executor\u003c/span\u003e\n} \u003cspan class=\"hljs-comment\"\u003e// Automatically shuts down and waits\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e2. Exception Handling\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Always handle exceptions in async chains\u003c/span\u003e\nCompletableFuture.supplyAsync(() -\u0026gt; riskyOperation())\n    .exceptionally(throwable -\u0026gt; {\n        log.error(\u003cspan class=\"hljs-string\"\u003e\u0026quot;Operation failed\u0026quot;\u003c/span\u003e, throwable);\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e defaultValue;\n    })\n    .thenAccept(\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e::processResult);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e3. Avoid Blocking in Async Code\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// BAD: Blocking in async context\u003c/span\u003e\nCompletableFuture.runAsync(() -\u0026gt; {\n    \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eresult\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e anotherFuture.join(); \u003cspan class=\"hljs-comment\"\u003e// Blocking!\u003c/span\u003e\n    process(result);\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// GOOD: Chain properly\u003c/span\u003e\nCompletableFuture.runAsync(() -\u0026gt; setupWork())\n    .thenCompose(x -\u0026gt; anotherFuture)  \u003cspan class=\"hljs-comment\"\u003e// Non-blocking composition\u003c/span\u003e\n    .thenAccept(\u003cspan class=\"hljs-built_in\"\u003ethis\u003c/span\u003e::process);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e4. Memory and Context Management\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Be careful with shared state in lambdas\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// Prefer passing data through the pipeline rather than capturing\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003ch3\u003e5. Testing Async Code\u003c/h3\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-meta\"\u003e@Test\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etestAsync\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n    \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003efuture\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e myAsyncMethod();\n\n    \u003cspan class=\"hljs-comment\"\u003e// Don\u0026#x27;t forget to wait in tests!\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eresult\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e future.join();\n    assertEquals(\u003cspan class=\"hljs-string\"\u003e\u0026quot;expected\u0026quot;\u003c/span\u003e, result);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2\u003eSummary\u003c/h2\u003e\n\u003cp\u003eCompletableFuture provide powerful tools for asynchronous programming:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eFuture/Callable\u003c/strong\u003e interfaces allow returning values from background tasks\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCompletableFuture\u003c/strong\u003e enables modern, composable asynchronous programming\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eProper error handling\u003c/strong\u003e and \u003cstrong\u003eresource management\u003c/strong\u003e are crucial\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eUnderstanding the difference\u003c/strong\u003e between blocking and non-blocking operations is key\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003eKey Takeaways\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eUse CompletableFuture for new async code\u003c/li\u003e\n\u003cli\u003eChain operations with \u003ccode\u003ethenApply\u003c/code\u003e, \u003ccode\u003ethenCompose\u003c/code\u003e, \u003ccode\u003ethenCombine\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eHandle errors with \u003ccode\u003eexceptionally\u003c/code\u003e or \u003ccode\u003ehandle\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eAlways consider resource cleanup\u003c/li\u003e\n\u003cli\u003eTest your async code properly\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eget() vs join()\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eget()\u003c/code\u003e: Throws checked exceptions (\u003ccode\u003eInterruptedException\u003c/code\u003e, \u003ccode\u003eExecutionException\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ejoin()\u003c/code\u003e: Throws unchecked \u003ccode\u003eCompletionException\u003c/code\u003e, more convenient for most use cases\u003c/li\u003e\n\u003c/ul\u003e\n","markdown":"# Async Java\n\nAsynchronous programming is a style of writing code where a long-running operation\nis started, and the main program continues its work **without waiting**\nfor that operation to finish. In Java, this is often managed using the `Future` interface.\n\n## The `Future` Interface: A Placeholder for Results\n\nThe **`Future\u003cT\u003e`** interface is a core component of Java's concurrency utilities.\nIt represents the **result of an asynchronous computation** that may not have completed yet.\nWhen you start a task on a background thread (e.g., using an `ExecutorService`), the method returns a `Future` object immediately. This object is essentially a **placeholder** for the eventual result (of type `T`).\n\n#### **How to Get a Future**\n\nYou typically obtain a `Future` by submitting a task (a `Callable`) to an `ExecutorService`:\n\n```java\nimport java.util.concurrent.*;\n\n// 1. Create a service to run background threads\nExecutorService executor = Executors.newSingleThreadExecutor();\n\n// 2. Submit a long-running task that returns a value (Callable)\nFuture\u003cInteger\u003e futureResult = executor.submit(() -\u003e {\n    System.out.println(\"...Starting background task (simulating 3 seconds)...\");\n    Thread.sleep(3000);\n    return 42; // The final result\n});\n\n// The main thread continues running immediately.\nSystem.out.println(\"Main thread is not blocked yet, doing other work...\");\n```\n\n### Future Interface Methods\n\n| Method                     | Purpose                                 | Key Behavior and Limitation                                                                                                                                    |\n| :------------------------- | :-------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **`get()`**                | Retrieves the result.                   | **BLOCKS** the calling thread indefinitely until the result is available or an exception is thrown. **This is usually what asynchronous code tries to avoid.** |\n| **`get(timeout, unit)`**   | Retrieves the result with a time limit. | **BLOCKS** the calling thread. Throws a `TimeoutException` if the result isn't ready in time.                                                                  |\n| **`isDone()`**             | Check if task completed.                | Returns `true` if the task has finished, whether normally, by cancellation, or with an error.                                                                  |\n| **`cancel(mayInterrupt)`** | Attempt to cancel the task.             | Attempts to stop the running task. Returns `true` if the cancellation was successful.                                                                          |\n\n**_The main limitation of the original `Future` is that retrieving the result via `get()` requires the calling thread to stop and wait. For modern, non-blocking asynchronous programming, Java developers prefer the_** **`CompletableFuture`** **_class (introduced in Java 8), which allows you to chain tasks and react to completion without blocking._**\n\n---\n\n## Understanding Concurrency vs. Parallelism vs. Asynchronous\n\nThese three terms are often confused. Here’s how they differ:\n\n| Term             | Meaning                                                                                                                                        | Requires Multiple Cores?                 | Practical Analogy                                                                                                                           |\n| :--------------- | :--------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ |\n| **Concurrent**   | Many tasks making **progress** over overlapping time periods by rapidly switching between them.                                                | ❌ Not necessarily (can run on one core) | **One Chef** juggling three orders: they chop for a minute, stir for a minute, then check the oven. All tasks are _progressing_ over time.  |\n| **Parallel**     | Tasks running **literally at the same instant** (simultaneously) on different CPU cores.                                                       | ✅ Yes                                   | **Three Chefs** working on three different orders **at the exact same time** on three different stations.                                   |\n| **Asynchronous** | A **programming style** where the caller initiates a task and continues its own work, using a `Future` or callback to handle the result later. | ❌ No (It's a coding approach)           | **Placing a take-out order** by phone: You hang up and drive to the restaurant. You don't stay on hold the whole time waiting for the food. |\n\n### Future Interface Methods\n\n- `get()`: Blocks until result is available (throws checked exceptions)\n- `get(timeout, unit)`: Blocks with timeout\n- `isDone()`: Check if task completed\n- `cancel(mayInterrupt)`: Attempt to cancel the task\n\n## Understanding Concurrency vs Parallelism vs Asynchronous\n\n### Definitions\n\n| Term             | Meaning                                      | Needs Multiple Cores? | Typical Use                             |\n| ---------------- | -------------------------------------------- | --------------------- | --------------------------------------- |\n| **Parallel**     | Tasks run literally at the same time         | ✅ Yes                | CPU-bound work (math, image processing) |\n| **Concurrent**   | Many tasks progressing in overlapping time   | ❌ Not necessarily    | Task scheduling, multitasking           |\n| **Asynchronous** | Task runs in background, caller doesn't wait | ❌ No                 | I/O-bound work (network, DB, files)     |\n\n### Examples\n\n**Parallel Processing:**\n\n```java\nIntStream.range(0, 10)\n    .parallel()\n    .forEach(i -\u003e System.out.println(i + \" \" + Thread.currentThread()));\n```\n\n**Concurrent Processing:**\n\n```java\nExecutorService pool = Executors.newFixedThreadPool(2);\npool.submit(() -\u003e doWork(\"A\"));\npool.submit(() -\u003e doWork(\"B\"));\n// Tasks overlap in time, may or may not run simultaneously\n```\n\n**Asynchronous Processing:**\n\n```java\nCompletableFuture.runAsync(() -\u003e {\n    delay();\n    System.out.println(\"hello\");\n});\nSystem.out.println(\"I don't block!\"); // Runs immediately\n```\n\n### What Does \"Asynchronous\" Really Mean?\n\nAsynchronous programming is about **non-blocking execution**:\n\n- You start a task\n- Your thread continues with other work\n- The task completes later and notifies you (via callback, promise, etc.)\n\nThink of it like ordering coffee:\n\n- **Synchronous**: Order coffee → wait → receive coffee → continue\n- **Asynchronous**: Order coffee → do other things → get notified when ready\n\n## CompletableFuture: Modern Asynchronous Programming\n\n### Introduction\n\n`CompletableFuture` is Java's equivalent to JavaScript Promises. It has three states:\n\n- **Pending**: Task is running\n- **Resolved**: Task completed successfully\n- **Rejected**: Task failed with an exception\n\n### Basic Usage\n\n```java\npublic class AsyncExample {\n    public static void main(String[] args) {\n        // Fire and forget\n        show().join(); // join() blocks until completion\n\n        // With return value\n        try {\n            String value = show2().get();\n            System.out.println(\"Returned: \" + value);\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // CompletableFuture.runAsync for void tasks\n    public static CompletableFuture\u003cVoid\u003e show() {\n        return CompletableFuture.runAsync(() -\u003e {\n            delay();\n            System.out.println(\"hello\");\n        });\n    }\n\n    // CompletableFuture.supplyAsync for tasks with return values\n    public static CompletableFuture\u003cString\u003e show2() {\n        return CompletableFuture.supplyAsync(() -\u003e {\n            delay();\n            return \"hello\";\n        });\n    }\n}\n```\n\n### Building Async APIs\n\n```java\nclass MailSender {\n    // Synchronous method\n    public void sendMail() {\n        delay();\n        System.out.println(\"mail sent !!!!\");\n    }\n\n    // Asynchronous wrapper\n    public CompletableFuture\u003cVoid\u003e sendMailAsync() {\n        return CompletableFuture.runAsync(() -\u003e sendMail());\n    }\n}\n\n// Usage\nvar mailService = new MailSender();\nvar future = mailService.sendMailAsync();\nSystem.out.println(\"This runs immediately\");\nfuture.join(); // Wait for completion\n```\n\n## Chaining Operations\n\n### CompletableFuture Chaining Methods\n\n| Method                      | Input Lambda                | Returns                   | Use Case                  |\n| --------------------------- | --------------------------- | ------------------------- | ------------------------- |\n| `thenApply(fn)`             | `T -\u003e U`                    | `CompletableFuture\u003cU\u003e`    | Transform result (sync)   |\n| `thenApplyAsync(fn)`        | `T -\u003e U`                    | `CompletableFuture\u003cU\u003e`    | Transform result (async)  |\n| `thenAccept(consumer)`      | `T -\u003e void`                 | `CompletableFuture\u003cVoid\u003e` | Consume result, no return |\n| `thenAcceptAsync(consumer)` | `T -\u003e void`                 | `CompletableFuture\u003cVoid\u003e` | Consume result (async)    |\n| `thenRun(runnable)`         | `() -\u003e void`                | `CompletableFuture\u003cVoid\u003e` | Run after completion      |\n| `thenCompose(fn)`           | `T -\u003e CompletableFuture\u003cU\u003e` | `CompletableFuture\u003cU\u003e`    | Chain async operations    |\n\n### Practical Examples\n\n```java\npublic class CompletableFutureChaining {\n    public static void main(String[] args) {\n        // Transform and consume\n        var future = CompletableFuture.supplyAsync(() -\u003e 12)\n            .thenApplyAsync(v -\u003e v * 2) // Transform: 12 -\u003e 24\n            .thenAcceptAsync(v -\u003e {\n                delay();\n                System.out.println(\"Thread: \" + Thread.currentThread().getName());\n                System.out.println(\"Value: \" + v);\n            });\n\n        future.join();\n    }\n}\n```\n\n### thenApply vs thenCompose\n\n**Key Difference:**\n\n- `thenApply`: Use when your function returns a **plain value** (`T -\u003e U`)\n- `thenCompose`: Use when your function returns a **CompletableFuture** (`T -\u003e CompletableFuture\u003cU\u003e`)\n\n```java\n// thenApply - transforms value\nCompletableFuture.supplyAsync(() -\u003e \"User123\")\n    .thenApply(id -\u003e fetchProfileSync(id)) // Returns Profile\n    .thenAccept(System.out::println);\n\n// thenCompose - chains futures (avoids nesting)\nCompletableFuture.supplyAsync(() -\u003e \"User123\")\n    .thenCompose(id -\u003e fetchProfileAsync(id)) // Returns CompletableFuture\u003cProfile\u003e\n    .thenAccept(System.out::println);\n```\n\nWithout `thenCompose`, you'd get `CompletableFuture\u003cCompletableFuture\u003cProfile\u003e\u003e` (nested futures).\n\n## Combining Futures\n\n### Combining Two Futures\n\n```java\npublic class CombiningFutures {\n    public static void main(String[] args) {\n        // Get price in USD\n        var priceInUSD = CompletableFuture.supplyAsync(() -\u003e 39);\n\n        // Get exchange rate USD -\u003e EGP\n        var exchangeRate = CompletableFuture.supplyAsync(() -\u003e 50);\n\n        // Combine results\n        var finalPrice = priceInUSD.thenCombine(exchangeRate,\n            (price, rate) -\u003e price * rate);\n\n        System.out.println(\"Final price: \" + finalPrice.join());\n\n        // More complex example with string parsing\n        var priceString = CompletableFuture.supplyAsync(() -\u003e \"39usd\");\n        var rate = CompletableFuture.supplyAsync(() -\u003e 50);\n\n        var result = priceString\n            .thenApply(price -\u003e {\n                var cleanPrice = price.replace(\"usd\", \"\");\n                return Integer.parseInt(cleanPrice);\n            })\n            .thenCombine(rate, (price, exchangeRate) -\u003e price * exchangeRate);\n\n        System.out.println(\"Parsed result: \" + result.join());\n    }\n}\n```\n\n### Working with Multiple Futures\n\n```java\npublic class MultipleFutures {\n    public static void main(String[] args) {\n        var f1 = CompletableFuture.supplyAsync(() -\u003e { delay(); return 1; });\n        var f2 = CompletableFuture.supplyAsync(() -\u003e { delay(); return 2; });\n        var f3 = CompletableFuture.supplyAsync(() -\u003e { delay(); return 3; });\n        var f4 = CompletableFuture.supplyAsync(() -\u003e { delay(); return 4; });\n\n        // Wait for ALL to complete\n        CompletableFuture.allOf(f1, f2, f3, f4).join();\n        System.out.println(\"All completed: \" + f1.join());\n\n        // Wait for ANY to complete (first wins)\n        var slow = CompletableFuture.supplyAsync(() -\u003e {\n            delay(6); return \"slow\";\n        });\n        var fast = CompletableFuture.supplyAsync(() -\u003e {\n            delay(1); return \"fast\";\n        });\n\n        CompletableFuture.anyOf(slow, fast)\n            .thenAccept(System.out::println) // Prints \"fast\"\n            .join();\n    }\n}\n```\n\n## Error Handling\n\n### Exception Handling Patterns\n\n```java\npublic class ErrorHandling {\n    public static void main(String[] args) {\n        // Using exceptionally for error recovery\n        var future = CompletableFuture.supplyAsync(() -\u003e {\n            throw new IllegalStateException(\"Something went wrong!\");\n        });\n\n        try {\n            var result = future.exceptionally(throwable -\u003e {\n                System.out.println(\"Error: \" + throwable.getMessage());\n                return \"default_value\"; // Fallback value\n            }).get();\n\n            System.out.println(\"Result: \" + result); // Prints \"default_value\"\n        } catch (InterruptedException | ExecutionException e) {\n            System.out.println(\"Unexpected error: \" + e.getMessage());\n        }\n\n        // Using handle for both success and failure\n        var result2 = CompletableFuture.supplyAsync(() -\u003e {\n            // This might succeed or fail\n            if (Math.random() \u003e 0.5) {\n                return \"Success!\";\n            } else {\n                throw new RuntimeException(\"Failed!\");\n            }\n        }).handle((value, throwable) -\u003e {\n            if (throwable != null) {\n                return \"Error: \" + throwable.getMessage();\n            }\n            return \"Success: \" + value;\n        });\n\n        System.out.println(result2.join());\n    }\n}\n```\n\n### Timeouts\n\n```java\npublic class TimeoutHandling {\n    public static void main(String[] args) {\n        var slowTask = CompletableFuture.supplyAsync(() -\u003e {\n            delay(6); // 6 seconds\n            return \"slow result\";\n        });\n\n        // This will throw TimeoutException\n        // slowTask.orTimeout(2, TimeUnit.SECONDS).join();\n\n        // Better: provide default value on timeout\n        var result = slowTask.completeOnTimeout(\"timeout_value\", 1, TimeUnit.SECONDS);\n        System.out.println(result.join()); // Prints \"timeout_value\"\n    }\n}\n```\n\n## Advanced Patterns\n\n### Custom Thread Pools\n\n```java\n// CompletableFuture uses ForkJoinPool.commonPool() by default\n// You can provide custom executor:\nvar customPool = Executors.newFixedThreadPool(4);\nvar future = CompletableFuture.supplyAsync(() -\u003e \"result\", customPool);\n```\n\n### Async Method Composition\n\n```java\npublic CompletableFuture\u003cString\u003e processUser(String userId) {\n    return CompletableFuture.supplyAsync(() -\u003e userId)\n        .thenCompose(this::fetchUser)           // CompletableFuture\u003cUser\u003e\n        .thenCompose(this::enrichUserProfile)   // CompletableFuture\u003cUser\u003e\n        .thenApply(User::getName);              // CompletableFuture\u003cString\u003e\n}\n\nprivate CompletableFuture\u003cUser\u003e fetchUser(String id) {\n    return CompletableFuture.supplyAsync(() -\u003e {\n        // Simulate database call\n        delay();\n        return new User(id);\n    });\n}\n\nprivate CompletableFuture\u003cUser\u003e enrichUserProfile(User user) {\n    return CompletableFuture.supplyAsync(() -\u003e {\n        // Simulate external API call\n        delay();\n        user.setProfile(new Profile());\n        return user;\n    });\n}\n```\n\n## Best Practices\n\n### 1. Resource Management\n\n```java\n// Always shutdown executors\nExecutorService executor = Executors.newFixedThreadPool(4);\ntry {\n    // Use executor\n} finally {\n    executor.shutdown();\n}\n\n// Or use try-with-resources (but remember it blocks!)\ntry (var executor = Executors.newFixedThreadPool(4)) {\n    // Use executor\n} // Automatically shuts down and waits\n```\n\n### 2. Exception Handling\n\n```java\n// Always handle exceptions in async chains\nCompletableFuture.supplyAsync(() -\u003e riskyOperation())\n    .exceptionally(throwable -\u003e {\n        log.error(\"Operation failed\", throwable);\n        return defaultValue;\n    })\n    .thenAccept(this::processResult);\n```\n\n### 3. Avoid Blocking in Async Code\n\n```java\n// BAD: Blocking in async context\nCompletableFuture.runAsync(() -\u003e {\n    var result = anotherFuture.join(); // Blocking!\n    process(result);\n});\n\n// GOOD: Chain properly\nCompletableFuture.runAsync(() -\u003e setupWork())\n    .thenCompose(x -\u003e anotherFuture)  // Non-blocking composition\n    .thenAccept(this::process);\n```\n\n### 4. Memory and Context Management\n\n```java\n// Be careful with shared state in lambdas\n// Prefer passing data through the pipeline rather than capturing\n```\n\n### 5. Testing Async Code\n\n```java\n@Test\npublic void testAsync() {\n    var future = myAsyncMethod();\n\n    // Don't forget to wait in tests!\n    var result = future.join();\n    assertEquals(\"expected\", result);\n}\n```\n\n## Summary\n\nCompletableFuture provide powerful tools for asynchronous programming:\n\n1. **Future/Callable** interfaces allow returning values from background tasks\n2. **CompletableFuture** enables modern, composable asynchronous programming\n3. **Proper error handling** and **resource management** are crucial\n4. **Understanding the difference** between blocking and non-blocking operations is key\n\n### Key Takeaways\n\n- Use CompletableFuture for new async code\n- Chain operations with `thenApply`, `thenCompose`, `thenCombine`\n- Handle errors with `exceptionally` or `handle`\n- Always consider resource cleanup\n- Test your async code properly\n\n### get() vs join()\n\n- `get()`: Throws checked exceptions (`InterruptedException`, `ExecutionException`)\n- `join()`: Throws unchecked `CompletionException`, more convenient for most use cases\n","slug":"Async java","title":"Async Java","section":"A Quick Refresher","icon":"rotate","filePath":"/home/runner/work/complete-intro-to-spring-and-springBoot/complete-intro-to-spring-and-springBoot/lessons/00-A quick Refresher/G-Async java.md","nextSlug":"/complete-intro-to-spring-and-springBoot/lessons/Introduction/intro","prevSlug":"/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Threads and concurrent Programming"}},"__N_SSG":true},"page":"/lessons/[section]/[slug]","query":{"section":"A quick Refresher","slug":"Async java"},"buildId":"xTwxhuCtUf2QTtgk5CpXn","assetPrefix":"/complete-intro-to-spring-and-springBoot","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>