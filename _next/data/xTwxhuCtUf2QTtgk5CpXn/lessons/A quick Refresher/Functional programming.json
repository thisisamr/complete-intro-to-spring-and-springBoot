{"pageProps":{"post":{"attributes":{},"html":"<h1><strong>Functional Interfaces in Java</strong></h1>\n<p>Java 8 introduced <strong>functional programming features</strong> such as lambdas, method references, and the <code>java.util.function</code> package. At the heart of this ecosystem are <strong>functional interfaces</strong>.</p>\n<hr>\n<h2>1Ô∏è‚É£ What is a Functional Interface?</h2>\n<ul>\n<li>A <strong>functional interface</strong> is an interface with exactly <strong>one abstract method</strong>.</li>\n<li>This single method defines the <strong>functional contract</strong>.</li>\n<li>Java provides many built-in functional interfaces in the <code>java.util.function</code> package.</li>\n<li>Examples: <code>Function&lt;T,R&gt;</code>, <code>Consumer&lt;T&gt;</code>, <code>Supplier&lt;T&gt;</code>, <code>Predicate&lt;T&gt;</code>, <code>UnaryOperator&lt;T&gt;</code>, <code>BinaryOperator&lt;T&gt;</code>.</li>\n</ul>\n<p>‚ö° Lambdas and method references can be used wherever a functional interface is expected.</p>\n<hr>\n<h2>2Ô∏è‚É£ <code>Function&lt;T, R&gt;</code> ‚Äì Transforming Data</h2>\n<ul>\n<li>Represents a function that <strong>takes one argument of type <code>T</code> and returns a result of type <code>R</code></strong>.</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> thisisamr;\n\n<span class=\"hljs-keyword\">import</span> java.util.function.Function;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FunctionInterfaceExample</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        Function&lt;String, String&gt; modify = (name) -&gt; name + <span class=\"hljs-string\">&quot; Modified&quot;</span>;\n\n        System.out.println(modify.apply(<span class=\"hljs-string\">&quot;Amr&quot;</span>));  <span class=\"hljs-comment\">// Amr Modified</span>\n\n        <span class=\"hljs-comment\">// Function composition</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> modify\n                .compose((String p) -&gt; p.toLowerCase()) <span class=\"hljs-comment\">// runs first</span>\n                .apply(<span class=\"hljs-string\">&quot;AAAAA&quot;</span>);\n\n        System.out.println(result); <span class=\"hljs-comment\">// aaaaa Modified</span>\n    }\n}\n</code></pre><h3>üìù Key methods</h3>\n<ul>\n<li><code>apply(T t)</code> ‚Üí runs the function.</li>\n<li><code>compose(Function before)</code> ‚Üí run another function <em>before</em>.</li>\n<li><code>andThen(Function after)</code> ‚Üí run another function <em>after</em>.</li>\n</ul>\n<p>So you can build <strong>pipelines</strong> of transformations.</p>\n<hr>\n<h2>3Ô∏è‚É£ <code>Consumer&lt;T&gt;</code> ‚Äì Consuming Data</h2>\n<ul>\n<li>Represents an operation that <strong>takes one argument and returns nothing</strong> (side effects only).</li>\n<li>Typical use: logging, printing, collecting results.</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> thisisamr;\n\n<span class=\"hljs-keyword\">import</span> java.util.List;\n<span class=\"hljs-keyword\">import</span> java.util.function.Consumer;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConsumerInterfaceExample</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        List&lt;Integer&gt; numbers = List.of(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>);\n\n        Consumer&lt;Integer&gt; print = System.out::println;\n\n        <span class=\"hljs-comment\">// Chaining consumers</span>\n        numbers.forEach(print.andThen(i -&gt; System.out.println(i * <span class=\"hljs-number\">2</span>)));\n    }\n}\n</code></pre><hr>\n<h2>4Ô∏è‚É£ <code>Supplier&lt;T&gt;</code> ‚Äì Supplying Values</h2>\n<ul>\n<li>Represents a function that <strong>takes no arguments but returns a value</strong>.</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> thisisamr;\n\n<span class=\"hljs-keyword\">import</span> java.util.function.DoubleSupplier;\n<span class=\"hljs-keyword\">import</span> java.util.function.Supplier;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SupplierInterfaceExample</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        Supplier&lt;Double&gt; randomBoxed = Math::random;\n        <span class=\"hljs-type\">DoubleSupplier</span> <span class=\"hljs-variable\">randomPrimitive</span> <span class=\"hljs-operator\">=</span> Math::random;\n\n        System.out.println(randomBoxed.get());       <span class=\"hljs-comment\">// Double (boxed)</span>\n        System.out.println(randomPrimitive.getAsDouble()); <span class=\"hljs-comment\">// double (primitive)</span>\n    }\n}\n</code></pre><h3>üîë Why <code>DoubleSupplier</code>?</h3>\n<ul>\n<li>To avoid the <strong>overhead of boxing/unboxing</strong>.</li>\n<li><code>Supplier&lt;Double&gt;</code> works with objects (heap allocated).</li>\n<li><code>DoubleSupplier</code> works directly with <code>double</code> (faster, no GC overhead).</li>\n</ul>\n<p>üëâ Boxing/unboxing exists because Java generics only work with objects, unlike modern languages (Rust, Go, C++).</p>\n<hr>\n<h2>5Ô∏è‚É£ <code>Predicate&lt;T&gt;</code> ‚Äì Filtering Data</h2>\n<ul>\n<li>Represents a function that <strong>takes one argument and returns a boolean</strong>.</li>\n<li>Often used for filtering and conditional logic.</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> thisisamr;\n\n<span class=\"hljs-keyword\">import</span> java.util.List;\n<span class=\"hljs-keyword\">import</span> java.util.function.Predicate;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PredicateInterfaceExample</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        List&lt;Integer&gt; numbers = List.of(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">9</span>);\n\n        Predicate&lt;Integer&gt; divisibleBy3 = i -&gt; i % <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>;\n\n        numbers.stream()\n               .filter(divisibleBy3)\n               .forEach(System.out::println); <span class=\"hljs-comment\">// 3, 6, 9</span>\n\n        <span class=\"hljs-comment\">// Combining predicates</span>\n        Predicate&lt;String&gt; hasLeftBrace = str -&gt; str.startsWith(<span class=\"hljs-string\">&quot;{&quot;</span>);\n        Predicate&lt;String&gt; hasRightBrace = str -&gt; str.endsWith(<span class=\"hljs-string\">&quot;}&quot;</span>);\n\n        Predicate&lt;String&gt; both = hasLeftBrace.and(hasRightBrace);\n        Predicate&lt;String&gt; either = hasLeftBrace.or(hasRightBrace);\n        Predicate&lt;String&gt; notLeft = hasLeftBrace.negate();\n\n        System.out.println(both.test(<span class=\"hljs-string\">&quot;{ASD}&quot;</span>));   <span class=\"hljs-comment\">// true</span>\n        System.out.println(either.test(<span class=\"hljs-string\">&quot;{ASD&quot;</span>));  <span class=\"hljs-comment\">// true</span>\n        System.out.println(notLeft.test(<span class=\"hljs-string\">&quot;ASD&quot;</span>));  <span class=\"hljs-comment\">// true</span>\n    }\n}\n</code></pre><hr>\n<h2>6Ô∏è‚É£ <code>UnaryOperator&lt;T&gt;</code> and <code>BinaryOperator&lt;T&gt;</code></h2>\n<ul>\n<li>Both are <strong>specializations of <code>Function</code></strong>:<ul>\n<li><code>UnaryOperator&lt;T&gt;</code> ‚Üí takes one argument and returns the same type.</li>\n<li><code>BinaryOperator&lt;T&gt;</code> ‚Üí takes two arguments of the same type and returns the same type.</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> thisisamr;\n\n<span class=\"hljs-keyword\">import</span> java.util.function.BinaryOperator;\n<span class=\"hljs-keyword\">import</span> java.util.function.Function;\n<span class=\"hljs-keyword\">import</span> java.util.function.UnaryOperator;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OperatorExamples</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        BinaryOperator&lt;Integer&gt; add = Integer::sum;\n        Function&lt;Integer, Integer&gt; square = a -&gt; a * a;\n\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> add.andThen(square).apply(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>);\n        System.out.println(result); <span class=\"hljs-comment\">// (1+3)^2 = 16</span>\n\n        UnaryOperator&lt;Integer&gt; increment = a -&gt; a + <span class=\"hljs-number\">1</span>;\n        UnaryOperator&lt;Integer&gt; squareOp = a -&gt; a * a;\n\n        System.out.println(increment.andThen(squareOp).apply(<span class=\"hljs-number\">1</span>)); <span class=\"hljs-comment\">// (1+1)^2 = 4</span>\n    }\n}\n</code></pre><hr>\n<h2>üîë Summary</h2>\n<ul>\n<li><p><strong>Functional interfaces</strong> allow Java to use <strong>lambdas and method references</strong> elegantly.</p>\n</li>\n<li><p>Core built-in interfaces:</p>\n<ul>\n<li><code>Function&lt;T,R&gt;</code> ‚Üí transforms data.</li>\n<li><code>Consumer&lt;T&gt;</code> ‚Üí consumes data (side effects).</li>\n<li><code>Supplier&lt;T&gt;</code> ‚Üí supplies values.</li>\n<li><code>Predicate&lt;T&gt;</code> ‚Üí tests conditions.</li>\n<li><code>UnaryOperator&lt;T&gt;</code> and <code>BinaryOperator&lt;T&gt;</code> ‚Üí operate on same-type inputs.</li>\n</ul>\n</li>\n<li><p>They can be <strong>chained, composed, and combined</strong>.</p>\n</li>\n<li><p>You‚Äôll use them extensively with <strong>Streams</strong> for mapping, filtering, reducing, and collecting.</p>\n</li>\n</ul>\n<hr>\n<p>üëâ Next step: apply these in <strong>Streams</strong> (map, filter, reduce, collect) ‚Äî that‚Äôs where the real power shows.</p>\n<p>Perfect üëå what you‚Äôve written is already a nice ‚Äúplayground‚Äù for students to see streams in action. Let me turn it into a <strong>structured, refined lecture on Java Streams</strong>, with clearer flow, theory + practical examples.</p>\n<hr>\n<h1>üöÄ <strong>Java Streams ‚Äì A Comprehensive Introduction</strong></h1>\n<hr>\n<h2>1. What are Streams?</h2>\n<p>Streams are one of the most powerful features introduced in Java 8.\nThey allow us to <strong>process data in a declarative, functional style</strong>, instead of writing loops and manual logic.</p>\n<p>Think of a stream as:</p>\n<ul>\n<li>A <strong>pipeline</strong> of data flowing through transformations.</li>\n<li>It doesn‚Äôt <strong>store</strong> data ‚Äì it processes data from a source (collection, array, I/O, or infinite generator).</li>\n</ul>\n<hr>\n<h2>2. Creating Streams</h2>\n<p>You can create streams from multiple sources:</p>\n<h3>From collections:</h3>\n<pre><code class=\"hljs language-java\">List&lt;String&gt; names = List.of(<span class=\"hljs-string\">&quot;Amr&quot;</span>, <span class=\"hljs-string\">&quot;Huda&quot;</span>, <span class=\"hljs-string\">&quot;Salwa&quot;</span>);\nnames.stream().forEach(System.out::println);\n</code></pre><h3>From arrays:</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">int</span>[] nums = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>};\nArrays.stream(nums).forEach(System.out::print);\n</code></pre><h3>From infinite generators:</h3>\n<pre><code class=\"hljs language-java\">Stream.generate(Math::random).limit(<span class=\"hljs-number\">3</span>).forEach(System.out::println);\nStream.iterate(<span class=\"hljs-number\">1</span>, n -&gt; n * <span class=\"hljs-number\">2</span>).limit(<span class=\"hljs-number\">5</span>).forEach(System.out::println);\n</code></pre><hr>\n<h2>3. Intermediate Operations</h2>\n<p>These <strong>transform streams</strong> but don‚Äôt produce a result until a terminal operation is called.</p>\n<p>Some common ones:</p>\n<ul>\n<li><strong><code>filter</code></strong> ‚Üí keep only matching elements</li>\n<li><strong><code>map</code></strong> ‚Üí transform each element</li>\n<li><strong><code>distinct</code></strong> ‚Üí remove duplicates</li>\n<li><strong><code>sorted</code></strong> ‚Üí order elements</li>\n<li><strong><code>limit</code>, <code>skip</code>, <code>takeWhile</code>, <code>dropWhile</code></strong> ‚Üí slicing</li>\n<li><strong><code>peek</code></strong> ‚Üí debugging, view without consuming</li>\n</ul>\n<p>Example:</p>\n<pre><code class=\"hljs language-java\">movies.stream()\n      .filter(m -&gt; m.likes &gt; <span class=\"hljs-number\">20</span>)   <span class=\"hljs-comment\">// keep movies with likes &gt; 20</span>\n      .map(m -&gt; m.title)           <span class=\"hljs-comment\">// transform to titles</span>\n      .distinct()\n      .forEach(System.out::println);\n</code></pre><hr>\n<h2>4. Terminal Operations</h2>\n<p>These <strong>end the stream pipeline</strong> and produce a result (number, collection, boolean, etc.).</p>\n<p>Examples:</p>\n<ul>\n<li><strong>Counting</strong></li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> movies.stream().filter(m -&gt; m.likes &gt; <span class=\"hljs-number\">20</span>).count();\n</code></pre><ul>\n<li><strong>Matching</strong></li>\n</ul>\n<pre><code class=\"hljs language-java\">movies.stream().allMatch(m -&gt; m.likes &gt; <span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// true/false</span>\nmovies.stream().anyMatch(m -&gt; m.genre == Movie.GENRE.ACTION);\n</code></pre><ul>\n<li><strong>Finding</strong></li>\n</ul>\n<pre><code class=\"hljs language-java\">movies.stream().findFirst().ifPresent(System.out::println);\nmovies.stream().findAny().ifPresent(System.out::println);\n</code></pre><ul>\n<li><strong>Reducing</strong></li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">totalLikes</span> <span class=\"hljs-operator\">=</span> movies.stream()\n                       .map(m -&gt; m.likes)\n                       .reduce(Integer::sum)\n                       .orElse(<span class=\"hljs-number\">0</span>);\n</code></pre><hr>\n<h2>5. Collecting Results</h2>\n<p>Streams integrate tightly with the <strong>Collectors</strong> utility class.</p>\n<ul>\n<li><strong>To List/Set</strong></li>\n</ul>\n<pre><code class=\"hljs language-java\">List&lt;String&gt; titles = movies.stream()\n                            .map(m -&gt; m.title)\n                            .toList();\n</code></pre><ul>\n<li><strong>To Set (unique values)</strong></li>\n</ul>\n<pre><code class=\"hljs language-java\">Set&lt;Integer&gt; likes = movies.stream()\n                           .map(m -&gt; m.likes)\n                           .collect(Collectors.toSet());\n</code></pre><ul>\n<li><strong>Summarizing</strong></li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">stats</span> <span class=\"hljs-operator\">=</span> movies.stream()\n                  .collect(Collectors.summarizingInt(m -&gt; m.likes));\nSystem.out.println(stats.getAverage());\n</code></pre><ul>\n<li><strong>Grouping</strong></li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">grouped</span> <span class=\"hljs-operator\">=</span> movies.stream()\n                    .collect(Collectors.groupingBy(m -&gt; m.genre));\n</code></pre><ul>\n<li><strong>Grouping + Mapping</strong></li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">groupedTitles</span> <span class=\"hljs-operator\">=</span> movies.stream()\n    .collect(Collectors.groupingBy(m -&gt; m.genre,\n             Collectors.mapping(m -&gt; m.title, Collectors.joining(<span class=\"hljs-string\">&quot;, &quot;</span>))));\n</code></pre><ul>\n<li><strong>Partitioning</strong></li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">partitioned</span> <span class=\"hljs-operator\">=</span> movies.stream()\n                        .collect(Collectors.partitioningBy(m -&gt; m.likes &gt; <span class=\"hljs-number\">20</span>));\n</code></pre><hr>\n<h2>6. Sorting</h2>\n<p>Streams allow easy sorting:</p>\n<ul>\n<li>With a comparator:</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">sorted</span> <span class=\"hljs-operator\">=</span> movies.stream()\n                   .sorted(Comparator.comparingInt(m -&gt; m.likes))\n                   .toList();\n</code></pre><ul>\n<li>With a custom comparator:</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">sortedDesc</span> <span class=\"hljs-operator\">=</span> movies.stream()\n                       .sorted((m1, m2) -&gt; m2.likes - m1.likes)\n                       .toList();\n</code></pre><hr>\n<h2>7. Primitive Streams</h2>\n<p>When working with primitives, Java provides specialized streams:</p>\n<ul>\n<li><strong><code>IntStream</code></strong></li>\n<li><strong><code>LongStream</code></strong></li>\n<li><strong><code>DoubleStream</code></strong></li>\n</ul>\n<p>Useful methods:</p>\n<pre><code class=\"hljs language-java\">IntStream.range(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>).forEach(System.out::println);      <span class=\"hljs-comment\">// 1..4</span>\nIntStream.rangeClosed(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>).forEach(System.out::println); <span class=\"hljs-comment\">// 1..5</span>\n</code></pre><p>This avoids boxing/unboxing overhead.</p>\n<hr>\n<h2>8. Example Recap with <code>Movie</code> Class</h2>\n<pre><code class=\"hljs language-java\">List&lt;Movie&gt; movies = List.of(\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Movie</span>(<span class=\"hljs-string\">&quot;A&quot;</span>, <span class=\"hljs-number\">12</span>, Movie.GENRE.ACTION),\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Movie</span>(<span class=\"hljs-string\">&quot;B&quot;</span>, <span class=\"hljs-number\">22</span>, Movie.GENRE.ROMANCE),\n    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Movie</span>(<span class=\"hljs-string\">&quot;C&quot;</span>, <span class=\"hljs-number\">32</span>, Movie.GENRE.COMEDY)\n);\n\n<span class=\"hljs-comment\">// Filter + map + collect</span>\nList&lt;String&gt; popularMovies = movies.stream()\n    .filter(m -&gt; m.likes &gt; <span class=\"hljs-number\">20</span>)\n    .map(m -&gt; m.title)\n    .toList();\n\nSystem.out.println(popularMovies); <span class=\"hljs-comment\">// [B, C]</span>\n</code></pre><hr>\n<h2>9. Key Takeaways</h2>\n<ul>\n<li>Streams = <strong>pipeline of data</strong> with intermediate + terminal operations.</li>\n<li>Encourages <strong>declarative programming</strong> (what to do, not how).</li>\n<li>Avoids manual loops and state.</li>\n<li>Powerful when combined with <strong>lambdas + functional interfaces</strong>.</li>\n<li>Collectors let you transform results into lists, sets, maps, summaries, or groups.</li>\n</ul>\n<hr>\n","markdown":"# **Functional Interfaces in Java**\n\nJava 8 introduced **functional programming features** such as lambdas, method references, and the `java.util.function` package. At the heart of this ecosystem are **functional interfaces**.\n\n---\n\n## 1Ô∏è‚É£ What is a Functional Interface?\n\n- A **functional interface** is an interface with exactly **one abstract method**.\n- This single method defines the **functional contract**.\n- Java provides many built-in functional interfaces in the `java.util.function` package.\n- Examples: `Function<T,R>`, `Consumer<T>`, `Supplier<T>`, `Predicate<T>`, `UnaryOperator<T>`, `BinaryOperator<T>`.\n\n‚ö° Lambdas and method references can be used wherever a functional interface is expected.\n\n---\n\n## 2Ô∏è‚É£ `Function<T, R>` ‚Äì Transforming Data\n\n- Represents a function that **takes one argument of type `T` and returns a result of type `R`**.\n\n```java\npackage thisisamr;\n\nimport java.util.function.Function;\n\npublic class FunctionInterfaceExample {\n    public static void main(String[] args) {\n        Function<String, String> modify = (name) -> name + \" Modified\";\n\n        System.out.println(modify.apply(\"Amr\"));  // Amr Modified\n\n        // Function composition\n        var result = modify\n                .compose((String p) -> p.toLowerCase()) // runs first\n                .apply(\"AAAAA\");\n\n        System.out.println(result); // aaaaa Modified\n    }\n}\n```\n\n### üìù Key methods\n\n- `apply(T t)` ‚Üí runs the function.\n- `compose(Function before)` ‚Üí run another function _before_.\n- `andThen(Function after)` ‚Üí run another function _after_.\n\nSo you can build **pipelines** of transformations.\n\n---\n\n## 3Ô∏è‚É£ `Consumer<T>` ‚Äì Consuming Data\n\n- Represents an operation that **takes one argument and returns nothing** (side effects only).\n- Typical use: logging, printing, collecting results.\n\n```java\npackage thisisamr;\n\nimport java.util.List;\nimport java.util.function.Consumer;\n\npublic class ConsumerInterfaceExample {\n    public static void main(String[] args) {\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5);\n\n        Consumer<Integer> print = System.out::println;\n\n        // Chaining consumers\n        numbers.forEach(print.andThen(i -> System.out.println(i * 2)));\n    }\n}\n```\n\n---\n\n## 4Ô∏è‚É£ `Supplier<T>` ‚Äì Supplying Values\n\n- Represents a function that **takes no arguments but returns a value**.\n\n```java\npackage thisisamr;\n\nimport java.util.function.DoubleSupplier;\nimport java.util.function.Supplier;\n\npublic class SupplierInterfaceExample {\n    public static void main(String[] args) {\n        Supplier<Double> randomBoxed = Math::random;\n        DoubleSupplier randomPrimitive = Math::random;\n\n        System.out.println(randomBoxed.get());       // Double (boxed)\n        System.out.println(randomPrimitive.getAsDouble()); // double (primitive)\n    }\n}\n```\n\n### üîë Why `DoubleSupplier`?\n\n- To avoid the **overhead of boxing/unboxing**.\n- `Supplier<Double>` works with objects (heap allocated).\n- `DoubleSupplier` works directly with `double` (faster, no GC overhead).\n\nüëâ Boxing/unboxing exists because Java generics only work with objects, unlike modern languages (Rust, Go, C++).\n\n---\n\n## 5Ô∏è‚É£ `Predicate<T>` ‚Äì Filtering Data\n\n- Represents a function that **takes one argument and returns a boolean**.\n- Often used for filtering and conditional logic.\n\n```java\npackage thisisamr;\n\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class PredicateInterfaceExample {\n    public static void main(String[] args) {\n        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 9);\n\n        Predicate<Integer> divisibleBy3 = i -> i % 3 == 0;\n\n        numbers.stream()\n               .filter(divisibleBy3)\n               .forEach(System.out::println); // 3, 6, 9\n\n        // Combining predicates\n        Predicate<String> hasLeftBrace = str -> str.startsWith(\"{\");\n        Predicate<String> hasRightBrace = str -> str.endsWith(\"}\");\n\n        Predicate<String> both = hasLeftBrace.and(hasRightBrace);\n        Predicate<String> either = hasLeftBrace.or(hasRightBrace);\n        Predicate<String> notLeft = hasLeftBrace.negate();\n\n        System.out.println(both.test(\"{ASD}\"));   // true\n        System.out.println(either.test(\"{ASD\"));  // true\n        System.out.println(notLeft.test(\"ASD\"));  // true\n    }\n}\n```\n\n---\n\n## 6Ô∏è‚É£ `UnaryOperator<T>` and `BinaryOperator<T>`\n\n- Both are **specializations of `Function`**:\n  - `UnaryOperator<T>` ‚Üí takes one argument and returns the same type.\n  - `BinaryOperator<T>` ‚Üí takes two arguments of the same type and returns the same type.\n\n```java\npackage thisisamr;\n\nimport java.util.function.BinaryOperator;\nimport java.util.function.Function;\nimport java.util.function.UnaryOperator;\n\npublic class OperatorExamples {\n    public static void main(String[] args) {\n        BinaryOperator<Integer> add = Integer::sum;\n        Function<Integer, Integer> square = a -> a * a;\n\n        var result = add.andThen(square).apply(1, 3);\n        System.out.println(result); // (1+3)^2 = 16\n\n        UnaryOperator<Integer> increment = a -> a + 1;\n        UnaryOperator<Integer> squareOp = a -> a * a;\n\n        System.out.println(increment.andThen(squareOp).apply(1)); // (1+1)^2 = 4\n    }\n}\n```\n\n---\n\n## üîë Summary\n\n- **Functional interfaces** allow Java to use **lambdas and method references** elegantly.\n- Core built-in interfaces:\n  - `Function<T,R>` ‚Üí transforms data.\n  - `Consumer<T>` ‚Üí consumes data (side effects).\n  - `Supplier<T>` ‚Üí supplies values.\n  - `Predicate<T>` ‚Üí tests conditions.\n  - `UnaryOperator<T>` and `BinaryOperator<T>` ‚Üí operate on same-type inputs.\n\n- They can be **chained, composed, and combined**.\n- You‚Äôll use them extensively with **Streams** for mapping, filtering, reducing, and collecting.\n\n---\n\nüëâ Next step: apply these in **Streams** (map, filter, reduce, collect) ‚Äî that‚Äôs where the real power shows.\n\nPerfect üëå what you‚Äôve written is already a nice ‚Äúplayground‚Äù for students to see streams in action. Let me turn it into a **structured, refined lecture on Java Streams**, with clearer flow, theory + practical examples.\n\n---\n\n# üöÄ **Java Streams ‚Äì A Comprehensive Introduction**\n\n---\n\n## 1. What are Streams?\n\nStreams are one of the most powerful features introduced in Java 8.\nThey allow us to **process data in a declarative, functional style**, instead of writing loops and manual logic.\n\nThink of a stream as:\n\n- A **pipeline** of data flowing through transformations.\n- It doesn‚Äôt **store** data ‚Äì it processes data from a source (collection, array, I/O, or infinite generator).\n\n---\n\n## 2. Creating Streams\n\nYou can create streams from multiple sources:\n\n### From collections:\n\n```java\nList<String> names = List.of(\"Amr\", \"Huda\", \"Salwa\");\nnames.stream().forEach(System.out::println);\n```\n\n### From arrays:\n\n```java\nint[] nums = {1, 2, 3, 4, 5};\nArrays.stream(nums).forEach(System.out::print);\n```\n\n### From infinite generators:\n\n```java\nStream.generate(Math::random).limit(3).forEach(System.out::println);\nStream.iterate(1, n -> n * 2).limit(5).forEach(System.out::println);\n```\n\n---\n\n## 3. Intermediate Operations\n\nThese **transform streams** but don‚Äôt produce a result until a terminal operation is called.\n\nSome common ones:\n\n- **`filter`** ‚Üí keep only matching elements\n- **`map`** ‚Üí transform each element\n- **`distinct`** ‚Üí remove duplicates\n- **`sorted`** ‚Üí order elements\n- **`limit`, `skip`, `takeWhile`, `dropWhile`** ‚Üí slicing\n- **`peek`** ‚Üí debugging, view without consuming\n\nExample:\n\n```java\nmovies.stream()\n      .filter(m -> m.likes > 20)   // keep movies with likes > 20\n      .map(m -> m.title)           // transform to titles\n      .distinct()\n      .forEach(System.out::println);\n```\n\n---\n\n## 4. Terminal Operations\n\nThese **end the stream pipeline** and produce a result (number, collection, boolean, etc.).\n\nExamples:\n\n- **Counting**\n\n```java\nlong count = movies.stream().filter(m -> m.likes > 20).count();\n```\n\n- **Matching**\n\n```java\nmovies.stream().allMatch(m -> m.likes > 10); // true/false\nmovies.stream().anyMatch(m -> m.genre == Movie.GENRE.ACTION);\n```\n\n- **Finding**\n\n```java\nmovies.stream().findFirst().ifPresent(System.out::println);\nmovies.stream().findAny().ifPresent(System.out::println);\n```\n\n- **Reducing**\n\n```java\nint totalLikes = movies.stream()\n                       .map(m -> m.likes)\n                       .reduce(Integer::sum)\n                       .orElse(0);\n```\n\n---\n\n## 5. Collecting Results\n\nStreams integrate tightly with the **Collectors** utility class.\n\n- **To List/Set**\n\n```java\nList<String> titles = movies.stream()\n                            .map(m -> m.title)\n                            .toList();\n```\n\n- **To Set (unique values)**\n\n```java\nSet<Integer> likes = movies.stream()\n                           .map(m -> m.likes)\n                           .collect(Collectors.toSet());\n```\n\n- **Summarizing**\n\n```java\nvar stats = movies.stream()\n                  .collect(Collectors.summarizingInt(m -> m.likes));\nSystem.out.println(stats.getAverage());\n```\n\n- **Grouping**\n\n```java\nvar grouped = movies.stream()\n                    .collect(Collectors.groupingBy(m -> m.genre));\n```\n\n- **Grouping + Mapping**\n\n```java\nvar groupedTitles = movies.stream()\n    .collect(Collectors.groupingBy(m -> m.genre,\n             Collectors.mapping(m -> m.title, Collectors.joining(\", \"))));\n```\n\n- **Partitioning**\n\n```java\nvar partitioned = movies.stream()\n                        .collect(Collectors.partitioningBy(m -> m.likes > 20));\n```\n\n---\n\n## 6. Sorting\n\nStreams allow easy sorting:\n\n- With a comparator:\n\n```java\nvar sorted = movies.stream()\n                   .sorted(Comparator.comparingInt(m -> m.likes))\n                   .toList();\n```\n\n- With a custom comparator:\n\n```java\nvar sortedDesc = movies.stream()\n                       .sorted((m1, m2) -> m2.likes - m1.likes)\n                       .toList();\n```\n\n---\n\n## 7. Primitive Streams\n\nWhen working with primitives, Java provides specialized streams:\n\n- **`IntStream`**\n- **`LongStream`**\n- **`DoubleStream`**\n\nUseful methods:\n\n```java\nIntStream.range(1, 5).forEach(System.out::println);      // 1..4\nIntStream.rangeClosed(1, 5).forEach(System.out::println); // 1..5\n```\n\nThis avoids boxing/unboxing overhead.\n\n---\n\n## 8. Example Recap with `Movie` Class\n\n```java\nList<Movie> movies = List.of(\n    new Movie(\"A\", 12, Movie.GENRE.ACTION),\n    new Movie(\"B\", 22, Movie.GENRE.ROMANCE),\n    new Movie(\"C\", 32, Movie.GENRE.COMEDY)\n);\n\n// Filter + map + collect\nList<String> popularMovies = movies.stream()\n    .filter(m -> m.likes > 20)\n    .map(m -> m.title)\n    .toList();\n\nSystem.out.println(popularMovies); // [B, C]\n```\n\n---\n\n## 9. Key Takeaways\n\n- Streams = **pipeline of data** with intermediate + terminal operations.\n- Encourages **declarative programming** (what to do, not how).\n- Avoids manual loops and state.\n- Powerful when combined with **lambdas + functional interfaces**.\n- Collectors let you transform results into lists, sets, maps, summaries, or groups.\n\n---\n","slug":"Functional programming","title":"Functional Programming","section":"A Quick Refresher","icon":"rotate","filePath":"/home/runner/work/complete-intro-to-spring-and-springBoot/complete-intro-to-spring-and-springBoot/lessons/00-A quick Refresher/E-Functional programming.md","nextSlug":"/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Threads and concurrent Programming","prevSlug":"/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Advanced java"}},"__N_SSG":true}