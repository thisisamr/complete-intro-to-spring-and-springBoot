{"pageProps":{"post":{"attributes":{},"html":"<h1><strong>Introduction to Object-Oriented Programming (OOP) in Java</strong></h1>\n<p>Welcome to the second part of our Java refresher course.\nIn this section, we’ll start exploring <strong>Object-Oriented Programming (OOP)</strong> — the most widely used programming paradigm in Java.</p>\n<hr>\n<h2>What is OOP?</h2>\n<p>OOP (Object-Oriented Programming) is just a <strong>programming paradigm</strong> — a style of writing code.\nIt’s not the only one:</p>\n<ul>\n<li><strong>Procedural</strong> (C, early Java)</li>\n<li><strong>Functional</strong> (Java Streams, Haskell, Scala)</li>\n<li><strong>Event-driven</strong> (GUIs, message-based systems)</li>\n<li><strong>Object-oriented</strong> (Java, C++, C#)</li>\n</ul>\n<p>👉 In OOP, we <strong>combine data and behavior into a single unit called an object</strong>.</p>\n<p>This differs from functional programming, which separates data and behavior.</p>\n<p>⚡ Important:</p>\n<ul>\n<li>Don’t get stuck on paradigms. Each has its strengths.</li>\n<li>Java is classically OOP-focused, but modern approaches (like Go or Rust) use different models.</li>\n<li>Use the style that best <strong>solves your problem</strong>.</li>\n</ul>\n<hr>\n<h2>The Four Pillars of OOP</h2>\n<p>In this section of the course, we’ll cover:</p>\n<ul>\n<li><strong>Encapsulation</strong> – bundling data + methods, controlling access</li>\n<li><strong>Abstraction</strong> – hiding details, showing only essentials</li>\n<li><strong>Inheritance</strong> – reusing existing code by extending classes</li>\n<li><strong>Polymorphism</strong> – objects behaving differently under the same interface</li>\n</ul>\n<p>Additionally, we’ll learn about:</p>\n<ul>\n<li><strong>Classes</strong> (the building blocks of OOP)</li>\n<li><strong>Constructors</strong></li>\n<li><strong>Getters &amp; Setters</strong></li>\n<li><strong>Method Overloading</strong></li>\n<li><strong>Interfaces</strong></li>\n<li><strong>Coupling &amp; Dependency</strong> between classes</li>\n</ul>\n<hr>\n<h2>Classes and Objects</h2>\n<p>A <strong>class</strong> is like a <strong>blueprint</strong> or <strong>type</strong>.</p>\n<p>Example:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Car</span> {\n    String model;\n    <span class=\"hljs-type\">int</span> year;\n}\n</code></pre><p>When we create something from this class, we get an <strong>object (or instance)</strong>:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">Car</span> <span class=\"hljs-variable\">myCar</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Car</span>();\n</code></pre><hr>\n<h2>Memory Model in Java</h2>\n<p>Java memory is divided into:</p>\n<ul>\n<li><strong>Stack</strong> – stores <strong>primitive values</strong> and <strong>object references</strong> (addresses).</li>\n<li><strong>Heap</strong> – stores the actual <strong>objects</strong> (created with <code>new</code>).</li>\n</ul>\n<p>🔑 Key points:</p>\n<ul>\n<li>When a method ends, stack variables are removed.</li>\n<li>If no references point to an object in the heap, the <strong>Garbage Collector</strong> will eventually clean it up.</li>\n</ul>\n<hr>\n<h2>Example: Our First Class</h2>\n<p>Here’s a small example:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Main</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">// Create an instance of TextBox</span>\n        <span class=\"hljs-type\">TextBox</span> <span class=\"hljs-variable\">tb</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TextBox</span>(<span class=\"hljs-string\">&quot;BOX1&quot;</span>);\n\n        <span class=\"hljs-comment\">// Print text in lowercase</span>\n        System.out.println(tb.text.toLowerCase());\n    }\n\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TextBox</span> {\n        <span class=\"hljs-comment\">// Field</span>\n        <span class=\"hljs-keyword\">public</span> String text;\n\n        <span class=\"hljs-comment\">// Constructor</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">TextBox</span><span class=\"hljs-params\">(String value)</span> {\n            <span class=\"hljs-built_in\">this</span>.text = value;\n        }\n\n        <span class=\"hljs-comment\">// Setter method</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setText</span><span class=\"hljs-params\">(String text)</span> {\n            <span class=\"hljs-built_in\">this</span>.text = text;\n        }\n\n        <span class=\"hljs-comment\">// Clear method</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">clear</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-built_in\">this</span>.text = <span class=\"hljs-string\">&quot;&quot;</span>;\n        }\n    }\n}\n</code></pre><hr>\n<h3>Explanation:</h3>\n<ul>\n<li><code>TextBox</code> is a <strong>class</strong> (blueprint).</li>\n<li><code>text</code> is a <strong>field</strong> (data stored in the object).</li>\n<li>The <strong>constructor</strong> initializes the object.</li>\n<li><code>setText</code> and <code>clear</code> are <strong>methods</strong> that define behavior.</li>\n<li>In <code>main</code>, we create an <strong>object</strong> (<code>tb</code>) using <code>new TextBox(&quot;BOX1&quot;)</code>.</li>\n</ul>\n<hr>\n<h1>From Procedural to Object-Oriented Programming</h1>\n<p>In the last lesson, we introduced <strong>classes</strong> and saw how objects bundle <strong>data + behavior</strong>.</p>\n<p>Now, let’s take a simple example — calculating an employee’s wage — and see how it looks:</p>\n<ol>\n<li>First, in a <strong>procedural style</strong> (functions + variables, separate).</li>\n<li>Then, in <strong>OOP style</strong> (using a class that encapsulates data + behavior).</li>\n</ol>\n<hr>\n<h2>Procedural Approach</h2>\n<p>In a procedural style, we might write something like this:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ProceduralDemo</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">baseSalary</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5000</span>;\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">hourlyRate</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">50</span>;\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">extraHours</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;\n\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">wage</span> <span class=\"hljs-operator\">=</span> calculateWage(baseSalary, hourlyRate, extraHours);\n        System.out.println(wage);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">calculateWage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> base, <span class=\"hljs-type\">int</span> hourlyRate, <span class=\"hljs-type\">int</span> extraHours)</span> {\n        <span class=\"hljs-keyword\">return</span> base + extraHours * hourlyRate;\n    }\n}\n</code></pre><p>👉 Here, we:</p>\n<ul>\n<li>Store data (<code>baseSalary</code>, <code>hourlyRate</code>, <code>extraHours</code>) in <strong>separate variables</strong>.</li>\n<li>Write a <strong>standalone function</strong> (<code>calculateWage</code>) to compute the result.</li>\n</ul>\n<p>This works, but as the program grows, managing all these <strong>loose variables</strong> gets messy.</p>\n<hr>\n<h2>OOP Approach</h2>\n<p>In OOP, we bundle the <strong>data</strong> (like salary and hourly rate) and the <strong>functionality</strong> (like calculating wage) inside a single <strong>class</strong>.</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Procedural</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">Employee</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Employee</span>();\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">wage</span> <span class=\"hljs-operator\">=</span> e.calculateWage(<span class=\"hljs-number\">12</span>);\n\n        e.setBaseSalary(<span class=\"hljs-number\">6000</span>); <span class=\"hljs-comment\">// using setter</span>\n        System.out.println(wage);\n    }\n\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Employee</span> {\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">baseSalary</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5000</span>;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">hourlyRate</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">50</span>;\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getBaseSalary</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-keyword\">return</span> baseSalary;\n        }\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setBaseSalary</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> baseSalary)</span> {\n            <span class=\"hljs-keyword\">if</span> (baseSalary &lt;= <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;Base salary cannot be negative or zero&quot;</span>);\n            }\n            <span class=\"hljs-built_in\">this</span>.baseSalary = baseSalary;\n        }\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">calculateWage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> extraHours)</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.baseSalary + <span class=\"hljs-built_in\">this</span>.hourlyRate * extraHours;\n        }\n    }\n}\n</code></pre><hr>\n<h3>What Changed?</h3>\n<ol>\n<li><p><strong>Encapsulation</strong>:</p>\n<ul>\n<li>We made <code>baseSalary</code> <strong>private</strong> so it cannot be modified directly.</li>\n<li>We control changes using <strong>getters and setters</strong>.</li>\n<li>This allows us to enforce rules (e.g., salary cannot be <code>0</code> or negative).</li>\n</ul>\n</li>\n<li><p><strong>Methods inside the class</strong>:</p>\n<ul>\n<li>Instead of writing a separate <code>calculateWage</code> function, it is now part of <code>Employee</code>.</li>\n<li>This makes sense because &quot;wage calculation&quot; is <strong>behavior</strong> of an Employee.</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h2>Why Encapsulation Matters</h2>\n<p>Let’s say we didn’t hide <code>baseSalary</code> and left it public:</p>\n<pre><code class=\"hljs language-java\">e.baseSalary = -<span class=\"hljs-number\">1000</span>;  <span class=\"hljs-comment\">// valid in procedural style, but meaningless!</span>\n</code></pre><p>That would allow invalid states.\nBy making it <strong>private</strong> and controlling it with a setter, we ensure data integrity:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setBaseSalary</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> baseSalary)</span> {\n    <span class=\"hljs-keyword\">if</span> (baseSalary &lt;= <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;Base salary cannot be negative or zero&quot;</span>);\n    }\n    <span class=\"hljs-built_in\">this</span>.baseSalary = baseSalary;\n}\n</code></pre><hr>\n<p>✅ With this, we’ve transitioned from procedural code → OOP design.\nNext, we’ll look at <strong>constructors, overloading, and further encapsulation improvements</strong>.</p>\n<hr>\n<h1><strong>Abstraction, Coupling, Constructors, and Static Members</strong></h1>\n<h2>Abstraction</h2>\n<ul>\n<li><strong>Definition:</strong> Abstraction is simply reducing complexity by hiding unnecessary details.</li>\n<li>Instead of exposing raw class members (fields) to the outside world, we expose <strong>methods</strong> that control how other code interacts with the class.</li>\n<li>This hides implementation details and protects the integrity of the class.</li>\n</ul>\n<hr>\n<h2>Coupling</h2>\n<ul>\n<li><strong>Coupling</strong> happens when classes depend on each other.</li>\n<li>Coupling is not always bad, but if classes are <strong>tightly coupled</strong>, then changing one class may force you to change many others.</li>\n<li>By reducing coupling, we make our code more <strong>maintainable</strong> and <strong>flexible</strong>.</li>\n</ul>\n<hr>\n<h2>Example: Employee Class</h2>\n<p>Instead of exposing fields directly, we use <strong>getters and setters</strong> with validation.</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Employee</span> {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">hourlyRate</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">50</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">baseSalary</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5000</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getBaseSalary</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> baseSalary;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setBaseSalary</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> baseSalary)</span> {\n        <span class=\"hljs-keyword\">if</span> (baseSalary &lt;= <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalArgumentException</span>(<span class=\"hljs-string\">&quot;Base salary cannot be negative or zero&quot;</span>);\n        }\n        <span class=\"hljs-built_in\">this</span>.baseSalary = baseSalary;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">calculateWage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> extraHours)</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.baseSalary + <span class=\"hljs-built_in\">this</span>.hourlyRate * extraHours;\n    }\n}\n</code></pre><h3>Key points:</h3>\n<ul>\n<li>We made <code>baseSalary</code> <strong>private</strong> to prevent direct modification.</li>\n<li>We added a <strong>setter method</strong> with validation to avoid putting the class into a “bad state.”</li>\n<li>We exposed a <strong>method</strong> (<code>calculateWage</code>) to perform work instead of letting the outside code do the calculation.</li>\n</ul>\n<hr>\n<h2>Constructors</h2>\n<p>Constructors are special methods that initialize objects when they are created.\nThey help us avoid forgetting to initialize important values.</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Employee</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> baseSalary;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> hourlyRate;\n\n    <span class=\"hljs-comment\">// Constructor with parameters</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Employee</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> baseSalary, <span class=\"hljs-type\">int</span> hourlyRate)</span> {\n        <span class=\"hljs-built_in\">this</span>.baseSalary = baseSalary;\n        <span class=\"hljs-built_in\">this</span>.hourlyRate = hourlyRate;\n    }\n\n    <span class=\"hljs-comment\">// Overloaded constructor with default values</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Employee</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-built_in\">this</span>.baseSalary = <span class=\"hljs-number\">5000</span>;\n        <span class=\"hljs-built_in\">this</span>.hourlyRate = <span class=\"hljs-number\">10</span>;\n    }\n}\n</code></pre><h3>Notes:</h3>\n<ul>\n<li>By providing multiple constructors (<strong>constructor overloading</strong>), we can simulate “default parameters” in Java.</li>\n<li>Unlike languages like C#, C++, Go, or JavaScript, Java does not support default parameter values directly. Overloading is the workaround.</li>\n</ul>\n<hr>\n<h2>Static Members</h2>\n<ul>\n<li>A class can have <strong>instance members</strong> (belong to an object) or <strong>static members</strong> (belong to the class itself).</li>\n<li><strong>Static methods</strong> are useful when we don’t need an object, for example the <code>main</code> method:</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Program</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">// no object needed because main is static</span>\n        System.out.println(<span class=\"hljs-string\">&quot;Hello OOP&quot;</span>);\n    }\n}\n</code></pre><h3>When to use static:</h3>\n<ul>\n<li>When a value or behavior should be <strong>shared across all objects</strong>.</li>\n<li>When you want to provide <strong>utility functions</strong> (e.g., <code>Math.sqrt()</code>).</li>\n</ul>\n<hr>\n<h2>Transition</h2>\n<p>We’ve now seen:</p>\n<ul>\n<li>How abstraction helps hide details.</li>\n<li>How to reduce coupling between classes.</li>\n<li>How constructors and method overloading make our classes safer and more flexible.</li>\n<li>The difference between instance and static members.</li>\n</ul>\n<p>👉 <strong>Next time, we’ll look at <em>inheritance</em></strong> — how one class can derive from another and reuse its code.</p>\n<hr>\n<h1><strong>Inheritance, Casting, Abstract Classes, and Polymorphism</strong></h1>\n<p>In the previous section, we talked about the <strong>basics of OOP</strong> – classes, objects, encapsulation, abstraction, and methods.\nNow we’re going to push further into <strong>how objects relate to each other</strong> through inheritance, casting, abstract classes, and polymorphism.</p>\n<hr>\n<h2>Upcasting and Downcasting</h2>\n<p>In Java, when you have a class hierarchy:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UiControl</span> { ... }\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TextBox</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">UiControl</span> { ... }\n</code></pre><ul>\n<li><strong>Upcasting</strong> → assigning a subclass (<code>TextBox</code>) to a superclass (<code>UiControl</code>) reference.\n✅ Always safe.</li>\n<li><strong>Downcasting</strong> → forcing a superclass reference back into a subclass.\n⚠️ Dangerous, only works if the object is <em>actually</em> that subclass at runtime.</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">UiControl</span> <span class=\"hljs-variable\">control</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TextBox</span>(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// upcasting, safe</span>\n<span class=\"hljs-type\">TextBox</span> <span class=\"hljs-variable\">tb</span> <span class=\"hljs-operator\">=</span> (TextBox) control;        <span class=\"hljs-comment\">// downcasting, works</span>\n\n<span class=\"hljs-type\">UiControl</span> <span class=\"hljs-variable\">control2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">UiControl</span>(<span class=\"hljs-literal\">true</span>);\n<span class=\"hljs-type\">TextBox</span> <span class=\"hljs-variable\">tb2</span> <span class=\"hljs-operator\">=</span> (TextBox) control2;      <span class=\"hljs-comment\">// ❌ runtime error</span>\n</code></pre><p>👉 Always check with <code>instanceof</code> or <code>getClass()</code> before downcasting.</p>\n<hr>\n<h2>Abstract Classes</h2>\n<p>Sometimes, we want to define a <strong>general concept</strong> without being able to create it directly.</p>\n<p>For example, <code>UiControl</code> is an abstract idea – we don’t really have a generic &quot;control&quot; in a UI, but we do have specific controls like <code>TextBox</code> or <code>CheckBox</code>.</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UiControl</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">isEnabled</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">UiControl</span><span class=\"hljs-params\">(<span class=\"hljs-type\">boolean</span> flag)</span> {\n        <span class=\"hljs-built_in\">this</span>.isEnabled = flag;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isEnabled</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> isEnabled; }\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setEnabled</span><span class=\"hljs-params\">(<span class=\"hljs-type\">boolean</span> enabled)</span> { <span class=\"hljs-built_in\">this</span>.isEnabled = enabled; }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">abstract</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">draw</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// forces subclasses to implement</span>\n}\n</code></pre><ul>\n<li>You <strong>cannot instantiate</strong> an abstract class.</li>\n<li>Subclasses <strong>must</strong> implement the abstract methods.</li>\n</ul>\n<hr>\n<h2>Final Classes and Methods</h2>\n<ul>\n<li>A <strong>final class</strong> cannot be extended.</li>\n<li>A <strong>final method</strong> cannot be overridden.</li>\n</ul>\n<p>Rarely used, but important for ensuring immutability and security.</p>\n<hr>\n<h2>Polymorphism</h2>\n<p>Polymorphism means <strong>“many forms.”</strong></p>\n<p>When you call a method on a superclass reference, the JVM will run the <strong>actual subclass implementation</strong> at runtime.</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">GeometricShape</span> {\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">draw</span><span class=\"hljs-params\">()</span>;\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Circle</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">GeometricShape</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">draw</span><span class=\"hljs-params\">()</span> { System.out.println(<span class=\"hljs-string\">&quot;This is a circle&quot;</span>); }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Square</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">GeometricShape</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">draw</span><span class=\"hljs-params\">()</span> { System.out.println(<span class=\"hljs-string\">&quot;This is a square&quot;</span>); }\n}\n</code></pre><p>Now if we write:</p>\n<pre><code class=\"hljs language-java\">GeometricShape[] shapes = { <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Circle</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Square</span>() };\n\n<span class=\"hljs-keyword\">for</span> (GeometricShape s : shapes) {\n    s.draw(); <span class=\"hljs-comment\">// Polymorphism in action</span>\n}\n</code></pre><p>Each object runs its own implementation, even though the reference type is the interface.</p>\n<hr>\n<h2>Comparing Objects (<code>equals</code>)</h2>\n<p>By default, the <code>equals</code> method compares object <strong>references</strong>, not actual content.</p>\n<p>Example:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Point</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> x, y;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Point</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y)</span> {\n        <span class=\"hljs-built_in\">this</span>.x = x;\n        <span class=\"hljs-built_in\">this</span>.y = y;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">equals</span><span class=\"hljs-params\">(Object obj)</span> {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span> == obj) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;                <span class=\"hljs-comment\">// same reference</span>\n        <span class=\"hljs-keyword\">if</span> (obj == <span class=\"hljs-literal\">null</span> || getClass() != obj.getClass()) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n\n        <span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">other</span> <span class=\"hljs-operator\">=</span> (Point) obj;                   <span class=\"hljs-comment\">// safe cast</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.x == other.x &amp;&amp; <span class=\"hljs-built_in\">this</span>.y == other.y;\n    }\n}\n</code></pre><p>Now:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">p1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n<span class=\"hljs-type\">Point</span> <span class=\"hljs-variable\">p2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Point</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n\nSystem.out.println(p1.equals(p2)); <span class=\"hljs-comment\">// true ✅ (compares content)</span>\nSystem.out.println(p1 == p2);      <span class=\"hljs-comment\">// false ❌ (different references)</span>\n</code></pre><hr>\n<h2>Putting It All Together</h2>\n<p>Here’s a summary of what we covered with live code:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UpCastingDowncasting</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        GeometricShape[] shapes = { <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Circle</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Square</span>() };\n        <span class=\"hljs-keyword\">for</span> (GeometricShape sh : shapes) sh.draw();\n    }\n}\n</code></pre><ul>\n<li><code>UiControl</code> → base (abstract) concept.</li>\n<li><code>TextBox</code> → subclass (concrete).</li>\n<li>Upcasting allows <code>TextBox</code> to be treated as <code>UiControl</code>.</li>\n<li>Downcasting requires checks.</li>\n<li>Interfaces allow polymorphism across unrelated classes.</li>\n<li>Override <code>equals</code> to compare <strong>contents</strong>, not references.</li>\n</ul>\n<hr>\n<p>✅ Next lesson: <strong>Interfaces and Dependency Injection</strong></p>\n<hr>\n<!---->\n<!-- # C-9 📘 Lecture: Interfaces and Dependency Injection in Java -->\n<!---->\n<!-- Today, we’re going to dive into **interfaces** in Java, understand **why they exist**, and learn how they help us build **loosely coupled, extensible, and testable applications**. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 1. Why Interfaces? (The Restaurant Analogy) -->\n<!---->\n<!-- Imagine you own a restaurant. You hire a chef named John. John is great, but one day John gets sick. If your restaurant only works because *John* is there, your business is in trouble. -->\n<!---->\n<!-- But what if instead, you said: -->\n<!---->\n<!-- > “I don’t care who the chef is, as long as they can cook.” -->\n<!---->\n<!-- That’s exactly what interfaces are about. We don’t tie ourselves to a **specific person (class)** — we depend on a **contract (interface)**. -->\n<!---->\n<!-- This way, our application can keep running no matter who is “in the kitchen.” -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 2. The Problem of Tight Coupling -->\n<!---->\n<!-- Let’s look at some code that is **tightly coupled**: -->\n<!---->\n<!-- ```java -->\n<!-- static class TaxReport { -->\n<!--     private TaxCal taxCal; -->\n<!---->\n<!--     public TaxReport() { -->\n<!--         taxCal = new TaxCal(1000); -->\n<!--     } -->\n<!-- } -->\n<!---->\n<!-- static class TaxCal { -->\n<!--     private double taxableIncome; -->\n<!---->\n<!--     public TaxCal(double taxableIncome) { -->\n<!--         this.taxableIncome = taxableIncome; -->\n<!--     } -->\n<!---->\n<!--     public double calculateTax() { -->\n<!--         return taxableIncome * 0.3; -->\n<!--     } -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- Here’s the issue: -->\n<!---->\n<!-- * `TaxReport` directly depends on `TaxCal`. -->\n<!-- * If we change the `TaxCal` implementation, we might break `TaxReport`. -->\n<!-- * If we want to introduce a new tax rule (e.g., 2020 tax laws), we’d have to rewrite parts of `TaxReport`. -->\n<!---->\n<!-- This is **tight coupling**, and it makes code brittle and hard to maintain. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 3. Breaking the Coupling with Interfaces -->\n<!---->\n<!-- Now let’s introduce an **interface** to reduce coupling: -->\n<!---->\n<!-- ```java -->\n<!-- interface TaxCalculator { -->\n<!--     double calculateTax(); -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- Instead of depending on a *concrete class*, `TaxReport` now depends on this *contract*: -->\n<!---->\n<!-- ```java -->\n<!-- static class TaxReport { -->\n<!--     private TaxCalculator taxCal; -->\n<!---->\n<!--     // Constructor Injection -->\n<!--     public TaxReport(TaxCalculator tc) { -->\n<!--         taxCal = tc; -->\n<!--     } -->\n<!---->\n<!--     public void printReport() { -->\n<!--         System.out.println(taxCal.calculateTax()); -->\n<!--     } -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- Notice: -->\n<!---->\n<!-- * `TaxReport` doesn’t care *which* `TaxCalculator` it’s given. -->\n<!-- * As long as the class implements `TaxCalculator`, `TaxReport` is happy. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 4. Multiple Implementations -->\n<!---->\n<!-- Now we can write different tax calculators without breaking `TaxReport`: -->\n<!---->\n<!-- ```java -->\n<!-- static class TaxCal implements TaxCalculator { -->\n<!--     private double taxableIncome; -->\n<!---->\n<!--     public TaxCal(double taxableIncome) { -->\n<!--         this.taxableIncome = taxableIncome; -->\n<!--     } -->\n<!---->\n<!--     @Override -->\n<!--     public double calculateTax() { -->\n<!--         return taxableIncome * 0.3; -->\n<!--     } -->\n<!-- } -->\n<!---->\n<!-- static class TaxCal2020 implements TaxCalculator { -->\n<!--     private double taxableIncome; -->\n<!---->\n<!--     public TaxCal2020(double taxableIncome) { -->\n<!--         this.taxableIncome = taxableIncome; -->\n<!--     } -->\n<!---->\n<!--     @Override -->\n<!--     public double calculateTax() { -->\n<!--         return taxableIncome * 0.25;  // new rules for 2020 -->\n<!--     } -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- Now `TaxReport` can work with **any** tax calculator: -->\n<!---->\n<!-- ```java -->\n<!-- public static void main(String[] args) { -->\n<!--     TaxCalculator calc = new TaxCal(1000); -->\n<!--     TaxReport tr = new TaxReport(calc); -->\n<!--     tr.printReport(); -->\n<!---->\n<!--     TaxCalculator calc2020 = new TaxCal2020(1000); -->\n<!--     TaxReport tr2020 = new TaxReport(calc2020); -->\n<!--     tr2020.printReport(); -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 5. Dependency Injection -->\n<!---->\n<!-- What we just did is called **Dependency Injection (DI)**. -->\n<!---->\n<!-- Instead of `TaxReport` creating its own dependencies, we **inject** them from outside. -->\n<!-- There are three main ways to inject dependencies: -->\n<!---->\n<!-- 1. **Constructor Injection** (most common, what we used) -->\n<!-- 2. **Setter Injection** (pass a dependency via a setter method) -->\n<!-- 3. **Method Injection** (pass a dependency as a parameter to a method call) -->\n<!---->\n<!-- In real projects, you won’t manually manage all dependencies. -->\n<!-- Instead, you’ll often use a **DI Framework** like **Spring** to do this for you automatically. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 6. Interface Segregation -->\n<!---->\n<!-- One last point: -->\n<!---->\n<!-- If you create a huge “god interface” with too many methods, every implementing class is forced to implement things it doesn’t care about. -->\n<!---->\n<!-- That’s bad design. -->\n<!---->\n<!-- Instead, follow the **Interface Segregation Principle (ISP)**: -->\n<!---->\n<!-- > Split large interfaces into smaller, more focused ones. -->\n<!---->\n<!-- For example: -->\n<!---->\n<!-- ```java -->\n<!-- interface Drivable { -->\n<!--     void drive(); -->\n<!-- } -->\n<!---->\n<!-- interface Flyable { -->\n<!--     void fly(); -->\n<!-- } -->\n<!---->\n<!-- class Car implements Drivable { -->\n<!--     public void drive() { System.out.println(\"Car is driving\"); } -->\n<!-- } -->\n<!---->\n<!-- class Plane implements Drivable, Flyable { -->\n<!--     public void drive() { System.out.println(\"Plane is taxiing\"); } -->\n<!--     public void fly() { System.out.println(\"Plane is flying\"); } -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- This way, classes only implement what they actually need. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 7. A Note on Default, Private, and Static Methods in Interfaces -->\n<!---->\n<!-- Since Java 8, interfaces can have `default` and `static` methods. -->\n<!-- Since Java 9, they can even have `private` methods. -->\n<!---->\n<!-- Personally, I recommend being cautious here. Why? -->\n<!---->\n<!-- * An interface’s purpose is to define a **contract**. -->\n<!-- * Putting too much code inside an interface can blur the line between **contracts** and **implementations**. -->\n<!-- * If you need to share common logic between multiple classes, an **abstract class** that implements the interface is often a cleaner design. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## ✅ Summary -->\n<!---->\n<!-- * **Interfaces** define *what* a class can do, not *how*. -->\n<!-- * They help us build **loosely coupled, extensible, and testable applications**. -->\n<!-- * **Dependency Injection** means passing dependencies instead of creating them internally. -->\n<!-- * Use frameworks like **Spring** for large-scale projects. -->\n<!-- * Apply the **Interface Segregation Principle** to avoid “fat” interfaces. -->\n<!-- * Be careful with `default`, `static`, and `private` methods inside interfaces — prefer abstract classes for shared logic. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- 👉 And that’s interfaces in Java. -->\n<!-- Next time, we’ll look at how interfaces and **abstract classes** work together to design even more flexible systems. -->\n<!---->\n<!-- --- -->\n<!---->\n\n<h1>Java Interfaces and Inheritance Guide</h1>\n<h2>Why interfaces exists ?- THE BIG PICTURE</h2>\n<h3>The Restaurant Analogy</h3>\n<p>Imagine you own a restaurant and hire a chef named John. John is great, but what happens when John gets sick? If your restaurant only works because <em>John</em> is there, your business is in trouble.</p>\n<p>But what if instead, you said: <em>&quot;I don&#39;t care who the chef is, as long as they can cook.&quot;</em></p>\n<p>That&#39;s exactly what interfaces are about. We don&#39;t tie ourselves to a <strong>specific person (class)</strong> — we depend on a <strong>contract (interface)</strong>. This way, our application can keep running no matter who is &quot;in the kitchen.&quot;</p>\n<h3>The Problem: <strong>Tight Coupling</strong></h3>\n<p>Let&#39;s look at code that is <strong>tightly coupled</strong>:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TaxReport</span> {\n    <span class=\"hljs-keyword\">private</span> TaxCal taxCal;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">TaxReport</span><span class=\"hljs-params\">()</span> {\n        taxCal = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TaxCal</span>(<span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// Directly creates dependency</span>\n    }\n}\n\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TaxCal</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">double</span> taxableIncome;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">TaxCal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> taxableIncome)</span> {\n        <span class=\"hljs-built_in\">this</span>.taxableIncome = taxableIncome;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">calculateTax</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> taxableIncome * <span class=\"hljs-number\">0.3</span>;\n    }\n}\n</code></pre><p>Problems with this approach:</p>\n<ul>\n<li><code>TaxReport</code> directly depends on <code>TaxCal</code></li>\n<li>Changing <code>TaxCal</code> might break <code>TaxReport</code></li>\n<li>Adding new tax rules requires rewriting <code>TaxReport</code></li>\n<li>Hard to test in isolation</li>\n</ul>\n<h3>The Solution: Programming Against Interfaces</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">TaxCalculator</span> {\n    <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">calculateTax</span><span class=\"hljs-params\">()</span>;\n}\n\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TaxReport</span> {\n    <span class=\"hljs-keyword\">private</span> TaxCalculator taxCal;\n\n    <span class=\"hljs-comment\">// Constructor Injection - depends on contract, not implementation</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">TaxReport</span><span class=\"hljs-params\">(TaxCalculator tc)</span> {\n        taxCal = tc;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printReport</span><span class=\"hljs-params\">()</span> {\n        System.out.println(taxCal.calculateTax());\n    }\n}\n</code></pre><p>Now <code>TaxReport</code> doesn&#39;t care <em>which</em> <code>TaxCalculator</code> it receives - it just needs something that fulfills the contract.</p>\n<h2>Multiple Inher rules</h2>\n<h3>Classes: Single Inheritance Only</h3>\n<p><strong>Java classes cannot extend multiple classes</strong>. Java only allows <strong>single inheritance</strong>:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> { }\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">B</span> { }\n<span class=\"hljs-comment\">// ❌ Not allowed - will cause compile error</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">C</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">A</span>, B { }\n</code></pre><h3>Interfaces: Multiple Inheritance Allowed</h3>\n<p>Unlike classes, an <strong>interface can extend multiple interfaces</strong>:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">A</span> { <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">foo</span><span class=\"hljs-params\">()</span>; }\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">B</span> { <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bar</span><span class=\"hljs-params\">()</span>; }\n\n<span class=\"hljs-comment\">// ✅ Perfectly valid</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">C</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">A</span>, B {\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">baz</span><span class=\"hljs-params\">()</span>;\n}\n</code></pre><p>So <code>C</code> inherits <code>foo()</code> from <code>A</code> and <code>bar()</code> from <code>B</code>.</p>\n<h2>Hndeling method coflicts</h2>\n<h3>Same Method Signature = No Conflict</h3>\n<p>When interfaces have methods with identical signatures, there&#39;s no problem:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">A</span> { <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doSomething</span><span class=\"hljs-params\">()</span>; }\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">B</span> { <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doSomething</span><span class=\"hljs-params\">()</span>; }\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">C</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">A</span>, B { } <span class=\"hljs-comment\">// No conflict</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">C</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doSomething</span><span class=\"hljs-params\">()</span> {\n        System.out.println(<span class=\"hljs-string\">&quot;Single implementation satisfies both&quot;</span>);\n    }\n}\n</code></pre><p>The compiler sees them as <strong>one method contract</strong>.</p>\n<h3>Different Signatures = Method Overloading</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">A</span> { <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doSomething</span><span class=\"hljs-params\">()</span>; }\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">B</span> { <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doSomething</span><span class=\"hljs-params\">(String msg)</span>; }\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">C</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">A</span>, B { }\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">C</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doSomething</span><span class=\"hljs-params\">()</span> { System.out.println(<span class=\"hljs-string\">&quot;No args&quot;</span>); }\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">doSomething</span><span class=\"hljs-params\">(String msg)</span> { System.out.println(msg); }\n}\n</code></pre><h3>Default Method Conflicts (Java 8+)</h3>\n<p>When interfaces have conflicting default methods, you <strong>must</strong> resolve the conflict:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">A</span> {\n    <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">hello</span><span class=\"hljs-params\">()</span> { System.out.println(<span class=\"hljs-string\">&quot;Hello from A&quot;</span>); }\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">B</span> {\n    <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">hello</span><span class=\"hljs-params\">()</span> { System.out.println(<span class=\"hljs-string\">&quot;Hello from B&quot;</span>); }\n}\n\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">C</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">A</span>, B {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">hello</span><span class=\"hljs-params\">()</span> {\n        A.<span class=\"hljs-built_in\">super</span>.hello(); <span class=\"hljs-comment\">// Choose A&#x27;s, B&#x27;s, or write custom implementation</span>\n    }\n}\n</code></pre><h2>Interface evolution through java versions</h2>\n<h3>Pre-Java 8: Pure Contracts</h3>\n<ul>\n<li>Only abstract methods (implicitly <code>public abstract</code>)</li>\n<li>Only <code>public static final</code> constants</li>\n<li>No implemented methods allowed</li>\n</ul>\n<h3>Java 8: Default and Static Methods</h3>\n<p>Interfaces can now have:</p>\n<ul>\n<li><strong>Default methods</strong>: Provide fallback implementations</li>\n<li><strong>Static methods</strong>: Utility methods belonging to the interface</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Vehicle</span> {\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">move</span><span class=\"hljs-params\">()</span>; <span class=\"hljs-comment\">// abstract method</span>\n\n    <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">honk</span><span class=\"hljs-params\">()</span> {  <span class=\"hljs-comment\">// default method</span>\n        System.out.println(<span class=\"hljs-string\">&quot;Beep!&quot;</span>);\n    }\n\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">serviceInfo</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-comment\">// static method</span>\n        System.out.println(<span class=\"hljs-string\">&quot;Service required every 6 months&quot;</span>);\n    }\n}\n</code></pre><h3>Java 9+: Private Methods</h3>\n<p>Added <strong>private methods</strong> for organizing code within interfaces:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Calculator</span> {\n    <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">addAndLog</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> {\n        logOperation(<span class=\"hljs-string\">&quot;Addition&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> a + b;\n    }\n\n    <span class=\"hljs-keyword\">default</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">subtractAndLog</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b)</span> {\n        logOperation(<span class=\"hljs-string\">&quot;Subtraction&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> a - b;\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">logOperation</span><span class=\"hljs-params\">(String operation)</span> { <span class=\"hljs-comment\">// Helper method</span>\n        System.out.println(<span class=\"hljs-string\">&quot;Performing: &quot;</span> + operation);\n    }\n}\n</code></pre><h2>Dependency injection patterns</h2>\n<h3>Three Types of Dependency Injection</h3>\n<ol>\n<li><strong>Constructor Injection</strong> (recommended):</li>\n</ol>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TaxReport</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> TaxCalculator calculator;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">TaxReport</span><span class=\"hljs-params\">(TaxCalculator calculator)</span> {\n        <span class=\"hljs-built_in\">this</span>.calculator = calculator;\n    }\n}\n</code></pre><ol start=\"2\">\n<li>Setter Injection:</li>\n</ol>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TaxReport</span> {\n    <span class=\"hljs-keyword\">private</span> TaxCalculator calculator;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setTaxCalculator</span><span class=\"hljs-params\">(TaxCalculator calculator)</span> {\n        <span class=\"hljs-built_in\">this</span>.calculator = calculator;\n    }\n}\n</code></pre><ol start=\"3\">\n<li>Method Injection:</li>\n</ol>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TaxReport</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">generateReport</span><span class=\"hljs-params\">(TaxCalculator calculator)</span> {\n        <span class=\"hljs-comment\">// Use calculator for this specific operation</span>\n    }\n}\n</code></pre><h3>Benefits of Dependency Injection</h3>\n<ul>\n<li><strong>Flexibility</strong>: Easy to swap implementations</li>\n<li><strong>Testability</strong>: Can inject mock objects for testing</li>\n<li><strong>Extensibility</strong>: Add new implementations without changing existing code</li>\n<li><strong>Loose Coupling</strong>: Classes depend on abstractions, not concrete implementations</li>\n</ul>\n<h2>Desig principles and best practices</h2>\n<h3>Interface Segregation Principle (ISP)</h3>\n<p>Avoid creating &quot;god interfaces&quot; with too many methods. Split large interfaces into smaller, focused ones:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// ❌ Bad: Fat interface</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">VehicleOperations</span> {\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">drive</span><span class=\"hljs-params\">()</span>;\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">()</span>;\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">swim</span><span class=\"hljs-params\">()</span>;\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">refuel</span><span class=\"hljs-params\">()</span>;\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">recharge</span><span class=\"hljs-params\">()</span>;\n}\n\n<span class=\"hljs-comment\">// ✅ Good: Segregated interfaces</span>\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Drivable</span> { <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">drive</span><span class=\"hljs-params\">()</span>; }\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Flyable</span> { <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">fly</span><span class=\"hljs-params\">()</span>; }\n<span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">Rechargeable</span> { <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">recharge</span><span class=\"hljs-params\">()</span>; }\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Car</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Drivable</span>, Rechargeable {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">drive</span><span class=\"hljs-params\">()</span> { System.out.println(<span class=\"hljs-string\">&quot;Car is driving&quot;</span>); }\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">recharge</span><span class=\"hljs-params\">()</span> { System.out.println(<span class=\"hljs-string\">&quot;Car is charging&quot;</span>); }\n    <span class=\"hljs-comment\">// No need to implement fly() or swim()</span>\n}\n</code></pre><h3>When to Use Abstract Classes vs Interfaces</h3>\n<p>Use Abstract Classes When:</p>\n<ul>\n<li>You need to share code between related classes</li>\n<li>You have common state (fields) to share</li>\n<li>Classes have a clear &quot;is-a&quot; relationship</li>\n<li>You want to provide partial implementations</li>\n</ul>\n<p>Use Interfaces When:</p>\n<ul>\n<li>You need multiple inheritance</li>\n<li>Defining contracts for unrelated classes</li>\n<li>You want loose coupling and flexibility</li>\n<li>Building for testability</li>\n</ul>\n<h3>Modern Interface Design Guidelines</h3>\n<p>Static Methods in Interfaces:</p>\n<ul>\n<li>Belong to the interface namespace, not implementing classes</li>\n<li>Called via <code>InterfaceName.methodName()</code></li>\n<li>Consider if utility classes might be cleaner</li>\n</ul>\n<p>Default Methods:</p>\n<ul>\n<li>Use sparingly to avoid blurring interface purpose</li>\n<li>Good for interface evolution without breaking existing code</li>\n<li>Don&#39;t overuse - interfaces should primarily define contracts</li>\n</ul>\n<p>Private Methods:</p>\n<ul>\n<li>Useful for organizing code within the interface</li>\n<li>Help reduce duplication in default methods</li>\n<li>Only visible within the same interface</li>\n</ul>\n<h2>Practical example : Multiple implementations</h2>\n<p>Here&#39;s how you can create multiple implementations and swap them easily:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// Different tax calculation strategies</span>\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TaxCal</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">TaxCalculator</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">double</span> taxableIncome;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">TaxCal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> taxableIncome)</span> {\n        <span class=\"hljs-built_in\">this</span>.taxableIncome = taxableIncome;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">calculateTax</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> taxableIncome * <span class=\"hljs-number\">0.3</span>; <span class=\"hljs-comment\">// Standard rate</span>\n    }\n}\n\n<span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TaxCal2020</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">TaxCalculator</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">double</span> taxableIncome;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">TaxCal2020</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> taxableIncome)</span> {\n        <span class=\"hljs-built_in\">this</span>.taxableIncome = taxableIncome;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">calculateTax</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> taxableIncome * <span class=\"hljs-number\">0.25</span>; <span class=\"hljs-comment\">// 2020 tax rules</span>\n    }\n}\n\n<span class=\"hljs-comment\">// Usage - easy to swap implementations</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">TaxCalculator</span> <span class=\"hljs-variable\">calc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TaxCal</span>(<span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-type\">TaxReport</span> <span class=\"hljs-variable\">tr</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TaxReport</span>(calc);\n    tr.printReport(); <span class=\"hljs-comment\">// Uses standard calculation</span>\n\n    <span class=\"hljs-type\">TaxCalculator</span> <span class=\"hljs-variable\">calc2020</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TaxCal2020</span>(<span class=\"hljs-number\">1000</span>);\n    <span class=\"hljs-type\">TaxReport</span> <span class=\"hljs-variable\">tr2020</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TaxReport</span>(calc2020);\n    tr2020.printReport(); <span class=\"hljs-comment\">// Uses 2020 rules</span>\n}\n</code></pre><h2>Important interview insights</h2>\n<h3>The Classic &quot;Interface vs Abstract Class&quot; Question</h3>\n<p>This is often considered an <strong>outdated interview question</strong> for several reasons:</p>\n<p><strong>Why it&#39;s problematic:</strong></p>\n<ul>\n<li>Shows lack of modern interviewing experience</li>\n<li>Focuses on memorization rather than practical problem-solving</li>\n<li>Doesn&#39;t reflect real-world development challenges</li>\n<li>Many modern languages don&#39;t even have these concepts</li>\n</ul>\n<p><strong>What matters more in 2025:</strong></p>\n<ul>\n<li>Understanding appropriate design patterns</li>\n<li>Building maintainable, testable applications</li>\n<li>Knowing when to use loose coupling</li>\n<li>Practical problem-solving skills</li>\n</ul>\n<p><strong>The Real Answer:</strong></p>\n<ul>\n<li><strong>Interfaces</strong> = contracts for loose coupling and flexibility</li>\n<li><strong>Abstract classes</strong> = partially implemented classes for sharing code between related classes</li>\n<li><strong>Focus on</strong> = choosing the right tool for the design problem, not memorizing differences</li>\n</ul>\n<h2>KEY TAKEAWAYS</h2>\n<h3>Core Principles</h3>\n<ol>\n<li><strong>Program against interfaces, not implementations</strong> - enables flexibility and testability</li>\n<li><strong>Use dependency injection</strong> to reduce coupling and improve testability</li>\n<li><strong>Keep interfaces focused</strong> - follow Interface Segregation Principle</li>\n<li><strong>Interfaces define contracts</strong> - what classes can do, not how they do it</li>\n</ol>\n<h3>Design Recommendations</h3>\n<ol>\n<li><strong>Keep interfaces clean</strong> - primarily for defining contracts</li>\n<li><strong>Use abstract classes for shared code</strong> between related classes</li>\n<li><strong>Prefer composition over inheritance</strong> when possible</li>\n<li><strong>Avoid overusing default methods</strong> - they can blur interface purpose</li>\n<li><strong>Use DI frameworks</strong> (like Spring) for complex applications</li>\n</ol>\n<h3>Benefits of This Approach</h3>\n<ul>\n<li><strong>Loose Coupling</strong>: Components depend on abstractions, not concrete classes</li>\n<li><strong>Extensibility</strong>: Easy to add new implementations without changing existing code</li>\n<li><strong>Testability</strong>: Can inject mock objects for unit testing</li>\n<li><strong>Maintainability</strong>: Changes in one implementation don&#39;t affect others</li>\n<li><strong>Flexibility</strong>: Can swap implementations at runtime</li>\n</ul>\n<p>Remember: Good design is about <strong>clarity of responsibility</strong>. Interfaces should define contracts, abstract classes should share code, and utility classes should contain common helpers. Don&#39;t mix these roles unnecessarily.</p>\n","markdown":"# **Introduction to Object-Oriented Programming (OOP) in Java**\n\nWelcome to the second part of our Java refresher course.\nIn this section, we’ll start exploring **Object-Oriented Programming (OOP)** — the most widely used programming paradigm in Java.\n\n---\n\n## What is OOP?\n\nOOP (Object-Oriented Programming) is just a **programming paradigm** — a style of writing code.\nIt’s not the only one:\n\n- **Procedural** (C, early Java)\n- **Functional** (Java Streams, Haskell, Scala)\n- **Event-driven** (GUIs, message-based systems)\n- **Object-oriented** (Java, C++, C#)\n\n👉 In OOP, we **combine data and behavior into a single unit called an object**.\n\nThis differs from functional programming, which separates data and behavior.\n\n⚡ Important:\n\n- Don’t get stuck on paradigms. Each has its strengths.\n- Java is classically OOP-focused, but modern approaches (like Go or Rust) use different models.\n- Use the style that best **solves your problem**.\n\n---\n\n## The Four Pillars of OOP\n\nIn this section of the course, we’ll cover:\n\n- **Encapsulation** – bundling data + methods, controlling access\n- **Abstraction** – hiding details, showing only essentials\n- **Inheritance** – reusing existing code by extending classes\n- **Polymorphism** – objects behaving differently under the same interface\n\nAdditionally, we’ll learn about:\n\n- **Classes** (the building blocks of OOP)\n- **Constructors**\n- **Getters & Setters**\n- **Method Overloading**\n- **Interfaces**\n- **Coupling & Dependency** between classes\n\n---\n\n## Classes and Objects\n\nA **class** is like a **blueprint** or **type**.\n\nExample:\n\n```java\nclass Car {\n    String model;\n    int year;\n}\n```\n\nWhen we create something from this class, we get an **object (or instance)**:\n\n```java\nCar myCar = new Car();\n```\n\n---\n\n## Memory Model in Java\n\nJava memory is divided into:\n\n- **Stack** – stores **primitive values** and **object references** (addresses).\n- **Heap** – stores the actual **objects** (created with `new`).\n\n🔑 Key points:\n\n- When a method ends, stack variables are removed.\n- If no references point to an object in the heap, the **Garbage Collector** will eventually clean it up.\n\n---\n\n## Example: Our First Class\n\nHere’s a small example:\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        // Create an instance of TextBox\n        TextBox tb = new TextBox(\"BOX1\");\n\n        // Print text in lowercase\n        System.out.println(tb.text.toLowerCase());\n    }\n\n    static class TextBox {\n        // Field\n        public String text;\n\n        // Constructor\n        public TextBox(String value) {\n            this.text = value;\n        }\n\n        // Setter method\n        public void setText(String text) {\n            this.text = text;\n        }\n\n        // Clear method\n        public void clear() {\n            this.text = \"\";\n        }\n    }\n}\n```\n\n---\n\n### Explanation:\n\n- `TextBox` is a **class** (blueprint).\n- `text` is a **field** (data stored in the object).\n- The **constructor** initializes the object.\n- `setText` and `clear` are **methods** that define behavior.\n- In `main`, we create an **object** (`tb`) using `new TextBox(\"BOX1\")`.\n\n---\n\n# From Procedural to Object-Oriented Programming\n\nIn the last lesson, we introduced **classes** and saw how objects bundle **data + behavior**.\n\nNow, let’s take a simple example — calculating an employee’s wage — and see how it looks:\n\n1. First, in a **procedural style** (functions + variables, separate).\n2. Then, in **OOP style** (using a class that encapsulates data + behavior).\n\n---\n\n## Procedural Approach\n\nIn a procedural style, we might write something like this:\n\n```java\npublic class ProceduralDemo {\n    public static void main(String[] args) {\n        int baseSalary = 5000;\n        int hourlyRate = 50;\n        int extraHours = 10;\n\n        int wage = calculateWage(baseSalary, hourlyRate, extraHours);\n        System.out.println(wage);\n    }\n\n    public static int calculateWage(int base, int hourlyRate, int extraHours) {\n        return base + extraHours * hourlyRate;\n    }\n}\n```\n\n👉 Here, we:\n\n- Store data (`baseSalary`, `hourlyRate`, `extraHours`) in **separate variables**.\n- Write a **standalone function** (`calculateWage`) to compute the result.\n\nThis works, but as the program grows, managing all these **loose variables** gets messy.\n\n---\n\n## OOP Approach\n\nIn OOP, we bundle the **data** (like salary and hourly rate) and the **functionality** (like calculating wage) inside a single **class**.\n\n```java\npublic class Procedural {\n    public static void main(String[] args) {\n        Employee e = new Employee();\n        int wage = e.calculateWage(12);\n\n        e.setBaseSalary(6000); // using setter\n        System.out.println(wage);\n    }\n\n    static class Employee {\n        private int baseSalary = 5000;\n        public int hourlyRate = 50;\n\n        public int getBaseSalary() {\n            return baseSalary;\n        }\n\n        public void setBaseSalary(int baseSalary) {\n            if (baseSalary <= 0) {\n                throw new IllegalArgumentException(\"Base salary cannot be negative or zero\");\n            }\n            this.baseSalary = baseSalary;\n        }\n\n        public int calculateWage(int extraHours) {\n            return this.baseSalary + this.hourlyRate * extraHours;\n        }\n    }\n}\n```\n\n---\n\n### What Changed?\n\n1. **Encapsulation**:\n   - We made `baseSalary` **private** so it cannot be modified directly.\n   - We control changes using **getters and setters**.\n   - This allows us to enforce rules (e.g., salary cannot be `0` or negative).\n\n2. **Methods inside the class**:\n   - Instead of writing a separate `calculateWage` function, it is now part of `Employee`.\n   - This makes sense because \"wage calculation\" is **behavior** of an Employee.\n\n---\n\n## Why Encapsulation Matters\n\nLet’s say we didn’t hide `baseSalary` and left it public:\n\n```java\ne.baseSalary = -1000;  // valid in procedural style, but meaningless!\n```\n\nThat would allow invalid states.\nBy making it **private** and controlling it with a setter, we ensure data integrity:\n\n```java\npublic void setBaseSalary(int baseSalary) {\n    if (baseSalary <= 0) {\n        throw new IllegalArgumentException(\"Base salary cannot be negative or zero\");\n    }\n    this.baseSalary = baseSalary;\n}\n```\n\n---\n\n✅ With this, we’ve transitioned from procedural code → OOP design.\nNext, we’ll look at **constructors, overloading, and further encapsulation improvements**.\n\n---\n\n# **Abstraction, Coupling, Constructors, and Static Members**\n\n## Abstraction\n\n- **Definition:** Abstraction is simply reducing complexity by hiding unnecessary details.\n- Instead of exposing raw class members (fields) to the outside world, we expose **methods** that control how other code interacts with the class.\n- This hides implementation details and protects the integrity of the class.\n\n---\n\n## Coupling\n\n- **Coupling** happens when classes depend on each other.\n- Coupling is not always bad, but if classes are **tightly coupled**, then changing one class may force you to change many others.\n- By reducing coupling, we make our code more **maintainable** and **flexible**.\n\n---\n\n## Example: Employee Class\n\nInstead of exposing fields directly, we use **getters and setters** with validation.\n\n```java\npublic class Employee {\n\n    private int hourlyRate = 50;\n    private int baseSalary = 5000;\n\n    public int getBaseSalary() {\n        return baseSalary;\n    }\n\n    public void setBaseSalary(int baseSalary) {\n        if (baseSalary <= 0) {\n            throw new IllegalArgumentException(\"Base salary cannot be negative or zero\");\n        }\n        this.baseSalary = baseSalary;\n    }\n\n    public int calculateWage(int extraHours) {\n        return this.baseSalary + this.hourlyRate * extraHours;\n    }\n}\n```\n\n### Key points:\n\n- We made `baseSalary` **private** to prevent direct modification.\n- We added a **setter method** with validation to avoid putting the class into a “bad state.”\n- We exposed a **method** (`calculateWage`) to perform work instead of letting the outside code do the calculation.\n\n---\n\n## Constructors\n\nConstructors are special methods that initialize objects when they are created.\nThey help us avoid forgetting to initialize important values.\n\n```java\nclass Employee {\n    private int baseSalary;\n    private int hourlyRate;\n\n    // Constructor with parameters\n    public Employee(int baseSalary, int hourlyRate) {\n        this.baseSalary = baseSalary;\n        this.hourlyRate = hourlyRate;\n    }\n\n    // Overloaded constructor with default values\n    public Employee() {\n        this.baseSalary = 5000;\n        this.hourlyRate = 10;\n    }\n}\n```\n\n### Notes:\n\n- By providing multiple constructors (**constructor overloading**), we can simulate “default parameters” in Java.\n- Unlike languages like C#, C++, Go, or JavaScript, Java does not support default parameter values directly. Overloading is the workaround.\n\n---\n\n## Static Members\n\n- A class can have **instance members** (belong to an object) or **static members** (belong to the class itself).\n- **Static methods** are useful when we don’t need an object, for example the `main` method:\n\n```java\npublic class Program {\n    public static void main(String[] args) {\n        // no object needed because main is static\n        System.out.println(\"Hello OOP\");\n    }\n}\n```\n\n### When to use static:\n\n- When a value or behavior should be **shared across all objects**.\n- When you want to provide **utility functions** (e.g., `Math.sqrt()`).\n\n---\n\n## Transition\n\nWe’ve now seen:\n\n- How abstraction helps hide details.\n- How to reduce coupling between classes.\n- How constructors and method overloading make our classes safer and more flexible.\n- The difference between instance and static members.\n\n👉 **Next time, we’ll look at _inheritance_** — how one class can derive from another and reuse its code.\n\n---\n\n# **Inheritance, Casting, Abstract Classes, and Polymorphism**\n\nIn the previous section, we talked about the **basics of OOP** – classes, objects, encapsulation, abstraction, and methods.\nNow we’re going to push further into **how objects relate to each other** through inheritance, casting, abstract classes, and polymorphism.\n\n---\n\n## Upcasting and Downcasting\n\nIn Java, when you have a class hierarchy:\n\n```java\nclass UiControl { ... }\nclass TextBox extends UiControl { ... }\n```\n\n- **Upcasting** → assigning a subclass (`TextBox`) to a superclass (`UiControl`) reference.\n  ✅ Always safe.\n- **Downcasting** → forcing a superclass reference back into a subclass.\n  ⚠️ Dangerous, only works if the object is _actually_ that subclass at runtime.\n\n```java\nUiControl control = new TextBox(true); // upcasting, safe\nTextBox tb = (TextBox) control;        // downcasting, works\n\nUiControl control2 = new UiControl(true);\nTextBox tb2 = (TextBox) control2;      // ❌ runtime error\n```\n\n👉 Always check with `instanceof` or `getClass()` before downcasting.\n\n---\n\n## Abstract Classes\n\nSometimes, we want to define a **general concept** without being able to create it directly.\n\nFor example, `UiControl` is an abstract idea – we don’t really have a generic \"control\" in a UI, but we do have specific controls like `TextBox` or `CheckBox`.\n\n```java\nabstract class UiControl {\n    private boolean isEnabled = true;\n\n    public UiControl(boolean flag) {\n        this.isEnabled = flag;\n    }\n\n    public boolean isEnabled() { return isEnabled; }\n    public void setEnabled(boolean enabled) { this.isEnabled = enabled; }\n\n    public abstract void draw(); // forces subclasses to implement\n}\n```\n\n- You **cannot instantiate** an abstract class.\n- Subclasses **must** implement the abstract methods.\n\n---\n\n## Final Classes and Methods\n\n- A **final class** cannot be extended.\n- A **final method** cannot be overridden.\n\nRarely used, but important for ensuring immutability and security.\n\n---\n\n## Polymorphism\n\nPolymorphism means **“many forms.”**\n\nWhen you call a method on a superclass reference, the JVM will run the **actual subclass implementation** at runtime.\n\n```java\ninterface GeometricShape {\n    void draw();\n}\n\nclass Circle implements GeometricShape {\n    public void draw() { System.out.println(\"This is a circle\"); }\n}\n\nclass Square implements GeometricShape {\n    public void draw() { System.out.println(\"This is a square\"); }\n}\n```\n\nNow if we write:\n\n```java\nGeometricShape[] shapes = { new Circle(), new Square() };\n\nfor (GeometricShape s : shapes) {\n    s.draw(); // Polymorphism in action\n}\n```\n\nEach object runs its own implementation, even though the reference type is the interface.\n\n---\n\n## Comparing Objects (`equals`)\n\nBy default, the `equals` method compares object **references**, not actual content.\n\nExample:\n\n```java\nclass Point {\n    private int x, y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;                // same reference\n        if (obj == null || getClass() != obj.getClass()) return false;\n\n        Point other = (Point) obj;                   // safe cast\n        return this.x == other.x && this.y == other.y;\n    }\n}\n```\n\nNow:\n\n```java\nPoint p1 = new Point(1, 2);\nPoint p2 = new Point(1, 2);\n\nSystem.out.println(p1.equals(p2)); // true ✅ (compares content)\nSystem.out.println(p1 == p2);      // false ❌ (different references)\n```\n\n---\n\n## Putting It All Together\n\nHere’s a summary of what we covered with live code:\n\n```java\npublic class UpCastingDowncasting {\n    public static void main(String[] args) {\n        GeometricShape[] shapes = { new Circle(), new Square() };\n        for (GeometricShape sh : shapes) sh.draw();\n    }\n}\n```\n\n- `UiControl` → base (abstract) concept.\n- `TextBox` → subclass (concrete).\n- Upcasting allows `TextBox` to be treated as `UiControl`.\n- Downcasting requires checks.\n- Interfaces allow polymorphism across unrelated classes.\n- Override `equals` to compare **contents**, not references.\n\n---\n\n✅ Next lesson: **Interfaces and Dependency Injection**\n\n---\n\n<!---->\n<!-- # C-9 📘 Lecture: Interfaces and Dependency Injection in Java -->\n<!---->\n<!-- Today, we’re going to dive into **interfaces** in Java, understand **why they exist**, and learn how they help us build **loosely coupled, extensible, and testable applications**. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 1. Why Interfaces? (The Restaurant Analogy) -->\n<!---->\n<!-- Imagine you own a restaurant. You hire a chef named John. John is great, but one day John gets sick. If your restaurant only works because *John* is there, your business is in trouble. -->\n<!---->\n<!-- But what if instead, you said: -->\n<!---->\n<!-- > “I don’t care who the chef is, as long as they can cook.” -->\n<!---->\n<!-- That’s exactly what interfaces are about. We don’t tie ourselves to a **specific person (class)** — we depend on a **contract (interface)**. -->\n<!---->\n<!-- This way, our application can keep running no matter who is “in the kitchen.” -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 2. The Problem of Tight Coupling -->\n<!---->\n<!-- Let’s look at some code that is **tightly coupled**: -->\n<!---->\n<!-- ```java -->\n<!-- static class TaxReport { -->\n<!--     private TaxCal taxCal; -->\n<!---->\n<!--     public TaxReport() { -->\n<!--         taxCal = new TaxCal(1000); -->\n<!--     } -->\n<!-- } -->\n<!---->\n<!-- static class TaxCal { -->\n<!--     private double taxableIncome; -->\n<!---->\n<!--     public TaxCal(double taxableIncome) { -->\n<!--         this.taxableIncome = taxableIncome; -->\n<!--     } -->\n<!---->\n<!--     public double calculateTax() { -->\n<!--         return taxableIncome * 0.3; -->\n<!--     } -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- Here’s the issue: -->\n<!---->\n<!-- * `TaxReport` directly depends on `TaxCal`. -->\n<!-- * If we change the `TaxCal` implementation, we might break `TaxReport`. -->\n<!-- * If we want to introduce a new tax rule (e.g., 2020 tax laws), we’d have to rewrite parts of `TaxReport`. -->\n<!---->\n<!-- This is **tight coupling**, and it makes code brittle and hard to maintain. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 3. Breaking the Coupling with Interfaces -->\n<!---->\n<!-- Now let’s introduce an **interface** to reduce coupling: -->\n<!---->\n<!-- ```java -->\n<!-- interface TaxCalculator { -->\n<!--     double calculateTax(); -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- Instead of depending on a *concrete class*, `TaxReport` now depends on this *contract*: -->\n<!---->\n<!-- ```java -->\n<!-- static class TaxReport { -->\n<!--     private TaxCalculator taxCal; -->\n<!---->\n<!--     // Constructor Injection -->\n<!--     public TaxReport(TaxCalculator tc) { -->\n<!--         taxCal = tc; -->\n<!--     } -->\n<!---->\n<!--     public void printReport() { -->\n<!--         System.out.println(taxCal.calculateTax()); -->\n<!--     } -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- Notice: -->\n<!---->\n<!-- * `TaxReport` doesn’t care *which* `TaxCalculator` it’s given. -->\n<!-- * As long as the class implements `TaxCalculator`, `TaxReport` is happy. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 4. Multiple Implementations -->\n<!---->\n<!-- Now we can write different tax calculators without breaking `TaxReport`: -->\n<!---->\n<!-- ```java -->\n<!-- static class TaxCal implements TaxCalculator { -->\n<!--     private double taxableIncome; -->\n<!---->\n<!--     public TaxCal(double taxableIncome) { -->\n<!--         this.taxableIncome = taxableIncome; -->\n<!--     } -->\n<!---->\n<!--     @Override -->\n<!--     public double calculateTax() { -->\n<!--         return taxableIncome * 0.3; -->\n<!--     } -->\n<!-- } -->\n<!---->\n<!-- static class TaxCal2020 implements TaxCalculator { -->\n<!--     private double taxableIncome; -->\n<!---->\n<!--     public TaxCal2020(double taxableIncome) { -->\n<!--         this.taxableIncome = taxableIncome; -->\n<!--     } -->\n<!---->\n<!--     @Override -->\n<!--     public double calculateTax() { -->\n<!--         return taxableIncome * 0.25;  // new rules for 2020 -->\n<!--     } -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- Now `TaxReport` can work with **any** tax calculator: -->\n<!---->\n<!-- ```java -->\n<!-- public static void main(String[] args) { -->\n<!--     TaxCalculator calc = new TaxCal(1000); -->\n<!--     TaxReport tr = new TaxReport(calc); -->\n<!--     tr.printReport(); -->\n<!---->\n<!--     TaxCalculator calc2020 = new TaxCal2020(1000); -->\n<!--     TaxReport tr2020 = new TaxReport(calc2020); -->\n<!--     tr2020.printReport(); -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 5. Dependency Injection -->\n<!---->\n<!-- What we just did is called **Dependency Injection (DI)**. -->\n<!---->\n<!-- Instead of `TaxReport` creating its own dependencies, we **inject** them from outside. -->\n<!-- There are three main ways to inject dependencies: -->\n<!---->\n<!-- 1. **Constructor Injection** (most common, what we used) -->\n<!-- 2. **Setter Injection** (pass a dependency via a setter method) -->\n<!-- 3. **Method Injection** (pass a dependency as a parameter to a method call) -->\n<!---->\n<!-- In real projects, you won’t manually manage all dependencies. -->\n<!-- Instead, you’ll often use a **DI Framework** like **Spring** to do this for you automatically. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 6. Interface Segregation -->\n<!---->\n<!-- One last point: -->\n<!---->\n<!-- If you create a huge “god interface” with too many methods, every implementing class is forced to implement things it doesn’t care about. -->\n<!---->\n<!-- That’s bad design. -->\n<!---->\n<!-- Instead, follow the **Interface Segregation Principle (ISP)**: -->\n<!---->\n<!-- > Split large interfaces into smaller, more focused ones. -->\n<!---->\n<!-- For example: -->\n<!---->\n<!-- ```java -->\n<!-- interface Drivable { -->\n<!--     void drive(); -->\n<!-- } -->\n<!---->\n<!-- interface Flyable { -->\n<!--     void fly(); -->\n<!-- } -->\n<!---->\n<!-- class Car implements Drivable { -->\n<!--     public void drive() { System.out.println(\"Car is driving\"); } -->\n<!-- } -->\n<!---->\n<!-- class Plane implements Drivable, Flyable { -->\n<!--     public void drive() { System.out.println(\"Plane is taxiing\"); } -->\n<!--     public void fly() { System.out.println(\"Plane is flying\"); } -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- This way, classes only implement what they actually need. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 7. A Note on Default, Private, and Static Methods in Interfaces -->\n<!---->\n<!-- Since Java 8, interfaces can have `default` and `static` methods. -->\n<!-- Since Java 9, they can even have `private` methods. -->\n<!---->\n<!-- Personally, I recommend being cautious here. Why? -->\n<!---->\n<!-- * An interface’s purpose is to define a **contract**. -->\n<!-- * Putting too much code inside an interface can blur the line between **contracts** and **implementations**. -->\n<!-- * If you need to share common logic between multiple classes, an **abstract class** that implements the interface is often a cleaner design. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## ✅ Summary -->\n<!---->\n<!-- * **Interfaces** define *what* a class can do, not *how*. -->\n<!-- * They help us build **loosely coupled, extensible, and testable applications**. -->\n<!-- * **Dependency Injection** means passing dependencies instead of creating them internally. -->\n<!-- * Use frameworks like **Spring** for large-scale projects. -->\n<!-- * Apply the **Interface Segregation Principle** to avoid “fat” interfaces. -->\n<!-- * Be careful with `default`, `static`, and `private` methods inside interfaces — prefer abstract classes for shared logic. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- 👉 And that’s interfaces in Java. -->\n<!-- Next time, we’ll look at how interfaces and **abstract classes** work together to design even more flexible systems. -->\n<!---->\n<!-- --- -->\n<!---->\n\n# Java Interfaces and Inheritance Guide\n\n## Why interfaces exists ?- THE BIG PICTURE\n\n### The Restaurant Analogy\n\nImagine you own a restaurant and hire a chef named John. John is great, but what happens when John gets sick? If your restaurant only works because _John_ is there, your business is in trouble.\n\nBut what if instead, you said: _\"I don't care who the chef is, as long as they can cook.\"_\n\nThat's exactly what interfaces are about. We don't tie ourselves to a **specific person (class)** — we depend on a **contract (interface)**. This way, our application can keep running no matter who is \"in the kitchen.\"\n\n### The Problem: **Tight Coupling**\n\nLet's look at code that is **tightly coupled**:\n\n```java\nstatic class TaxReport {\n    private TaxCal taxCal;\n\n    public TaxReport() {\n        taxCal = new TaxCal(1000); // Directly creates dependency\n    }\n}\n\nstatic class TaxCal {\n    private double taxableIncome;\n\n    public TaxCal(double taxableIncome) {\n        this.taxableIncome = taxableIncome;\n    }\n\n    public double calculateTax() {\n        return taxableIncome * 0.3;\n    }\n}\n```\n\nProblems with this approach:\n\n- `TaxReport` directly depends on `TaxCal`\n- Changing `TaxCal` might break `TaxReport`\n- Adding new tax rules requires rewriting `TaxReport`\n- Hard to test in isolation\n\n### The Solution: Programming Against Interfaces\n\n```java\ninterface TaxCalculator {\n    double calculateTax();\n}\n\nstatic class TaxReport {\n    private TaxCalculator taxCal;\n\n    // Constructor Injection - depends on contract, not implementation\n    public TaxReport(TaxCalculator tc) {\n        taxCal = tc;\n    }\n\n    public void printReport() {\n        System.out.println(taxCal.calculateTax());\n    }\n}\n```\n\nNow `TaxReport` doesn't care _which_ `TaxCalculator` it receives - it just needs something that fulfills the contract.\n\n## Multiple Inher rules\n\n### Classes: Single Inheritance Only\n\n**Java classes cannot extend multiple classes**. Java only allows **single inheritance**:\n\n```java\nclass A { }\nclass B { }\n// ❌ Not allowed - will cause compile error\nclass C extends A, B { }\n```\n\n### Interfaces: Multiple Inheritance Allowed\n\nUnlike classes, an **interface can extend multiple interfaces**:\n\n```java\ninterface A { void foo(); }\ninterface B { void bar(); }\n\n// ✅ Perfectly valid\ninterface C extends A, B {\n    void baz();\n}\n```\n\nSo `C` inherits `foo()` from `A` and `bar()` from `B`.\n\n## Hndeling method coflicts\n\n### Same Method Signature = No Conflict\n\nWhen interfaces have methods with identical signatures, there's no problem:\n\n```java\ninterface A { void doSomething(); }\ninterface B { void doSomething(); }\ninterface C extends A, B { } // No conflict\n\nclass MyClass implements C {\n    public void doSomething() {\n        System.out.println(\"Single implementation satisfies both\");\n    }\n}\n```\n\nThe compiler sees them as **one method contract**.\n\n### Different Signatures = Method Overloading\n\n```java\ninterface A { void doSomething(); }\ninterface B { void doSomething(String msg); }\ninterface C extends A, B { }\n\nclass MyClass implements C {\n    public void doSomething() { System.out.println(\"No args\"); }\n    public void doSomething(String msg) { System.out.println(msg); }\n}\n```\n\n### Default Method Conflicts (Java 8+)\n\nWhen interfaces have conflicting default methods, you **must** resolve the conflict:\n\n```java\ninterface A {\n    default void hello() { System.out.println(\"Hello from A\"); }\n}\n\ninterface B {\n    default void hello() { System.out.println(\"Hello from B\"); }\n}\n\ninterface C extends A, B {\n    @Override\n    default void hello() {\n        A.super.hello(); // Choose A's, B's, or write custom implementation\n    }\n}\n```\n\n## Interface evolution through java versions\n\n### Pre-Java 8: Pure Contracts\n\n- Only abstract methods (implicitly `public abstract`)\n- Only `public static final` constants\n- No implemented methods allowed\n\n### Java 8: Default and Static Methods\n\nInterfaces can now have:\n\n- **Default methods**: Provide fallback implementations\n- **Static methods**: Utility methods belonging to the interface\n\n```java\ninterface Vehicle {\n    void move(); // abstract method\n\n    default void honk() {  // default method\n        System.out.println(\"Beep!\");\n    }\n\n    static void serviceInfo() { // static method\n        System.out.println(\"Service required every 6 months\");\n    }\n}\n```\n\n### Java 9+: Private Methods\n\nAdded **private methods** for organizing code within interfaces:\n\n```java\ninterface Calculator {\n    default int addAndLog(int a, int b) {\n        logOperation(\"Addition\");\n        return a + b;\n    }\n\n    default int subtractAndLog(int a, int b) {\n        logOperation(\"Subtraction\");\n        return a - b;\n    }\n\n    private void logOperation(String operation) { // Helper method\n        System.out.println(\"Performing: \" + operation);\n    }\n}\n```\n\n## Dependency injection patterns\n\n### Three Types of Dependency Injection\n\n1. **Constructor Injection** (recommended):\n\n```java\nclass TaxReport {\n    private final TaxCalculator calculator;\n\n    public TaxReport(TaxCalculator calculator) {\n        this.calculator = calculator;\n    }\n}\n```\n\n2. Setter Injection:\n\n```java\nclass TaxReport {\n    private TaxCalculator calculator;\n\n    public void setTaxCalculator(TaxCalculator calculator) {\n        this.calculator = calculator;\n    }\n}\n```\n\n3. Method Injection:\n\n```java\nclass TaxReport {\n    public void generateReport(TaxCalculator calculator) {\n        // Use calculator for this specific operation\n    }\n}\n```\n\n### Benefits of Dependency Injection\n\n- **Flexibility**: Easy to swap implementations\n- **Testability**: Can inject mock objects for testing\n- **Extensibility**: Add new implementations without changing existing code\n- **Loose Coupling**: Classes depend on abstractions, not concrete implementations\n\n## Desig principles and best practices\n\n### Interface Segregation Principle (ISP)\n\nAvoid creating \"god interfaces\" with too many methods. Split large interfaces into smaller, focused ones:\n\n```java\n// ❌ Bad: Fat interface\ninterface VehicleOperations {\n    void drive();\n    void fly();\n    void swim();\n    void refuel();\n    void recharge();\n}\n\n// ✅ Good: Segregated interfaces\ninterface Drivable { void drive(); }\ninterface Flyable { void fly(); }\ninterface Rechargeable { void recharge(); }\n\nclass Car implements Drivable, Rechargeable {\n    public void drive() { System.out.println(\"Car is driving\"); }\n    public void recharge() { System.out.println(\"Car is charging\"); }\n    // No need to implement fly() or swim()\n}\n```\n\n### When to Use Abstract Classes vs Interfaces\n\nUse Abstract Classes When:\n\n- You need to share code between related classes\n- You have common state (fields) to share\n- Classes have a clear \"is-a\" relationship\n- You want to provide partial implementations\n\nUse Interfaces When:\n\n- You need multiple inheritance\n- Defining contracts for unrelated classes\n- You want loose coupling and flexibility\n- Building for testability\n\n### Modern Interface Design Guidelines\n\nStatic Methods in Interfaces:\n\n- Belong to the interface namespace, not implementing classes\n- Called via `InterfaceName.methodName()`\n- Consider if utility classes might be cleaner\n\nDefault Methods:\n\n- Use sparingly to avoid blurring interface purpose\n- Good for interface evolution without breaking existing code\n- Don't overuse - interfaces should primarily define contracts\n\nPrivate Methods:\n\n- Useful for organizing code within the interface\n- Help reduce duplication in default methods\n- Only visible within the same interface\n\n## Practical example : Multiple implementations\n\nHere's how you can create multiple implementations and swap them easily:\n\n```java\n// Different tax calculation strategies\nstatic class TaxCal implements TaxCalculator {\n    private double taxableIncome;\n\n    public TaxCal(double taxableIncome) {\n        this.taxableIncome = taxableIncome;\n    }\n\n    @Override\n    public double calculateTax() {\n        return taxableIncome * 0.3; // Standard rate\n    }\n}\n\nstatic class TaxCal2020 implements TaxCalculator {\n    private double taxableIncome;\n\n    public TaxCal2020(double taxableIncome) {\n        this.taxableIncome = taxableIncome;\n    }\n\n    @Override\n    public double calculateTax() {\n        return taxableIncome * 0.25; // 2020 tax rules\n    }\n}\n\n// Usage - easy to swap implementations\npublic static void main(String[] args) {\n    TaxCalculator calc = new TaxCal(1000);\n    TaxReport tr = new TaxReport(calc);\n    tr.printReport(); // Uses standard calculation\n\n    TaxCalculator calc2020 = new TaxCal2020(1000);\n    TaxReport tr2020 = new TaxReport(calc2020);\n    tr2020.printReport(); // Uses 2020 rules\n}\n```\n\n## Important interview insights\n\n### The Classic \"Interface vs Abstract Class\" Question\n\nThis is often considered an **outdated interview question** for several reasons:\n\n**Why it's problematic:**\n\n- Shows lack of modern interviewing experience\n- Focuses on memorization rather than practical problem-solving\n- Doesn't reflect real-world development challenges\n- Many modern languages don't even have these concepts\n\n**What matters more in 2025:**\n\n- Understanding appropriate design patterns\n- Building maintainable, testable applications\n- Knowing when to use loose coupling\n- Practical problem-solving skills\n\n**The Real Answer:**\n\n- **Interfaces** = contracts for loose coupling and flexibility\n- **Abstract classes** = partially implemented classes for sharing code between related classes\n- **Focus on** = choosing the right tool for the design problem, not memorizing differences\n\n## KEY TAKEAWAYS\n\n### Core Principles\n\n1. **Program against interfaces, not implementations** - enables flexibility and testability\n2. **Use dependency injection** to reduce coupling and improve testability\n3. **Keep interfaces focused** - follow Interface Segregation Principle\n4. **Interfaces define contracts** - what classes can do, not how they do it\n\n### Design Recommendations\n\n1. **Keep interfaces clean** - primarily for defining contracts\n2. **Use abstract classes for shared code** between related classes\n3. **Prefer composition over inheritance** when possible\n4. **Avoid overusing default methods** - they can blur interface purpose\n5. **Use DI frameworks** (like Spring) for complex applications\n\n### Benefits of This Approach\n\n- **Loose Coupling**: Components depend on abstractions, not concrete classes\n- **Extensibility**: Easy to add new implementations without changing existing code\n- **Testability**: Can inject mock objects for unit testing\n- **Maintainability**: Changes in one implementation don't affect others\n- **Flexibility**: Can swap implementations at runtime\n\nRemember: Good design is about **clarity of responsibility**. Interfaces should define contracts, abstract classes should share code, and utility classes should contain common helpers. Don't mix these roles unnecessarily.\n","slug":"Oop","title":"Oop","section":"A Quick Refresher","icon":"rotate","filePath":"/home/runner/work/complete-intro-to-spring-and-springBoot/complete-intro-to-spring-and-springBoot/lessons/00-A quick Refresher/C-Oop.md","nextSlug":"/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Advanced java","prevSlug":"/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Java Fundamentals"}},"__N_SSG":true}