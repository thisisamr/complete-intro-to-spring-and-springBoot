{"pageProps":{"post":{"attributes":{},"html":"<h1>Async Java</h1>\n<p>Asynchronous programming is a style of writing code where a long-running operation\nis started, and the main program continues its work <strong>without waiting</strong>\nfor that operation to finish. In Java, this is often managed using the <code>Future</code> interface.</p>\n<h2>The <code>Future</code> Interface: A Placeholder for Results</h2>\n<p>The <strong><code>Future&lt;T&gt;</code></strong> interface is a core component of Java&#39;s concurrency utilities.\nIt represents the <strong>result of an asynchronous computation</strong> that may not have completed yet.\nWhen you start a task on a background thread (e.g., using an <code>ExecutorService</code>), the method returns a <code>Future</code> object immediately. This object is essentially a <strong>placeholder</strong> for the eventual result (of type <code>T</code>).</p>\n<h4><strong>How to Get a Future</strong></h4>\n<p>You typically obtain a <code>Future</code> by submitting a task (a <code>Callable</code>) to an <code>ExecutorService</code>:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">import</span> java.util.concurrent.*;\n\n<span class=\"hljs-comment\">// 1. Create a service to run background threads</span>\n<span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newSingleThreadExecutor();\n\n<span class=\"hljs-comment\">// 2. Submit a long-running task that returns a value (Callable)</span>\nFuture&lt;Integer&gt; futureResult = executor.submit(() -&gt; {\n    System.out.println(<span class=\"hljs-string\">&quot;...Starting background task (simulating 3 seconds)...&quot;</span>);\n    Thread.sleep(<span class=\"hljs-number\">3000</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// The final result</span>\n});\n\n<span class=\"hljs-comment\">// The main thread continues running immediately.</span>\nSystem.out.println(<span class=\"hljs-string\">&quot;Main thread is not blocked yet, doing other work...&quot;</span>);\n</code></pre><h3>Future Interface Methods</h3>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Method</th>\n<th align=\"left\">Purpose</th>\n<th align=\"left\">Key Behavior and Limitation</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong><code>get()</code></strong></td>\n<td align=\"left\">Retrieves the result.</td>\n<td align=\"left\"><strong>BLOCKS</strong> the calling thread indefinitely until the result is available or an exception is thrown. <strong>This is usually what asynchronous code tries to avoid.</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>get(timeout, unit)</code></strong></td>\n<td align=\"left\">Retrieves the result with a time limit.</td>\n<td align=\"left\"><strong>BLOCKS</strong> the calling thread. Throws a <code>TimeoutException</code> if the result isn&#39;t ready in time.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>isDone()</code></strong></td>\n<td align=\"left\">Check if task completed.</td>\n<td align=\"left\">Returns <code>true</code> if the task has finished, whether normally, by cancellation, or with an error.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong><code>cancel(mayInterrupt)</code></strong></td>\n<td align=\"left\">Attempt to cancel the task.</td>\n<td align=\"left\">Attempts to stop the running task. Returns <code>true</code> if the cancellation was successful.</td>\n</tr>\n</tbody></table>\n<p><strong><em>The main limitation of the original <code>Future</code> is that retrieving the result via <code>get()</code> requires the calling thread to stop and wait. For modern, non-blocking asynchronous programming, Java developers prefer the</em></strong> <strong><code>CompletableFuture</code></strong> <strong><em>class (introduced in Java 8), which allows you to chain tasks and react to completion without blocking.</em></strong></p>\n<hr>\n<h2>Understanding Concurrency vs. Parallelism vs. Asynchronous</h2>\n<p>These three terms are often confused. Here’s how they differ:</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">Term</th>\n<th align=\"left\">Meaning</th>\n<th align=\"left\">Requires Multiple Cores?</th>\n<th align=\"left\">Practical Analogy</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>Concurrent</strong></td>\n<td align=\"left\">Many tasks making <strong>progress</strong> over overlapping time periods by rapidly switching between them.</td>\n<td align=\"left\">❌ Not necessarily (can run on one core)</td>\n<td align=\"left\"><strong>One Chef</strong> juggling three orders: they chop for a minute, stir for a minute, then check the oven. All tasks are <em>progressing</em> over time.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Parallel</strong></td>\n<td align=\"left\">Tasks running <strong>literally at the same instant</strong> (simultaneously) on different CPU cores.</td>\n<td align=\"left\">✅ Yes</td>\n<td align=\"left\"><strong>Three Chefs</strong> working on three different orders <strong>at the exact same time</strong> on three different stations.</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>Asynchronous</strong></td>\n<td align=\"left\">A <strong>programming style</strong> where the caller initiates a task and continues its own work, using a <code>Future</code> or callback to handle the result later.</td>\n<td align=\"left\">❌ No (It&#39;s a coding approach)</td>\n<td align=\"left\"><strong>Placing a take-out order</strong> by phone: You hang up and drive to the restaurant. You don&#39;t stay on hold the whole time waiting for the food.</td>\n</tr>\n</tbody></table>\n<h3>Future Interface Methods</h3>\n<ul>\n<li><code>get()</code>: Blocks until result is available (throws checked exceptions)</li>\n<li><code>get(timeout, unit)</code>: Blocks with timeout</li>\n<li><code>isDone()</code>: Check if task completed</li>\n<li><code>cancel(mayInterrupt)</code>: Attempt to cancel the task</li>\n</ul>\n<h2>Understanding Concurrency vs Parallelism vs Asynchronous</h2>\n<h3>Definitions</h3>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Meaning</th>\n<th>Needs Multiple Cores?</th>\n<th>Typical Use</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Parallel</strong></td>\n<td>Tasks run literally at the same time</td>\n<td>✅ Yes</td>\n<td>CPU-bound work (math, image processing)</td>\n</tr>\n<tr>\n<td><strong>Concurrent</strong></td>\n<td>Many tasks progressing in overlapping time</td>\n<td>❌ Not necessarily</td>\n<td>Task scheduling, multitasking</td>\n</tr>\n<tr>\n<td><strong>Asynchronous</strong></td>\n<td>Task runs in background, caller doesn&#39;t wait</td>\n<td>❌ No</td>\n<td>I/O-bound work (network, DB, files)</td>\n</tr>\n</tbody></table>\n<h3>Examples</h3>\n<p><strong>Parallel Processing:</strong></p>\n<pre><code class=\"hljs language-java\">IntStream.range(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>)\n    .parallel()\n    .forEach(i -&gt; System.out.println(i + <span class=\"hljs-string\">&quot; &quot;</span> + Thread.currentThread()));\n</code></pre><p><strong>Concurrent Processing:</strong></p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">pool</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">2</span>);\npool.submit(() -&gt; doWork(<span class=\"hljs-string\">&quot;A&quot;</span>));\npool.submit(() -&gt; doWork(<span class=\"hljs-string\">&quot;B&quot;</span>));\n<span class=\"hljs-comment\">// Tasks overlap in time, may or may not run simultaneously</span>\n</code></pre><p><strong>Asynchronous Processing:</strong></p>\n<pre><code class=\"hljs language-java\">CompletableFuture.runAsync(() -&gt; {\n    delay();\n    System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);\n});\nSystem.out.println(<span class=\"hljs-string\">&quot;I don&#x27;t block!&quot;</span>); <span class=\"hljs-comment\">// Runs immediately</span>\n</code></pre><h3>What Does &quot;Asynchronous&quot; Really Mean?</h3>\n<p>Asynchronous programming is about <strong>non-blocking execution</strong>:</p>\n<ul>\n<li>You start a task</li>\n<li>Your thread continues with other work</li>\n<li>The task completes later and notifies you (via callback, promise, etc.)</li>\n</ul>\n<p>Think of it like ordering coffee:</p>\n<ul>\n<li><strong>Synchronous</strong>: Order coffee → wait → receive coffee → continue</li>\n<li><strong>Asynchronous</strong>: Order coffee → do other things → get notified when ready</li>\n</ul>\n<h2>CompletableFuture: Modern Asynchronous Programming</h2>\n<h3>Introduction</h3>\n<p><code>CompletableFuture</code> is Java&#39;s equivalent to JavaScript Promises. It has three states:</p>\n<ul>\n<li><strong>Pending</strong>: Task is running</li>\n<li><strong>Resolved</strong>: Task completed successfully</li>\n<li><strong>Rejected</strong>: Task failed with an exception</li>\n</ul>\n<h3>Basic Usage</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AsyncExample</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">// Fire and forget</span>\n        show().join(); <span class=\"hljs-comment\">// join() blocks until completion</span>\n\n        <span class=\"hljs-comment\">// With return value</span>\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">value</span> <span class=\"hljs-operator\">=</span> show2().get();\n            System.out.println(<span class=\"hljs-string\">&quot;Returned: &quot;</span> + value);\n        } <span class=\"hljs-keyword\">catch</span> (InterruptedException | ExecutionException e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);\n        }\n    }\n\n    <span class=\"hljs-comment\">// CompletableFuture.runAsync for void tasks</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> CompletableFuture&lt;Void&gt; <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> CompletableFuture.runAsync(() -&gt; {\n            delay();\n            System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);\n        });\n    }\n\n    <span class=\"hljs-comment\">// CompletableFuture.supplyAsync for tasks with return values</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> CompletableFuture&lt;String&gt; <span class=\"hljs-title function_\">show2</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; {\n            delay();\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;hello&quot;</span>;\n        });\n    }\n}\n</code></pre><h3>Building Async APIs</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MailSender</span> {\n    <span class=\"hljs-comment\">// Synchronous method</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">sendMail</span><span class=\"hljs-params\">()</span> {\n        delay();\n        System.out.println(<span class=\"hljs-string\">&quot;mail sent !!!!&quot;</span>);\n    }\n\n    <span class=\"hljs-comment\">// Asynchronous wrapper</span>\n    <span class=\"hljs-keyword\">public</span> CompletableFuture&lt;Void&gt; <span class=\"hljs-title function_\">sendMailAsync</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> CompletableFuture.runAsync(() -&gt; sendMail());\n    }\n}\n\n<span class=\"hljs-comment\">// Usage</span>\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">mailService</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MailSender</span>();\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">future</span> <span class=\"hljs-operator\">=</span> mailService.sendMailAsync();\nSystem.out.println(<span class=\"hljs-string\">&quot;This runs immediately&quot;</span>);\nfuture.join(); <span class=\"hljs-comment\">// Wait for completion</span>\n</code></pre><h2>Chaining Operations</h2>\n<h3>CompletableFuture Chaining Methods</h3>\n<table>\n<thead>\n<tr>\n<th>Method</th>\n<th>Input Lambda</th>\n<th>Returns</th>\n<th>Use Case</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>thenApply(fn)</code></td>\n<td><code>T -&gt; U</code></td>\n<td><code>CompletableFuture&lt;U&gt;</code></td>\n<td>Transform result (sync)</td>\n</tr>\n<tr>\n<td><code>thenApplyAsync(fn)</code></td>\n<td><code>T -&gt; U</code></td>\n<td><code>CompletableFuture&lt;U&gt;</code></td>\n<td>Transform result (async)</td>\n</tr>\n<tr>\n<td><code>thenAccept(consumer)</code></td>\n<td><code>T -&gt; void</code></td>\n<td><code>CompletableFuture&lt;Void&gt;</code></td>\n<td>Consume result, no return</td>\n</tr>\n<tr>\n<td><code>thenAcceptAsync(consumer)</code></td>\n<td><code>T -&gt; void</code></td>\n<td><code>CompletableFuture&lt;Void&gt;</code></td>\n<td>Consume result (async)</td>\n</tr>\n<tr>\n<td><code>thenRun(runnable)</code></td>\n<td><code>() -&gt; void</code></td>\n<td><code>CompletableFuture&lt;Void&gt;</code></td>\n<td>Run after completion</td>\n</tr>\n<tr>\n<td><code>thenCompose(fn)</code></td>\n<td><code>T -&gt; CompletableFuture&lt;U&gt;</code></td>\n<td><code>CompletableFuture&lt;U&gt;</code></td>\n<td>Chain async operations</td>\n</tr>\n</tbody></table>\n<h3>Practical Examples</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CompletableFutureChaining</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">// Transform and consume</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">future</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; <span class=\"hljs-number\">12</span>)\n            .thenApplyAsync(v -&gt; v * <span class=\"hljs-number\">2</span>) <span class=\"hljs-comment\">// Transform: 12 -&gt; 24</span>\n            .thenAcceptAsync(v -&gt; {\n                delay();\n                System.out.println(<span class=\"hljs-string\">&quot;Thread: &quot;</span> + Thread.currentThread().getName());\n                System.out.println(<span class=\"hljs-string\">&quot;Value: &quot;</span> + v);\n            });\n\n        future.join();\n    }\n}\n</code></pre><h3>thenApply vs thenCompose</h3>\n<p><strong>Key Difference:</strong></p>\n<ul>\n<li><code>thenApply</code>: Use when your function returns a <strong>plain value</strong> (<code>T -&gt; U</code>)</li>\n<li><code>thenCompose</code>: Use when your function returns a <strong>CompletableFuture</strong> (<code>T -&gt; CompletableFuture&lt;U&gt;</code>)</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// thenApply - transforms value</span>\nCompletableFuture.supplyAsync(() -&gt; <span class=\"hljs-string\">&quot;User123&quot;</span>)\n    .thenApply(id -&gt; fetchProfileSync(id)) <span class=\"hljs-comment\">// Returns Profile</span>\n    .thenAccept(System.out::println);\n\n<span class=\"hljs-comment\">// thenCompose - chains futures (avoids nesting)</span>\nCompletableFuture.supplyAsync(() -&gt; <span class=\"hljs-string\">&quot;User123&quot;</span>)\n    .thenCompose(id -&gt; fetchProfileAsync(id)) <span class=\"hljs-comment\">// Returns CompletableFuture&lt;Profile&gt;</span>\n    .thenAccept(System.out::println);\n</code></pre><p>Without <code>thenCompose</code>, you&#39;d get <code>CompletableFuture&lt;CompletableFuture&lt;Profile&gt;&gt;</code> (nested futures).</p>\n<h2>Combining Futures</h2>\n<h3>Combining Two Futures</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CombiningFutures</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">// Get price in USD</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">priceInUSD</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; <span class=\"hljs-number\">39</span>);\n\n        <span class=\"hljs-comment\">// Get exchange rate USD -&gt; EGP</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">exchangeRate</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; <span class=\"hljs-number\">50</span>);\n\n        <span class=\"hljs-comment\">// Combine results</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">finalPrice</span> <span class=\"hljs-operator\">=</span> priceInUSD.thenCombine(exchangeRate,\n            (price, rate) -&gt; price * rate);\n\n        System.out.println(<span class=\"hljs-string\">&quot;Final price: &quot;</span> + finalPrice.join());\n\n        <span class=\"hljs-comment\">// More complex example with string parsing</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">priceString</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; <span class=\"hljs-string\">&quot;39usd&quot;</span>);\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">rate</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; <span class=\"hljs-number\">50</span>);\n\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> priceString\n            .thenApply(price -&gt; {\n                <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">cleanPrice</span> <span class=\"hljs-operator\">=</span> price.replace(<span class=\"hljs-string\">&quot;usd&quot;</span>, <span class=\"hljs-string\">&quot;&quot;</span>);\n                <span class=\"hljs-keyword\">return</span> Integer.parseInt(cleanPrice);\n            })\n            .thenCombine(rate, (price, exchangeRate) -&gt; price * exchangeRate);\n\n        System.out.println(<span class=\"hljs-string\">&quot;Parsed result: &quot;</span> + result.join());\n    }\n}\n</code></pre><h3>Working with Multiple Futures</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MultipleFutures</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">f1</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; { delay(); <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>; });\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">f2</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; { delay(); <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>; });\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">f3</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; { delay(); <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span>; });\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">f4</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; { delay(); <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>; });\n\n        <span class=\"hljs-comment\">// Wait for ALL to complete</span>\n        CompletableFuture.allOf(f1, f2, f3, f4).join();\n        System.out.println(<span class=\"hljs-string\">&quot;All completed: &quot;</span> + f1.join());\n\n        <span class=\"hljs-comment\">// Wait for ANY to complete (first wins)</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">slow</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; {\n            delay(<span class=\"hljs-number\">6</span>); <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;slow&quot;</span>;\n        });\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">fast</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; {\n            delay(<span class=\"hljs-number\">1</span>); <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;fast&quot;</span>;\n        });\n\n        CompletableFuture.anyOf(slow, fast)\n            .thenAccept(System.out::println) <span class=\"hljs-comment\">// Prints &quot;fast&quot;</span>\n            .join();\n    }\n}\n</code></pre><h2>Error Handling</h2>\n<h3>Exception Handling Patterns</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ErrorHandling</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">// Using exceptionally for error recovery</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">future</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IllegalStateException</span>(<span class=\"hljs-string\">&quot;Something went wrong!&quot;</span>);\n        });\n\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> future.exceptionally(throwable -&gt; {\n                System.out.println(<span class=\"hljs-string\">&quot;Error: &quot;</span> + throwable.getMessage());\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;default_value&quot;</span>; <span class=\"hljs-comment\">// Fallback value</span>\n            }).get();\n\n            System.out.println(<span class=\"hljs-string\">&quot;Result: &quot;</span> + result); <span class=\"hljs-comment\">// Prints &quot;default_value&quot;</span>\n        } <span class=\"hljs-keyword\">catch</span> (InterruptedException | ExecutionException e) {\n            System.out.println(<span class=\"hljs-string\">&quot;Unexpected error: &quot;</span> + e.getMessage());\n        }\n\n        <span class=\"hljs-comment\">// Using handle for both success and failure</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">result2</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; {\n            <span class=\"hljs-comment\">// This might succeed or fail</span>\n            <span class=\"hljs-keyword\">if</span> (Math.random() &gt; <span class=\"hljs-number\">0.5</span>) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Success!&quot;</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(<span class=\"hljs-string\">&quot;Failed!&quot;</span>);\n            }\n        }).handle((value, throwable) -&gt; {\n            <span class=\"hljs-keyword\">if</span> (throwable != <span class=\"hljs-literal\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Error: &quot;</span> + throwable.getMessage();\n            }\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;Success: &quot;</span> + value;\n        });\n\n        System.out.println(result2.join());\n    }\n}\n</code></pre><h3>Timeouts</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TimeoutHandling</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">slowTask</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; {\n            delay(<span class=\"hljs-number\">6</span>); <span class=\"hljs-comment\">// 6 seconds</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;slow result&quot;</span>;\n        });\n\n        <span class=\"hljs-comment\">// This will throw TimeoutException</span>\n        <span class=\"hljs-comment\">// slowTask.orTimeout(2, TimeUnit.SECONDS).join();</span>\n\n        <span class=\"hljs-comment\">// Better: provide default value on timeout</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> slowTask.completeOnTimeout(<span class=\"hljs-string\">&quot;timeout_value&quot;</span>, <span class=\"hljs-number\">1</span>, TimeUnit.SECONDS);\n        System.out.println(result.join()); <span class=\"hljs-comment\">// Prints &quot;timeout_value&quot;</span>\n    }\n}\n</code></pre><h2>Advanced Patterns</h2>\n<h3>Custom Thread Pools</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// CompletableFuture uses ForkJoinPool.commonPool() by default</span>\n<span class=\"hljs-comment\">// You can provide custom executor:</span>\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">customPool</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">4</span>);\n<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">future</span> <span class=\"hljs-operator\">=</span> CompletableFuture.supplyAsync(() -&gt; <span class=\"hljs-string\">&quot;result&quot;</span>, customPool);\n</code></pre><h3>Async Method Composition</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> CompletableFuture&lt;String&gt; <span class=\"hljs-title function_\">processUser</span><span class=\"hljs-params\">(String userId)</span> {\n    <span class=\"hljs-keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; userId)\n        .thenCompose(<span class=\"hljs-built_in\">this</span>::fetchUser)           <span class=\"hljs-comment\">// CompletableFuture&lt;User&gt;</span>\n        .thenCompose(<span class=\"hljs-built_in\">this</span>::enrichUserProfile)   <span class=\"hljs-comment\">// CompletableFuture&lt;User&gt;</span>\n        .thenApply(User::getName);              <span class=\"hljs-comment\">// CompletableFuture&lt;String&gt;</span>\n}\n\n<span class=\"hljs-keyword\">private</span> CompletableFuture&lt;User&gt; <span class=\"hljs-title function_\">fetchUser</span><span class=\"hljs-params\">(String id)</span> {\n    <span class=\"hljs-keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; {\n        <span class=\"hljs-comment\">// Simulate database call</span>\n        delay();\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">User</span>(id);\n    });\n}\n\n<span class=\"hljs-keyword\">private</span> CompletableFuture&lt;User&gt; <span class=\"hljs-title function_\">enrichUserProfile</span><span class=\"hljs-params\">(User user)</span> {\n    <span class=\"hljs-keyword\">return</span> CompletableFuture.supplyAsync(() -&gt; {\n        <span class=\"hljs-comment\">// Simulate external API call</span>\n        delay();\n        user.setProfile(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Profile</span>());\n        <span class=\"hljs-keyword\">return</span> user;\n    });\n}\n</code></pre><h2>Best Practices</h2>\n<h3>1. Resource Management</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// Always shutdown executors</span>\n<span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">4</span>);\n<span class=\"hljs-keyword\">try</span> {\n    <span class=\"hljs-comment\">// Use executor</span>\n} <span class=\"hljs-keyword\">finally</span> {\n    executor.shutdown();\n}\n\n<span class=\"hljs-comment\">// Or use try-with-resources (but remember it blocks!)</span>\n<span class=\"hljs-keyword\">try</span> (<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">4</span>)) {\n    <span class=\"hljs-comment\">// Use executor</span>\n} <span class=\"hljs-comment\">// Automatically shuts down and waits</span>\n</code></pre><h3>2. Exception Handling</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// Always handle exceptions in async chains</span>\nCompletableFuture.supplyAsync(() -&gt; riskyOperation())\n    .exceptionally(throwable -&gt; {\n        log.error(<span class=\"hljs-string\">&quot;Operation failed&quot;</span>, throwable);\n        <span class=\"hljs-keyword\">return</span> defaultValue;\n    })\n    .thenAccept(<span class=\"hljs-built_in\">this</span>::processResult);\n</code></pre><h3>3. Avoid Blocking in Async Code</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// BAD: Blocking in async context</span>\nCompletableFuture.runAsync(() -&gt; {\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> anotherFuture.join(); <span class=\"hljs-comment\">// Blocking!</span>\n    process(result);\n});\n\n<span class=\"hljs-comment\">// GOOD: Chain properly</span>\nCompletableFuture.runAsync(() -&gt; setupWork())\n    .thenCompose(x -&gt; anotherFuture)  <span class=\"hljs-comment\">// Non-blocking composition</span>\n    .thenAccept(<span class=\"hljs-built_in\">this</span>::process);\n</code></pre><h3>4. Memory and Context Management</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// Be careful with shared state in lambdas</span>\n<span class=\"hljs-comment\">// Prefer passing data through the pipeline rather than capturing</span>\n</code></pre><h3>5. Testing Async Code</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testAsync</span><span class=\"hljs-params\">()</span> {\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">future</span> <span class=\"hljs-operator\">=</span> myAsyncMethod();\n\n    <span class=\"hljs-comment\">// Don&#x27;t forget to wait in tests!</span>\n    <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> future.join();\n    assertEquals(<span class=\"hljs-string\">&quot;expected&quot;</span>, result);\n}\n</code></pre><h2>Summary</h2>\n<p>CompletableFuture provide powerful tools for asynchronous programming:</p>\n<ol>\n<li><strong>Future/Callable</strong> interfaces allow returning values from background tasks</li>\n<li><strong>CompletableFuture</strong> enables modern, composable asynchronous programming</li>\n<li><strong>Proper error handling</strong> and <strong>resource management</strong> are crucial</li>\n<li><strong>Understanding the difference</strong> between blocking and non-blocking operations is key</li>\n</ol>\n<h3>Key Takeaways</h3>\n<ul>\n<li>Use CompletableFuture for new async code</li>\n<li>Chain operations with <code>thenApply</code>, <code>thenCompose</code>, <code>thenCombine</code></li>\n<li>Handle errors with <code>exceptionally</code> or <code>handle</code></li>\n<li>Always consider resource cleanup</li>\n<li>Test your async code properly</li>\n</ul>\n<h3>get() vs join()</h3>\n<ul>\n<li><code>get()</code>: Throws checked exceptions (<code>InterruptedException</code>, <code>ExecutionException</code>)</li>\n<li><code>join()</code>: Throws unchecked <code>CompletionException</code>, more convenient for most use cases</li>\n</ul>\n","markdown":"# Async Java\n\nAsynchronous programming is a style of writing code where a long-running operation\nis started, and the main program continues its work **without waiting**\nfor that operation to finish. In Java, this is often managed using the `Future` interface.\n\n## The `Future` Interface: A Placeholder for Results\n\nThe **`Future<T>`** interface is a core component of Java's concurrency utilities.\nIt represents the **result of an asynchronous computation** that may not have completed yet.\nWhen you start a task on a background thread (e.g., using an `ExecutorService`), the method returns a `Future` object immediately. This object is essentially a **placeholder** for the eventual result (of type `T`).\n\n#### **How to Get a Future**\n\nYou typically obtain a `Future` by submitting a task (a `Callable`) to an `ExecutorService`:\n\n```java\nimport java.util.concurrent.*;\n\n// 1. Create a service to run background threads\nExecutorService executor = Executors.newSingleThreadExecutor();\n\n// 2. Submit a long-running task that returns a value (Callable)\nFuture<Integer> futureResult = executor.submit(() -> {\n    System.out.println(\"...Starting background task (simulating 3 seconds)...\");\n    Thread.sleep(3000);\n    return 42; // The final result\n});\n\n// The main thread continues running immediately.\nSystem.out.println(\"Main thread is not blocked yet, doing other work...\");\n```\n\n### Future Interface Methods\n\n| Method                     | Purpose                                 | Key Behavior and Limitation                                                                                                                                    |\n| :------------------------- | :-------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| **`get()`**                | Retrieves the result.                   | **BLOCKS** the calling thread indefinitely until the result is available or an exception is thrown. **This is usually what asynchronous code tries to avoid.** |\n| **`get(timeout, unit)`**   | Retrieves the result with a time limit. | **BLOCKS** the calling thread. Throws a `TimeoutException` if the result isn't ready in time.                                                                  |\n| **`isDone()`**             | Check if task completed.                | Returns `true` if the task has finished, whether normally, by cancellation, or with an error.                                                                  |\n| **`cancel(mayInterrupt)`** | Attempt to cancel the task.             | Attempts to stop the running task. Returns `true` if the cancellation was successful.                                                                          |\n\n**_The main limitation of the original `Future` is that retrieving the result via `get()` requires the calling thread to stop and wait. For modern, non-blocking asynchronous programming, Java developers prefer the_** **`CompletableFuture`** **_class (introduced in Java 8), which allows you to chain tasks and react to completion without blocking._**\n\n---\n\n## Understanding Concurrency vs. Parallelism vs. Asynchronous\n\nThese three terms are often confused. Here’s how they differ:\n\n| Term             | Meaning                                                                                                                                        | Requires Multiple Cores?                 | Practical Analogy                                                                                                                           |\n| :--------------- | :--------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------ |\n| **Concurrent**   | Many tasks making **progress** over overlapping time periods by rapidly switching between them.                                                | ❌ Not necessarily (can run on one core) | **One Chef** juggling three orders: they chop for a minute, stir for a minute, then check the oven. All tasks are _progressing_ over time.  |\n| **Parallel**     | Tasks running **literally at the same instant** (simultaneously) on different CPU cores.                                                       | ✅ Yes                                   | **Three Chefs** working on three different orders **at the exact same time** on three different stations.                                   |\n| **Asynchronous** | A **programming style** where the caller initiates a task and continues its own work, using a `Future` or callback to handle the result later. | ❌ No (It's a coding approach)           | **Placing a take-out order** by phone: You hang up and drive to the restaurant. You don't stay on hold the whole time waiting for the food. |\n\n### Future Interface Methods\n\n- `get()`: Blocks until result is available (throws checked exceptions)\n- `get(timeout, unit)`: Blocks with timeout\n- `isDone()`: Check if task completed\n- `cancel(mayInterrupt)`: Attempt to cancel the task\n\n## Understanding Concurrency vs Parallelism vs Asynchronous\n\n### Definitions\n\n| Term             | Meaning                                      | Needs Multiple Cores? | Typical Use                             |\n| ---------------- | -------------------------------------------- | --------------------- | --------------------------------------- |\n| **Parallel**     | Tasks run literally at the same time         | ✅ Yes                | CPU-bound work (math, image processing) |\n| **Concurrent**   | Many tasks progressing in overlapping time   | ❌ Not necessarily    | Task scheduling, multitasking           |\n| **Asynchronous** | Task runs in background, caller doesn't wait | ❌ No                 | I/O-bound work (network, DB, files)     |\n\n### Examples\n\n**Parallel Processing:**\n\n```java\nIntStream.range(0, 10)\n    .parallel()\n    .forEach(i -> System.out.println(i + \" \" + Thread.currentThread()));\n```\n\n**Concurrent Processing:**\n\n```java\nExecutorService pool = Executors.newFixedThreadPool(2);\npool.submit(() -> doWork(\"A\"));\npool.submit(() -> doWork(\"B\"));\n// Tasks overlap in time, may or may not run simultaneously\n```\n\n**Asynchronous Processing:**\n\n```java\nCompletableFuture.runAsync(() -> {\n    delay();\n    System.out.println(\"hello\");\n});\nSystem.out.println(\"I don't block!\"); // Runs immediately\n```\n\n### What Does \"Asynchronous\" Really Mean?\n\nAsynchronous programming is about **non-blocking execution**:\n\n- You start a task\n- Your thread continues with other work\n- The task completes later and notifies you (via callback, promise, etc.)\n\nThink of it like ordering coffee:\n\n- **Synchronous**: Order coffee → wait → receive coffee → continue\n- **Asynchronous**: Order coffee → do other things → get notified when ready\n\n## CompletableFuture: Modern Asynchronous Programming\n\n### Introduction\n\n`CompletableFuture` is Java's equivalent to JavaScript Promises. It has three states:\n\n- **Pending**: Task is running\n- **Resolved**: Task completed successfully\n- **Rejected**: Task failed with an exception\n\n### Basic Usage\n\n```java\npublic class AsyncExample {\n    public static void main(String[] args) {\n        // Fire and forget\n        show().join(); // join() blocks until completion\n\n        // With return value\n        try {\n            String value = show2().get();\n            System.out.println(\"Returned: \" + value);\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // CompletableFuture.runAsync for void tasks\n    public static CompletableFuture<Void> show() {\n        return CompletableFuture.runAsync(() -> {\n            delay();\n            System.out.println(\"hello\");\n        });\n    }\n\n    // CompletableFuture.supplyAsync for tasks with return values\n    public static CompletableFuture<String> show2() {\n        return CompletableFuture.supplyAsync(() -> {\n            delay();\n            return \"hello\";\n        });\n    }\n}\n```\n\n### Building Async APIs\n\n```java\nclass MailSender {\n    // Synchronous method\n    public void sendMail() {\n        delay();\n        System.out.println(\"mail sent !!!!\");\n    }\n\n    // Asynchronous wrapper\n    public CompletableFuture<Void> sendMailAsync() {\n        return CompletableFuture.runAsync(() -> sendMail());\n    }\n}\n\n// Usage\nvar mailService = new MailSender();\nvar future = mailService.sendMailAsync();\nSystem.out.println(\"This runs immediately\");\nfuture.join(); // Wait for completion\n```\n\n## Chaining Operations\n\n### CompletableFuture Chaining Methods\n\n| Method                      | Input Lambda                | Returns                   | Use Case                  |\n| --------------------------- | --------------------------- | ------------------------- | ------------------------- |\n| `thenApply(fn)`             | `T -> U`                    | `CompletableFuture<U>`    | Transform result (sync)   |\n| `thenApplyAsync(fn)`        | `T -> U`                    | `CompletableFuture<U>`    | Transform result (async)  |\n| `thenAccept(consumer)`      | `T -> void`                 | `CompletableFuture<Void>` | Consume result, no return |\n| `thenAcceptAsync(consumer)` | `T -> void`                 | `CompletableFuture<Void>` | Consume result (async)    |\n| `thenRun(runnable)`         | `() -> void`                | `CompletableFuture<Void>` | Run after completion      |\n| `thenCompose(fn)`           | `T -> CompletableFuture<U>` | `CompletableFuture<U>`    | Chain async operations    |\n\n### Practical Examples\n\n```java\npublic class CompletableFutureChaining {\n    public static void main(String[] args) {\n        // Transform and consume\n        var future = CompletableFuture.supplyAsync(() -> 12)\n            .thenApplyAsync(v -> v * 2) // Transform: 12 -> 24\n            .thenAcceptAsync(v -> {\n                delay();\n                System.out.println(\"Thread: \" + Thread.currentThread().getName());\n                System.out.println(\"Value: \" + v);\n            });\n\n        future.join();\n    }\n}\n```\n\n### thenApply vs thenCompose\n\n**Key Difference:**\n\n- `thenApply`: Use when your function returns a **plain value** (`T -> U`)\n- `thenCompose`: Use when your function returns a **CompletableFuture** (`T -> CompletableFuture<U>`)\n\n```java\n// thenApply - transforms value\nCompletableFuture.supplyAsync(() -> \"User123\")\n    .thenApply(id -> fetchProfileSync(id)) // Returns Profile\n    .thenAccept(System.out::println);\n\n// thenCompose - chains futures (avoids nesting)\nCompletableFuture.supplyAsync(() -> \"User123\")\n    .thenCompose(id -> fetchProfileAsync(id)) // Returns CompletableFuture<Profile>\n    .thenAccept(System.out::println);\n```\n\nWithout `thenCompose`, you'd get `CompletableFuture<CompletableFuture<Profile>>` (nested futures).\n\n## Combining Futures\n\n### Combining Two Futures\n\n```java\npublic class CombiningFutures {\n    public static void main(String[] args) {\n        // Get price in USD\n        var priceInUSD = CompletableFuture.supplyAsync(() -> 39);\n\n        // Get exchange rate USD -> EGP\n        var exchangeRate = CompletableFuture.supplyAsync(() -> 50);\n\n        // Combine results\n        var finalPrice = priceInUSD.thenCombine(exchangeRate,\n            (price, rate) -> price * rate);\n\n        System.out.println(\"Final price: \" + finalPrice.join());\n\n        // More complex example with string parsing\n        var priceString = CompletableFuture.supplyAsync(() -> \"39usd\");\n        var rate = CompletableFuture.supplyAsync(() -> 50);\n\n        var result = priceString\n            .thenApply(price -> {\n                var cleanPrice = price.replace(\"usd\", \"\");\n                return Integer.parseInt(cleanPrice);\n            })\n            .thenCombine(rate, (price, exchangeRate) -> price * exchangeRate);\n\n        System.out.println(\"Parsed result: \" + result.join());\n    }\n}\n```\n\n### Working with Multiple Futures\n\n```java\npublic class MultipleFutures {\n    public static void main(String[] args) {\n        var f1 = CompletableFuture.supplyAsync(() -> { delay(); return 1; });\n        var f2 = CompletableFuture.supplyAsync(() -> { delay(); return 2; });\n        var f3 = CompletableFuture.supplyAsync(() -> { delay(); return 3; });\n        var f4 = CompletableFuture.supplyAsync(() -> { delay(); return 4; });\n\n        // Wait for ALL to complete\n        CompletableFuture.allOf(f1, f2, f3, f4).join();\n        System.out.println(\"All completed: \" + f1.join());\n\n        // Wait for ANY to complete (first wins)\n        var slow = CompletableFuture.supplyAsync(() -> {\n            delay(6); return \"slow\";\n        });\n        var fast = CompletableFuture.supplyAsync(() -> {\n            delay(1); return \"fast\";\n        });\n\n        CompletableFuture.anyOf(slow, fast)\n            .thenAccept(System.out::println) // Prints \"fast\"\n            .join();\n    }\n}\n```\n\n## Error Handling\n\n### Exception Handling Patterns\n\n```java\npublic class ErrorHandling {\n    public static void main(String[] args) {\n        // Using exceptionally for error recovery\n        var future = CompletableFuture.supplyAsync(() -> {\n            throw new IllegalStateException(\"Something went wrong!\");\n        });\n\n        try {\n            var result = future.exceptionally(throwable -> {\n                System.out.println(\"Error: \" + throwable.getMessage());\n                return \"default_value\"; // Fallback value\n            }).get();\n\n            System.out.println(\"Result: \" + result); // Prints \"default_value\"\n        } catch (InterruptedException | ExecutionException e) {\n            System.out.println(\"Unexpected error: \" + e.getMessage());\n        }\n\n        // Using handle for both success and failure\n        var result2 = CompletableFuture.supplyAsync(() -> {\n            // This might succeed or fail\n            if (Math.random() > 0.5) {\n                return \"Success!\";\n            } else {\n                throw new RuntimeException(\"Failed!\");\n            }\n        }).handle((value, throwable) -> {\n            if (throwable != null) {\n                return \"Error: \" + throwable.getMessage();\n            }\n            return \"Success: \" + value;\n        });\n\n        System.out.println(result2.join());\n    }\n}\n```\n\n### Timeouts\n\n```java\npublic class TimeoutHandling {\n    public static void main(String[] args) {\n        var slowTask = CompletableFuture.supplyAsync(() -> {\n            delay(6); // 6 seconds\n            return \"slow result\";\n        });\n\n        // This will throw TimeoutException\n        // slowTask.orTimeout(2, TimeUnit.SECONDS).join();\n\n        // Better: provide default value on timeout\n        var result = slowTask.completeOnTimeout(\"timeout_value\", 1, TimeUnit.SECONDS);\n        System.out.println(result.join()); // Prints \"timeout_value\"\n    }\n}\n```\n\n## Advanced Patterns\n\n### Custom Thread Pools\n\n```java\n// CompletableFuture uses ForkJoinPool.commonPool() by default\n// You can provide custom executor:\nvar customPool = Executors.newFixedThreadPool(4);\nvar future = CompletableFuture.supplyAsync(() -> \"result\", customPool);\n```\n\n### Async Method Composition\n\n```java\npublic CompletableFuture<String> processUser(String userId) {\n    return CompletableFuture.supplyAsync(() -> userId)\n        .thenCompose(this::fetchUser)           // CompletableFuture<User>\n        .thenCompose(this::enrichUserProfile)   // CompletableFuture<User>\n        .thenApply(User::getName);              // CompletableFuture<String>\n}\n\nprivate CompletableFuture<User> fetchUser(String id) {\n    return CompletableFuture.supplyAsync(() -> {\n        // Simulate database call\n        delay();\n        return new User(id);\n    });\n}\n\nprivate CompletableFuture<User> enrichUserProfile(User user) {\n    return CompletableFuture.supplyAsync(() -> {\n        // Simulate external API call\n        delay();\n        user.setProfile(new Profile());\n        return user;\n    });\n}\n```\n\n## Best Practices\n\n### 1. Resource Management\n\n```java\n// Always shutdown executors\nExecutorService executor = Executors.newFixedThreadPool(4);\ntry {\n    // Use executor\n} finally {\n    executor.shutdown();\n}\n\n// Or use try-with-resources (but remember it blocks!)\ntry (var executor = Executors.newFixedThreadPool(4)) {\n    // Use executor\n} // Automatically shuts down and waits\n```\n\n### 2. Exception Handling\n\n```java\n// Always handle exceptions in async chains\nCompletableFuture.supplyAsync(() -> riskyOperation())\n    .exceptionally(throwable -> {\n        log.error(\"Operation failed\", throwable);\n        return defaultValue;\n    })\n    .thenAccept(this::processResult);\n```\n\n### 3. Avoid Blocking in Async Code\n\n```java\n// BAD: Blocking in async context\nCompletableFuture.runAsync(() -> {\n    var result = anotherFuture.join(); // Blocking!\n    process(result);\n});\n\n// GOOD: Chain properly\nCompletableFuture.runAsync(() -> setupWork())\n    .thenCompose(x -> anotherFuture)  // Non-blocking composition\n    .thenAccept(this::process);\n```\n\n### 4. Memory and Context Management\n\n```java\n// Be careful with shared state in lambdas\n// Prefer passing data through the pipeline rather than capturing\n```\n\n### 5. Testing Async Code\n\n```java\n@Test\npublic void testAsync() {\n    var future = myAsyncMethod();\n\n    // Don't forget to wait in tests!\n    var result = future.join();\n    assertEquals(\"expected\", result);\n}\n```\n\n## Summary\n\nCompletableFuture provide powerful tools for asynchronous programming:\n\n1. **Future/Callable** interfaces allow returning values from background tasks\n2. **CompletableFuture** enables modern, composable asynchronous programming\n3. **Proper error handling** and **resource management** are crucial\n4. **Understanding the difference** between blocking and non-blocking operations is key\n\n### Key Takeaways\n\n- Use CompletableFuture for new async code\n- Chain operations with `thenApply`, `thenCompose`, `thenCombine`\n- Handle errors with `exceptionally` or `handle`\n- Always consider resource cleanup\n- Test your async code properly\n\n### get() vs join()\n\n- `get()`: Throws checked exceptions (`InterruptedException`, `ExecutionException`)\n- `join()`: Throws unchecked `CompletionException`, more convenient for most use cases\n","slug":"Async java","title":"Async Java","section":"A Quick Refresher","icon":"rotate","filePath":"/home/runner/work/complete-intro-to-spring-and-springBoot/complete-intro-to-spring-and-springBoot/lessons/00-A quick Refresher/G-Async java.md","nextSlug":"/complete-intro-to-spring-and-springBoot/lessons/Introduction/intro","prevSlug":"/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Threads and concurrent Programming"}},"__N_SSG":true}