{"pageProps":{"post":{"attributes":{},"html":"<h1><strong>Concurrency in Java</strong></h1>\n<p>Concurrency is one of the most important and tricky topics in Java.\nIt allows programs to perform multiple tasks at the same time, but introduces problems like <strong>race conditions</strong>, <strong>visibility issues</strong>, and <strong>deadlocks</strong> if not handled carefully.</p>\n<hr>\n<h2>1. Processes, Threads, and the JVM</h2>\n<ul>\n<li><strong>Process</strong> = an instance of a running program.</li>\n<li><strong>Thread</strong> = a lightweight unit of execution inside a process.</li>\n<li>Every Java program <strong>starts with the main thread</strong>.</li>\n<li>JVM also runs background threads (like garbage collector).</li>\n</ul>\n<p>üëâ To create new threads in Java:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">Thread</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; {\n    System.out.println(<span class=\"hljs-string\">&quot;Hello from a new thread!&quot;</span>);\n});\nt.start();\n</code></pre><hr>\n<h2>2. Thread Lifecycle and APIs</h2>\n<p>Important methods:</p>\n<ul>\n<li><code>start()</code> ‚Üí begins execution in a new thread.</li>\n<li><code>sleep(ms)</code> ‚Üí pauses <strong>current thread</strong>.</li>\n<li><code>join()</code> ‚Üí waits for another thread to finish.</li>\n<li><code>interrupt()</code> + <code>isInterrupted()</code> ‚Üí cooperative thread termination.</li>\n<li><code>setDaemon(true)</code> ‚Üí makes a background thread (JVM won‚Äôt wait for it).</li>\n</ul>\n<h3>Example:</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">Thread</span> <span class=\"hljs-variable\">worker</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Thread</span>(() -&gt; {\n    <span class=\"hljs-keyword\">try</span> {\n        Thread.sleep(<span class=\"hljs-number\">3000</span>);\n        System.out.println(<span class=\"hljs-string\">&quot;Work done!&quot;</span>);\n    } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n        System.out.println(<span class=\"hljs-string\">&quot;Interrupted!&quot;</span>);\n    }\n});\n\n<span class=\"hljs-comment\">// Non-daemon (JVM waits)</span>\nworker.start();\n\n<span class=\"hljs-comment\">// Main waits explicitly</span>\nworker.join();\n</code></pre><hr>\n<h2>3. JVM Exit Behavior</h2>\n<ul>\n<li>JVM <strong>keeps running</strong> if there‚Äôs any <strong>non-daemon thread</strong> alive.</li>\n<li>JVM <strong>can exit immediately</strong> if only <strong>daemon threads</strong> remain.</li>\n<li>Use <code>join()</code> when you want explicit waiting.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Feature</th>\n<th>Non-Daemon (default)</th>\n<th>Daemon</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JVM waits?</td>\n<td>‚úÖ Yes</td>\n<td>‚ùå No</td>\n</tr>\n<tr>\n<td>Example</td>\n<td>Worker threads</td>\n<td>Logging, GC</td>\n</tr>\n</tbody></table>\n<hr>\n<h2>4. Concurrency Problems</h2>\n<h3>4.1 Race Conditions</h3>\n<p>A <strong>race condition</strong> happens when multiple threads access and modify shared data simultaneously.</p>\n<p>Example:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> {\n    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">increment</span><span class=\"hljs-params\">()</span> { count++; }\n}\n</code></pre><p>If multiple threads call <code>increment()</code>, final result is unpredictable.</p>\n<hr>\n<h3>4.2 Fixing Race Conditions</h3>\n<p><strong>Techniques:</strong></p>\n<ol>\n<li><strong>Confinement</strong> ‚Üí keep data thread-local.</li>\n<li><strong>Synchronization</strong> ‚Üí locks, <code>synchronized</code>.</li>\n<li><strong>Atomic classes</strong> ‚Üí <code>AtomicInteger</code>, <code>AtomicBoolean</code>, etc.</li>\n<li><strong>Immutable objects</strong> ‚Üí safe by design.</li>\n</ol>\n<hr>\n<h2>5. Locks and Synchronization</h2>\n<h3>5.1 Using <code>synchronized</code></h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">increment</span><span class=\"hljs-params\">()</span> {\n        count++;\n    }\n}\n</code></pre><h3>5.2 Using Explicit Locks</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">import</span> java.util.concurrent.locks.Lock;\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.locks.ReentrantLock;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">Lock</span> <span class=\"hljs-variable\">lock</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ReentrantLock</span>();\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">increment</span><span class=\"hljs-params\">()</span> {\n        lock.lock();\n        <span class=\"hljs-keyword\">try</span> { count++; }\n        <span class=\"hljs-keyword\">finally</span> { lock.unlock(); }\n    }\n}\n</code></pre><hr>\n<h2>6. Volatile and Visibility</h2>\n<p>Threads can cache variables locally, leading to <strong>visibility issues</strong>.</p>\n<ul>\n<li>Without <code>volatile</code>, one thread may not see another‚Äôs changes.</li>\n<li>With <code>volatile</code>, all reads/writes go to <strong>main memory</strong>.</li>\n</ul>\n<p>Example:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Flag</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">volatile</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">done</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">work</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">while</span> (!done) { } <span class=\"hljs-comment\">// busy wait</span>\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">stop</span><span class=\"hljs-params\">()</span> {\n        done = <span class=\"hljs-literal\">true</span>;\n    }\n}\n</code></pre><p>‚ö†Ô∏è Note: <code>volatile</code> ensures <strong>visibility</strong>, but not <strong>atomicity</strong>.\n<code>x++</code> is still unsafe, even if <code>x</code> is volatile.</p>\n<hr>\n<h2>7. Atomic Classes</h2>\n<p>Java provides classes in <code>java.util.concurrent.atomic</code> that ensure atomic updates:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">import</span> java.util.concurrent.atomic.AtomicInteger;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AtomicCounter</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">AtomicInteger</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AtomicInteger</span>();\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">increment</span><span class=\"hljs-params\">()</span> {\n        count.incrementAndGet();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">get</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> count.get();\n    }\n}\n</code></pre><p>‚úî Uses CPU-level instructions (<code>Compare-And-Swap</code>) to guarantee atomicity without locks.</p>\n<hr>\n<h2>8. Thread Communication: <code>wait()</code> and <code>notify()</code></h2>\n<p>Sometimes threads need to communicate.</p>\n<ul>\n<li><code>wait()</code> ‚Üí makes a thread pause until notified.</li>\n<li><code>notify()</code> ‚Üí wakes one waiting thread.</li>\n<li><code>notifyAll()</code> ‚Üí wakes all waiting threads.</li>\n</ul>\n<p>‚ö†Ô∏è Must be used inside a <code>synchronized</code> block.</p>\n<p>Example:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DownloadStatus</span> {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">done</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">waitUntilDone</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException {\n        <span class=\"hljs-keyword\">while</span> (!done) {\n            wait(); <span class=\"hljs-comment\">// releases lock, waits</span>\n        }\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">synchronized</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">markDone</span><span class=\"hljs-params\">()</span> {\n        done = <span class=\"hljs-literal\">true</span>;\n        notifyAll(); <span class=\"hljs-comment\">// wakes waiting threads</span>\n    }\n}\n</code></pre><hr>\n<h2>9. Collections in Concurrency</h2>\n<ul>\n<li><code>Collections.synchronizedList()</code> ‚Üí wraps a list with locks.</li>\n<li><code>ConcurrentHashMap</code>, <code>CopyOnWriteArrayList</code> ‚Üí designed for concurrency, faster than synchronized wrappers.</li>\n</ul>\n<p>Example:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">list</span> <span class=\"hljs-operator\">=</span> Collections.synchronizedList(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;());\nlist.add(<span class=\"hljs-number\">1</span>);\n</code></pre><hr>\n<h2>10. Executor Framework (Modern Approach)</h2>\n<p>Instead of managing threads manually:</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">import</span> java.util.concurrent.*;\n\n<span class=\"hljs-type\">ExecutorService</span> <span class=\"hljs-variable\">executor</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">4</span>);\n\nexecutor.submit(() -&gt; {\n    System.out.println(<span class=\"hljs-string\">&quot;Task running&quot;</span>);\n});\n\nexecutor.shutdown();\n</code></pre><hr>\n<h1>‚úÖ Key Takeaways</h1>\n<ol>\n<li><p><strong>Thread basics</strong>: <code>start()</code>, <code>sleep()</code>, <code>join()</code>, <code>interrupt()</code>.</p>\n</li>\n<li><p><strong>Daemon vs non-daemon</strong>: JVM exit depends on them.</p>\n</li>\n<li><p><strong>Concurrency problems</strong>: Race conditions, visibility.</p>\n</li>\n<li><p><strong>Solutions</strong>:</p>\n<ul>\n<li>Confinement</li>\n<li>Synchronization</li>\n<li>Locks</li>\n<li>Atomic classes</li>\n<li>Immutability</li>\n</ul>\n</li>\n<li><p><strong>Visibility problem</strong> solved by <code>volatile</code>.</p>\n</li>\n<li><p><strong>Thread coordination</strong>: <code>wait()</code> / <code>notify()</code>.</p>\n</li>\n<li><p><strong>Use concurrent collections</strong> instead of manual sync.</p>\n</li>\n<li><p>For real apps ‚Üí prefer <strong>Executors</strong> over manual <code>Thread</code>.</p>\n</li>\n</ol>\n<!-- # **Executors, Thread Pools, and Futures in Java** -->\n<!---->\n<!-- ## 1. Why Executors? -->\n<!---->\n<!-- Working directly with threads (`new Thread(...)`) is: -->\n<!---->\n<!-- - **Error-prone** (manual start/stop, synchronization issues). -->\n<!-- - **Expensive** (creating a new thread for every task costs memory and CPU). -->\n<!-- - **Hard to scale** (what if you need to run hundreds of small tasks?). -->\n<!---->\n<!-- üëâ To solve this, Java 5 introduced the **Executor Framework** to manage threads for us. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 2. Thread Pools -->\n<!---->\n<!-- Instead of creating threads manually, we can use a **pool**: -->\n<!---->\n<!-- - A pool is a group of worker threads. -->\n<!-- - When a task finishes, the thread returns to the pool and can be reused. -->\n<!-- - Benefits: efficiency + no resource exhaustion. -->\n<!---->\n<!-- In Java, thread pools are represented by **`ExecutorService`**, with common implementations like: -->\n<!---->\n<!-- - `ThreadPoolExecutor` -->\n<!-- - `ScheduledThreadPoolExecutor` -->\n<!-- - `ForkJoinPool` -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 3. Example: Using Executors -->\n<!---->\n<!-- ### Blocking version (with try-with-resources) -->\n<!---->\n<!-- ```java -->\n<!-- public static void show() { -->\n<!--     // Java 21+: ExecutorService implements AutoCloseable -->\n<!--     try (var pool = Executors.newFixedThreadPool(2)) { -->\n<!--         pool.submit(() -> { -->\n<!--             delay(); -->\n<!--             System.out.println(Thread.currentThread().getName()); -->\n<!--         }); -->\n<!--         System.out.println(\"hello\"); -->\n<!--     } // <-- pool.close() waits for tasks to finish -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- üîé **What happens here?** -->\n<!---->\n<!-- - `\"hello\"` prints immediately. -->\n<!-- - The submitted task runs on a worker thread. -->\n<!-- - When the `try` block ends, `pool.close()` is called, which **blocks** until tasks finish. -->\n<!---->\n<!-- That‚Äôs why `\"this is blocking\"` only shows _after_ the task completes. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ### Non-blocking version (manual shutdown) -->\n<!---->\n<!-- ```java -->\n<!-- public static ExecutorService show2() { -->\n<!--     var pool = Executors.newFixedThreadPool(2); -->\n<!--     pool.submit(() -> { -->\n<!--         delay(); -->\n<!--         System.out.println(Thread.currentThread().getName()); -->\n<!--     }); -->\n<!--     System.out.println(\"hello\"); -->\n<!--     return pool; // caller can decide when to shut it down -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- Here: -->\n<!---->\n<!-- - `\"hello\"` prints immediately. -->\n<!-- - Program doesn‚Äôt block unless you later call `pool.shutdown()`. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 4. Callable and Future -->\n<!---->\n<!-- Sometimes, we don‚Äôt just want to run tasks‚Äîwe want a **result**. -->\n<!---->\n<!-- - `Runnable`: no result, just side effects. -->\n<!-- - `Callable<T>`: returns a value of type `T`. -->\n<!---->\n<!-- When we submit a `Callable`, we get back a **`Future<T>`** object. -->\n<!---->\n<!-- ```java -->\n<!-- public static Future<Integer> show3() { -->\n<!--     try (var pool = Executors.newFixedThreadPool(2)) { -->\n<!--         return pool.submit(() -> { -->\n<!--             delay(); -->\n<!--             return 25; -->\n<!--         }); -->\n<!--     } -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- ### Getting the result -->\n<!---->\n<!-- ```java -->\n<!-- var result = show3(); -->\n<!-- try { -->\n<!--     var value = result.get(); // blocks until task is finished -->\n<!--     System.out.println(value); -->\n<!-- } catch (InterruptedException | ExecutionException e) { -->\n<!--     throw new RuntimeException(e); -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- ‚ö†Ô∏è `.get()` **blocks** the main thread until the task finishes. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 5. Asynchronous Programming with `CompletableFuture` -->\n<!---->\n<!-- Futures are powerful but clunky (they only give you `.get()`). -->\n<!-- Java 8 introduced **`CompletableFuture`**, which lets you: -->\n<!---->\n<!-- - Run async tasks without blocking. -->\n<!-- - Chain multiple tasks (`thenApply`, `thenAccept`). -->\n<!-- - Handle errors. -->\n<!---->\n<!-- Example: -->\n<!---->\n<!-- ```java -->\n<!-- CompletableFuture.runAsync(() -> { -->\n<!--     delay(); -->\n<!--     System.out.println(Thread.currentThread().getName()); -->\n<!-- }); -->\n<!-- System.out.println(\"hello\"); // prints immediately -->\n<!-- ``` -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 6. Summary -->\n<!---->\n<!-- - **Executors** = abstraction over threads. -->\n<!-- - **Thread pools** = efficient reuse of threads. -->\n<!-- - **Runnable** = no result, **Callable** = returns result. -->\n<!-- - **Future** = placeholder for a result (but blocks). -->\n<!-- - **CompletableFuture** = modern async style with chaining. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## ‚úÖ Takeaway for students -->\n<!---->\n<!-- 1. Use **Executors** instead of raw threads. -->\n<!-- 2. Use **Callable + Future** when you need results. -->\n<!-- 3. Use **CompletableFuture** for non-blocking async programming. -->\n<!-- 4. Remember: -->\n<!--    - `ExecutorService.close()` blocks until tasks finish (Java 21+). -->\n<!--    - `.get()` on a `Future` blocks too. -->\n<!---->\n\n<h1><strong>ExecutorService</strong></h1>\n<!-- ## Table of Contents -->\n<!---->\n<!-- 1. [Introduction](#introduction) -->\n<!-- 2. [Thread Pools and ExecutorService](#thread-pools-and-executorservice) -->\n<!-- 3. [Callable and Future Interfaces](#callable-and-future-interfaces) -->\n<!-- 4. [Understanding Concurrency vs Parallelism vs Asynchronous](#understanding-concurrency-vs-parallelism-vs-asynchronous) -->\n<!-- 5. [CompletableFuture: Modern Asynchronous Programming](#completablefuture-modern-asynchronous-programming) -->\n<!-- 6. [Chaining Operations](#chaining-operations) -->\n<!-- 7. [Combining Futures](#combining-futures) -->\n<!-- 8. [Error Handling](#error-handling) -->\n<!-- 9. [Advanced Patterns](#advanced-patterns) -->\n<!-- 10. [Best Practices](#best-practices) -->\n\n<h2>Introduction</h2>\n<p>Working with threads directly in Java is difficult and error-prone. Java 5 introduced the <strong>Executor Framework</strong> to abstract away the complexity of thread management. This lesson covers:</p>\n<ul>\n<li>Thread pools and ExecutorService</li>\n<li>Callable and Future interfaces</li>\n<li>Asynchronous programming with CompletableFuture</li>\n<li>Modern patterns for concurrent programming</li>\n</ul>\n<h2>Thread Pools and ExecutorService</h2>\n<h3>The Problem with Direct Thread Usage</h3>\n<p>Creating threads directly has two major issues:</p>\n<ol>\n<li><strong>Cost</strong>: Creating and destroying threads is expensive</li>\n<li><strong>Availability</strong>: System resources are limited</li>\n</ol>\n<h3>Solution: Thread Pools</h3>\n<p>A thread pool is a collection of worker threads. When a worker thread finishes its task, it returns to the pool to execute other tasks instead of being destroyed.</p>\n<h3>ExecutorService Basics</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ExecutorDemo</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">// Basic executor usage</span>\n        show();\n\n        <span class=\"hljs-comment\">// Non-blocking example</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">exec</span> <span class=\"hljs-operator\">=</span> show2();\n        System.out.println(<span class=\"hljs-string\">&quot;this runs immediately&quot;</span>);\n        exec.shutdown();\n\n        <span class=\"hljs-comment\">// Working with return values</span>\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> show3();\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">value</span> <span class=\"hljs-operator\">=</span> result.get();\n            System.out.println(value);\n        } <span class=\"hljs-keyword\">catch</span> (InterruptedException | ExecutionException e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);\n        }\n    }\n\n    <span class=\"hljs-comment\">// Blocking example with try-with-resources</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">try</span> (<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">pool</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">2</span>)) {\n            pool.submit(() -&gt; {\n                delay();\n                System.out.println(Thread.currentThread().getName());\n            });\n            System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>);\n        } <span class=\"hljs-comment\">// pool.close() blocks until all tasks complete</span>\n    }\n\n    <span class=\"hljs-comment\">// Non-blocking example</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> ExecutorService <span class=\"hljs-title function_\">show2</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">pool</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">2</span>);\n        pool.submit(() -&gt; {\n            delay();\n            System.out.println(Thread.currentThread().getName());\n        });\n        System.out.println(<span class=\"hljs-string\">&quot;hello&quot;</span>); <span class=\"hljs-comment\">// Prints immediately</span>\n        <span class=\"hljs-keyword\">return</span> pool; <span class=\"hljs-comment\">// Must manually shutdown later</span>\n    }\n\n    <span class=\"hljs-comment\">// Returning values with Future</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Future&lt;Integer&gt; <span class=\"hljs-title function_\">show3</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">try</span> (<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">pool</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">2</span>)) {\n            <span class=\"hljs-keyword\">return</span> pool.submit(() -&gt; {\n                delay();\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">25</span>;\n            });\n        }\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">delay</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">try</span> {\n            Thread.sleep(Duration.ofSeconds(<span class=\"hljs-number\">2</span>));\n        } <span class=\"hljs-keyword\">catch</span> (InterruptedException e) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);\n        }\n    }\n}\n</code></pre><h3>Key ExecutorService Implementations</h3>\n<ol>\n<li><strong>ThreadPoolExecutor</strong>: General-purpose thread pool</li>\n<li><strong>ScheduledThreadPoolExecutor</strong>: For scheduled tasks</li>\n<li><strong>ForkJoinPool</strong>: For divide-and-conquer algorithms</li>\n</ol>\n<h3>Important Note About try-with-resources</h3>\n<p>When using <code>try-with-resources</code> with ExecutorService:</p>\n<ul>\n<li>The <code>close()</code> method calls <code>shutdown()</code> and <strong>blocks</strong> until all submitted tasks finish</li>\n<li>This can make your code appear synchronous even though tasks run on separate threads</li>\n<li>For truly non-blocking behavior, manage the executor lifecycle manually</li>\n</ul>\n<h2>Callable and Future Interfaces</h2>\n<h3>Moving Beyond Runnable</h3>\n<p>While <code>Runnable</code> is great for fire-and-forget tasks, often you need to:</p>\n<ul>\n<li>Return a value from your task</li>\n<li>Handle exceptions properly</li>\n<li>Check if the task is complete</li>\n</ul>\n<h3>Callable Interface</h3>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ThreadPoolExample</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-keyword\">try</span> (<span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">exec</span> <span class=\"hljs-operator\">=</span> Executors.newFixedThreadPool(<span class=\"hljs-number\">2</span>)) {\n            <span class=\"hljs-comment\">// Submit a Callable that returns a value</span>\n            <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> exec.submit(() -&gt; {\n                System.out.println(Thread.currentThread().getName());\n                LongTask.simulate();\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// Return value</span>\n            });\n\n            <span class=\"hljs-keyword\">try</span> {\n                <span class=\"hljs-comment\">// get() is a BLOCKING call</span>\n                <span class=\"hljs-type\">var</span> <span class=\"hljs-variable\">res</span> <span class=\"hljs-operator\">=</span> result.get();\n                System.out.println(res);\n            } <span class=\"hljs-keyword\">catch</span> (InterruptedException | ExecutionException e) {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RuntimeException</span>(e);\n            }\n        }\n    }\n}\n</code></pre>","markdown":"# **Concurrency in Java**\n\nConcurrency is one of the most important and tricky topics in Java.\nIt allows programs to perform multiple tasks at the same time, but introduces problems like **race conditions**, **visibility issues**, and **deadlocks** if not handled carefully.\n\n---\n\n## 1. Processes, Threads, and the JVM\n\n- **Process** = an instance of a running program.\n- **Thread** = a lightweight unit of execution inside a process.\n- Every Java program **starts with the main thread**.\n- JVM also runs background threads (like garbage collector).\n\nüëâ To create new threads in Java:\n\n```java\nThread t = new Thread(() -> {\n    System.out.println(\"Hello from a new thread!\");\n});\nt.start();\n```\n\n---\n\n## 2. Thread Lifecycle and APIs\n\nImportant methods:\n\n- `start()` ‚Üí begins execution in a new thread.\n- `sleep(ms)` ‚Üí pauses **current thread**.\n- `join()` ‚Üí waits for another thread to finish.\n- `interrupt()` + `isInterrupted()` ‚Üí cooperative thread termination.\n- `setDaemon(true)` ‚Üí makes a background thread (JVM won‚Äôt wait for it).\n\n### Example:\n\n```java\nThread worker = new Thread(() -> {\n    try {\n        Thread.sleep(3000);\n        System.out.println(\"Work done!\");\n    } catch (InterruptedException e) {\n        System.out.println(\"Interrupted!\");\n    }\n});\n\n// Non-daemon (JVM waits)\nworker.start();\n\n// Main waits explicitly\nworker.join();\n```\n\n---\n\n## 3. JVM Exit Behavior\n\n- JVM **keeps running** if there‚Äôs any **non-daemon thread** alive.\n- JVM **can exit immediately** if only **daemon threads** remain.\n- Use `join()` when you want explicit waiting.\n\n| Feature    | Non-Daemon (default) | Daemon      |\n| ---------- | -------------------- | ----------- |\n| JVM waits? | ‚úÖ Yes               | ‚ùå No       |\n| Example    | Worker threads       | Logging, GC |\n\n---\n\n## 4. Concurrency Problems\n\n### 4.1 Race Conditions\n\nA **race condition** happens when multiple threads access and modify shared data simultaneously.\n\nExample:\n\n```java\nclass Counter {\n    int count = 0;\n    public void increment() { count++; }\n}\n```\n\nIf multiple threads call `increment()`, final result is unpredictable.\n\n---\n\n### 4.2 Fixing Race Conditions\n\n**Techniques:**\n\n1. **Confinement** ‚Üí keep data thread-local.\n2. **Synchronization** ‚Üí locks, `synchronized`.\n3. **Atomic classes** ‚Üí `AtomicInteger`, `AtomicBoolean`, etc.\n4. **Immutable objects** ‚Üí safe by design.\n\n---\n\n## 5. Locks and Synchronization\n\n### 5.1 Using `synchronized`\n\n```java\nclass Counter {\n    private int count = 0;\n    public synchronized void increment() {\n        count++;\n    }\n}\n```\n\n### 5.2 Using Explicit Locks\n\n```java\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass Counter {\n    private int count = 0;\n    private Lock lock = new ReentrantLock();\n\n    public void increment() {\n        lock.lock();\n        try { count++; }\n        finally { lock.unlock(); }\n    }\n}\n```\n\n---\n\n## 6. Volatile and Visibility\n\nThreads can cache variables locally, leading to **visibility issues**.\n\n- Without `volatile`, one thread may not see another‚Äôs changes.\n- With `volatile`, all reads/writes go to **main memory**.\n\nExample:\n\n```java\nclass Flag {\n    private volatile boolean done = false;\n\n    public void work() {\n        while (!done) { } // busy wait\n    }\n\n    public void stop() {\n        done = true;\n    }\n}\n```\n\n‚ö†Ô∏è Note: `volatile` ensures **visibility**, but not **atomicity**.\n`x++` is still unsafe, even if `x` is volatile.\n\n---\n\n## 7. Atomic Classes\n\nJava provides classes in `java.util.concurrent.atomic` that ensure atomic updates:\n\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\nclass AtomicCounter {\n    private AtomicInteger count = new AtomicInteger();\n\n    public void increment() {\n        count.incrementAndGet();\n    }\n\n    public int get() {\n        return count.get();\n    }\n}\n```\n\n‚úî Uses CPU-level instructions (`Compare-And-Swap`) to guarantee atomicity without locks.\n\n---\n\n## 8. Thread Communication: `wait()` and `notify()`\n\nSometimes threads need to communicate.\n\n- `wait()` ‚Üí makes a thread pause until notified.\n- `notify()` ‚Üí wakes one waiting thread.\n- `notifyAll()` ‚Üí wakes all waiting threads.\n\n‚ö†Ô∏è Must be used inside a `synchronized` block.\n\nExample:\n\n```java\nclass DownloadStatus {\n    private boolean done = false;\n\n    public synchronized void waitUntilDone() throws InterruptedException {\n        while (!done) {\n            wait(); // releases lock, waits\n        }\n    }\n\n    public synchronized void markDone() {\n        done = true;\n        notifyAll(); // wakes waiting threads\n    }\n}\n```\n\n---\n\n## 9. Collections in Concurrency\n\n- `Collections.synchronizedList()` ‚Üí wraps a list with locks.\n- `ConcurrentHashMap`, `CopyOnWriteArrayList` ‚Üí designed for concurrency, faster than synchronized wrappers.\n\nExample:\n\n```java\nvar list = Collections.synchronizedList(new ArrayList<>());\nlist.add(1);\n```\n\n---\n\n## 10. Executor Framework (Modern Approach)\n\nInstead of managing threads manually:\n\n```java\nimport java.util.concurrent.*;\n\nExecutorService executor = Executors.newFixedThreadPool(4);\n\nexecutor.submit(() -> {\n    System.out.println(\"Task running\");\n});\n\nexecutor.shutdown();\n```\n\n---\n\n# ‚úÖ Key Takeaways\n\n1. **Thread basics**: `start()`, `sleep()`, `join()`, `interrupt()`.\n2. **Daemon vs non-daemon**: JVM exit depends on them.\n3. **Concurrency problems**: Race conditions, visibility.\n4. **Solutions**:\n   - Confinement\n   - Synchronization\n   - Locks\n   - Atomic classes\n   - Immutability\n\n5. **Visibility problem** solved by `volatile`.\n6. **Thread coordination**: `wait()` / `notify()`.\n7. **Use concurrent collections** instead of manual sync.\n8. For real apps ‚Üí prefer **Executors** over manual `Thread`.\n\n<!-- # **Executors, Thread Pools, and Futures in Java** -->\n<!---->\n<!-- ## 1. Why Executors? -->\n<!---->\n<!-- Working directly with threads (`new Thread(...)`) is: -->\n<!---->\n<!-- - **Error-prone** (manual start/stop, synchronization issues). -->\n<!-- - **Expensive** (creating a new thread for every task costs memory and CPU). -->\n<!-- - **Hard to scale** (what if you need to run hundreds of small tasks?). -->\n<!---->\n<!-- üëâ To solve this, Java 5 introduced the **Executor Framework** to manage threads for us. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 2. Thread Pools -->\n<!---->\n<!-- Instead of creating threads manually, we can use a **pool**: -->\n<!---->\n<!-- - A pool is a group of worker threads. -->\n<!-- - When a task finishes, the thread returns to the pool and can be reused. -->\n<!-- - Benefits: efficiency + no resource exhaustion. -->\n<!---->\n<!-- In Java, thread pools are represented by **`ExecutorService`**, with common implementations like: -->\n<!---->\n<!-- - `ThreadPoolExecutor` -->\n<!-- - `ScheduledThreadPoolExecutor` -->\n<!-- - `ForkJoinPool` -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 3. Example: Using Executors -->\n<!---->\n<!-- ### Blocking version (with try-with-resources) -->\n<!---->\n<!-- ```java -->\n<!-- public static void show() { -->\n<!--     // Java 21+: ExecutorService implements AutoCloseable -->\n<!--     try (var pool = Executors.newFixedThreadPool(2)) { -->\n<!--         pool.submit(() -> { -->\n<!--             delay(); -->\n<!--             System.out.println(Thread.currentThread().getName()); -->\n<!--         }); -->\n<!--         System.out.println(\"hello\"); -->\n<!--     } // <-- pool.close() waits for tasks to finish -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- üîé **What happens here?** -->\n<!---->\n<!-- - `\"hello\"` prints immediately. -->\n<!-- - The submitted task runs on a worker thread. -->\n<!-- - When the `try` block ends, `pool.close()` is called, which **blocks** until tasks finish. -->\n<!---->\n<!-- That‚Äôs why `\"this is blocking\"` only shows _after_ the task completes. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ### Non-blocking version (manual shutdown) -->\n<!---->\n<!-- ```java -->\n<!-- public static ExecutorService show2() { -->\n<!--     var pool = Executors.newFixedThreadPool(2); -->\n<!--     pool.submit(() -> { -->\n<!--         delay(); -->\n<!--         System.out.println(Thread.currentThread().getName()); -->\n<!--     }); -->\n<!--     System.out.println(\"hello\"); -->\n<!--     return pool; // caller can decide when to shut it down -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- Here: -->\n<!---->\n<!-- - `\"hello\"` prints immediately. -->\n<!-- - Program doesn‚Äôt block unless you later call `pool.shutdown()`. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 4. Callable and Future -->\n<!---->\n<!-- Sometimes, we don‚Äôt just want to run tasks‚Äîwe want a **result**. -->\n<!---->\n<!-- - `Runnable`: no result, just side effects. -->\n<!-- - `Callable<T>`: returns a value of type `T`. -->\n<!---->\n<!-- When we submit a `Callable`, we get back a **`Future<T>`** object. -->\n<!---->\n<!-- ```java -->\n<!-- public static Future<Integer> show3() { -->\n<!--     try (var pool = Executors.newFixedThreadPool(2)) { -->\n<!--         return pool.submit(() -> { -->\n<!--             delay(); -->\n<!--             return 25; -->\n<!--         }); -->\n<!--     } -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- ### Getting the result -->\n<!---->\n<!-- ```java -->\n<!-- var result = show3(); -->\n<!-- try { -->\n<!--     var value = result.get(); // blocks until task is finished -->\n<!--     System.out.println(value); -->\n<!-- } catch (InterruptedException | ExecutionException e) { -->\n<!--     throw new RuntimeException(e); -->\n<!-- } -->\n<!-- ``` -->\n<!---->\n<!-- ‚ö†Ô∏è `.get()` **blocks** the main thread until the task finishes. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 5. Asynchronous Programming with `CompletableFuture` -->\n<!---->\n<!-- Futures are powerful but clunky (they only give you `.get()`). -->\n<!-- Java 8 introduced **`CompletableFuture`**, which lets you: -->\n<!---->\n<!-- - Run async tasks without blocking. -->\n<!-- - Chain multiple tasks (`thenApply`, `thenAccept`). -->\n<!-- - Handle errors. -->\n<!---->\n<!-- Example: -->\n<!---->\n<!-- ```java -->\n<!-- CompletableFuture.runAsync(() -> { -->\n<!--     delay(); -->\n<!--     System.out.println(Thread.currentThread().getName()); -->\n<!-- }); -->\n<!-- System.out.println(\"hello\"); // prints immediately -->\n<!-- ``` -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## 6. Summary -->\n<!---->\n<!-- - **Executors** = abstraction over threads. -->\n<!-- - **Thread pools** = efficient reuse of threads. -->\n<!-- - **Runnable** = no result, **Callable** = returns result. -->\n<!-- - **Future** = placeholder for a result (but blocks). -->\n<!-- - **CompletableFuture** = modern async style with chaining. -->\n<!---->\n<!-- --- -->\n<!---->\n<!-- ## ‚úÖ Takeaway for students -->\n<!---->\n<!-- 1. Use **Executors** instead of raw threads. -->\n<!-- 2. Use **Callable + Future** when you need results. -->\n<!-- 3. Use **CompletableFuture** for non-blocking async programming. -->\n<!-- 4. Remember: -->\n<!--    - `ExecutorService.close()` blocks until tasks finish (Java 21+). -->\n<!--    - `.get()` on a `Future` blocks too. -->\n<!---->\n\n# **ExecutorService**\n\n<!-- ## Table of Contents -->\n<!---->\n<!-- 1. [Introduction](#introduction) -->\n<!-- 2. [Thread Pools and ExecutorService](#thread-pools-and-executorservice) -->\n<!-- 3. [Callable and Future Interfaces](#callable-and-future-interfaces) -->\n<!-- 4. [Understanding Concurrency vs Parallelism vs Asynchronous](#understanding-concurrency-vs-parallelism-vs-asynchronous) -->\n<!-- 5. [CompletableFuture: Modern Asynchronous Programming](#completablefuture-modern-asynchronous-programming) -->\n<!-- 6. [Chaining Operations](#chaining-operations) -->\n<!-- 7. [Combining Futures](#combining-futures) -->\n<!-- 8. [Error Handling](#error-handling) -->\n<!-- 9. [Advanced Patterns](#advanced-patterns) -->\n<!-- 10. [Best Practices](#best-practices) -->\n\n## Introduction\n\nWorking with threads directly in Java is difficult and error-prone. Java 5 introduced the **Executor Framework** to abstract away the complexity of thread management. This lesson covers:\n\n- Thread pools and ExecutorService\n- Callable and Future interfaces\n- Asynchronous programming with CompletableFuture\n- Modern patterns for concurrent programming\n\n## Thread Pools and ExecutorService\n\n### The Problem with Direct Thread Usage\n\nCreating threads directly has two major issues:\n\n1. **Cost**: Creating and destroying threads is expensive\n2. **Availability**: System resources are limited\n\n### Solution: Thread Pools\n\nA thread pool is a collection of worker threads. When a worker thread finishes its task, it returns to the pool to execute other tasks instead of being destroyed.\n\n### ExecutorService Basics\n\n```java\npublic class ExecutorDemo {\n    public static void main(String[] args) {\n        // Basic executor usage\n        show();\n\n        // Non-blocking example\n        var exec = show2();\n        System.out.println(\"this runs immediately\");\n        exec.shutdown();\n\n        // Working with return values\n        var result = show3();\n        try {\n            var value = result.get();\n            System.out.println(value);\n        } catch (InterruptedException | ExecutionException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    // Blocking example with try-with-resources\n    public static void show() {\n        try (var pool = Executors.newFixedThreadPool(2)) {\n            pool.submit(() -> {\n                delay();\n                System.out.println(Thread.currentThread().getName());\n            });\n            System.out.println(\"hello\");\n        } // pool.close() blocks until all tasks complete\n    }\n\n    // Non-blocking example\n    public static ExecutorService show2() {\n        var pool = Executors.newFixedThreadPool(2);\n        pool.submit(() -> {\n            delay();\n            System.out.println(Thread.currentThread().getName());\n        });\n        System.out.println(\"hello\"); // Prints immediately\n        return pool; // Must manually shutdown later\n    }\n\n    // Returning values with Future\n    public static Future<Integer> show3() {\n        try (var pool = Executors.newFixedThreadPool(2)) {\n            return pool.submit(() -> {\n                delay();\n                return 25;\n            });\n        }\n    }\n\n    public static void delay() {\n        try {\n            Thread.sleep(Duration.ofSeconds(2));\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n### Key ExecutorService Implementations\n\n1. **ThreadPoolExecutor**: General-purpose thread pool\n2. **ScheduledThreadPoolExecutor**: For scheduled tasks\n3. **ForkJoinPool**: For divide-and-conquer algorithms\n\n### Important Note About try-with-resources\n\nWhen using `try-with-resources` with ExecutorService:\n\n- The `close()` method calls `shutdown()` and **blocks** until all submitted tasks finish\n- This can make your code appear synchronous even though tasks run on separate threads\n- For truly non-blocking behavior, manage the executor lifecycle manually\n\n## Callable and Future Interfaces\n\n### Moving Beyond Runnable\n\nWhile `Runnable` is great for fire-and-forget tasks, often you need to:\n\n- Return a value from your task\n- Handle exceptions properly\n- Check if the task is complete\n\n### Callable Interface\n\n```java\npublic class ThreadPoolExample {\n    public static void main(String[] args) {\n        try (var exec = Executors.newFixedThreadPool(2)) {\n            // Submit a Callable that returns a value\n            var result = exec.submit(() -> {\n                System.out.println(Thread.currentThread().getName());\n                LongTask.simulate();\n                return 1; // Return value\n            });\n\n            try {\n                // get() is a BLOCKING call\n                var res = result.get();\n                System.out.println(res);\n            } catch (InterruptedException | ExecutionException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}\n```\n","slug":"Threads and concurrent Programming","title":"Threads and Concurrent Programming","section":"A Quick Refresher","icon":"rotate","filePath":"/home/runner/work/complete-intro-to-spring-and-springBoot/complete-intro-to-spring-and-springBoot/lessons/00-A quick Refresher/F-Threads and concurrent Programming.md","nextSlug":"/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Async java","prevSlug":"/complete-intro-to-spring-and-springBoot/lessons/A quick Refresher/Functional programming"}},"__N_SSG":true}